// tslint:disable
/// <reference path="./custom.d.ts" />
/**
 * finAPI RESTful Services
 * finAPI RESTful Services
 *
 * The version of the OpenAPI document: v1.86.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as globalImportUrl from "url";
import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError
} from "./base";

/**
 * User access token info
 * @export
 * @interface AccessToken
 */
export interface AccessToken {
  /**
   * Token type (it\'s always \'bearer\')
   * @type {string}
   * @memberof AccessToken
   */
  tokenType: string;
  /**
   * Requested scopes (it\'s always \'all\')
   * @type {string}
   * @memberof AccessToken
   */
  scope: string;
  /**
   * Access token. Token has a length of up to 128 characters.
   * @type {string}
   * @memberof AccessToken
   */
  accessToken: string;
  /**
   * Refresh token. Only set in case of grant_type=\'password\'. Token has a length of up to 128 characters.
   * @type {string}
   * @memberof AccessToken
   */
  refreshToken?: string;
  /**
   * Expiration time in seconds. A value of 0 means that the token never expires (unless it is explicitly invalidated, e.g. by revocation, or when a user gets locked).
   * @type {number}
   * @memberof AccessToken
   */
  expiresIn: number;
}
/**
 * Container for a bank account\'s data
 * @export
 * @interface Account
 */
export interface Account {
  /**
   * Account identifier
   * @type {number}
   * @memberof Account
   */
  id: number;
  /**
   * Identifier of the bank connection that this account belongs to
   * @type {number}
   * @memberof Account
   */
  bankConnectionId: number;
  /**
   * Account name
   * @type {string}
   * @memberof Account
   */
  accountName?: string;
  /**
   * Account\'s IBAN. Note that this field can change from \'null\' to a value - or vice versa - any time when the account is being updated. This is subject to changes within the bank\'s internal account management.
   * @type {string}
   * @memberof Account
   */
  iban?: string;
  /**
   * (National) account number. Note that this value might change whenever the account is updated (for example, leading zeros might be added or removed).
   * @type {string}
   * @memberof Account
   */
  accountNumber: string;
  /**
   * Account\'s sub-account-number. Note that this field can change from \'null\' to a value - or vice versa - any time when the account is being updated. This is subject to changes within the bank\'s internal account management.
   * @type {string}
   * @memberof Account
   */
  subAccountNumber?: string;
  /**
   * Name of the account holder
   * @type {string}
   * @memberof Account
   */
  accountHolderName?: string;
  /**
   * Bank\'s internal identification of the account holder. Note that if your client has no license for processing this field, it will always be \'XXXXX\'
   * @type {string}
   * @memberof Account
   */
  accountHolderId?: string;
  /**
   * Account\'s currency
   * @type {string}
   * @memberof Account
   */
  accountCurrency?: string;
  /**
   * Identifier of the account\'s type. Note that, in general, the type of an account can change any time when the account is being updated. This is subject to changes within the bank\'s internal account management. However, if the account\'s type has previously been changed explicitly (via the PATCH method), then the explicitly set type will NOT be automatically changed anymore, even if the type has changed on the bank side. <br/>Note: this field is deprecated and would be removed at some point. Please refer to new field in \'accountType\' instead.<br/>1 = Checking,<br/>2 = Savings,<br/>3 = CreditCard,<br/>4 = Security,<br/>5 = Loan,<br/>6 = Pocket (DEPRECATED; will not be returned for any account unless this type has explicitly been set via PATCH),<br/>7 = Membership,<br/>8 = Bausparen<br/>
   * @type {number}
   * @memberof Account
   */
  accountTypeId: number;
  /**
   * Name of the account\'s type<br/>Note: this field is deprecated and would be removed at some point. Please refer to new field in \'accountType\' instead.
   * @type {string}
   * @memberof Account
   */
  accountTypeName: string;
  /**
   * An account type.<br/><br/>Checking,<br/>Savings,<br/>CreditCard,<br/>Security,<br/>Loan,<br/>Pocket (DEPRECATED; will not be returned for any account unless this type has explicitly been set via PATCH),<br/>Membership,<br/>Bausparen<br/><br/>
   * @type {string}
   * @memberof Account
   */
  accountType?: AccountAccountTypeEnum;
  /**
   * Current account balance
   * @type {number}
   * @memberof Account
   */
  balance?: number;
  /**
   * Current overdraft
   * @type {number}
   * @memberof Account
   */
  overdraft?: number;
  /**
   * Overdraft limit
   * @type {number}
   * @memberof Account
   */
  overdraftLimit?: number;
  /**
   * Current available funds. Note that this field is only set if finAPI can make a definite statement about the current available funds. This might not always be the case, for example if there is not enough information available about the overdraft limit and current overdraft.
   * @type {number}
   * @memberof Account
   */
  availableFunds?: number;
  /**
   * THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the corresponding field in \'interfaces\' instead.<br/><br/>Timestamp of when the account was last successfully updated (or initially imported); more precisely: time when the account data (balance and positions) has been stored into the finAPI databases. The value is returned in the format \'YYYY-MM-DD HH:MM:SS.SSS\' (german time).
   * @type {string}
   * @memberof Account
   */
  lastSuccessfulUpdate?: string;
  /**
   * THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the corresponding field in \'interfaces\' instead.<br/><br/>Timestamp of when the account was last tried to be updated (or initially imported); more precisely: time when the update (or initial import) was triggered. The value is returned in the format \'YYYY-MM-DD HH:MM:SS.SSS\' (german time).
   * @type {string}
   * @memberof Account
   */
  lastUpdateAttempt?: string;
  /**
   * Indicating whether this account is \'new\' or not. Any newly imported account will have this flag initially set to true, and remain so until you set it to false (see PATCH /accounts/<id>). How you use this field is up to your interpretation, however it is recommended to set the flag to false for all accounts right after the initial import of the bank connection. This way, you will be able recognize accounts that get newly imported during a later update of the bank connection, by checking for any accounts with the flag set to true right after an update.
   * @type {boolean}
   * @memberof Account
   */
  isNew: boolean;
  /**
   * THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the \'status\' field in \'interfaces\' instead.<br/><br/>The current status of the account. Possible values are:<br/>&bull; <code>UPDATED</code> means that the account is up to date from finAPI\'s point of view. This means that no current import/update is running, and the previous import/update could successfully update the account\'s data (e.g. transactions and securities), and the bank given balance matched the transaction\'s calculated sum, meaning that no adjusting entry (\'Zwischensaldo\' transaction) was inserted.<br/>&bull; <code>UPDATED_FIXED</code> means that the account is up to date from finAPI\'s point of view (no current import/update is running, and the previous import/update could successfully update the account\'s data), BUT there was a deviation in the bank given balance which was fixed by adding an adjusting entry (\'Zwischensaldo\' transaction).<br/>&bull; <code>DOWNLOAD_IN_PROGRESS</code> means that the account\'s data is currently being imported/updated.<br/>&bull; <code>DOWNLOAD_FAILED</code> means that the account data could not get successfully imported or updated. Possible reasons: finAPI could not get the account\'s balance, or it could not parse all transactions/securities, or some internal error has occurred. Also, it could mean that finAPI could not even get to the point of receiving the account data from the bank server, for example because of incorrect login credentials or a network problem. Note however that when we get a balance and just an empty list of transactions or securities, then this is regarded as valid and successful download. The reason for this is that for some accounts that have little activity, we may actually get no recent transactions but only a balance.<br/>&bull; <code>DEPRECATED</code> means that the account could no longer get matched with any account from the bank server. This can mean either that the account was terminated by the user and is no longer sent by the bank server, or that finAPI could no longer match it because the account\'s data (name, type, iban, account number, etc.) has been changed by the bank.
   * @type {string}
   * @memberof Account
   */
  status: AccountStatusEnum;
  /**
   * THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the \'capabilities\' in \'interfaces\' field instead.<br/><br/>List of orders that this account supports. Possible values are:<br/><br/>&bull; <code>SEPA_MONEY_TRANSFER</code> - single money transfer<br/>&bull; <code>SEPA_COLLECTIVE_MONEY_TRANSFER</code> - collective money transfer<br/>&bull; <code>SEPA_BASIC_DIRECT_DEBIT</code> - single basic direct debit<br/>&bull; <code>SEPA_BASIC_COLLECTIVE_DIRECT_DEBIT</code> - collective basic direct debit<br/>&bull; <code>SEPA_B2B_DIRECT_DEBIT</code> - single Business-To-Business direct debit<br/>&bull; <code>SEPA_B2B_COLLECTIVE_DIRECT_DEBIT</code> - collective Business-To-Business direct debit<br/><br/>Note that this list may be empty if the account is not supporting any of the above orders. Also note that the list is refreshed each time the account is being updated, so available orders may get added or removed in the course of an account update.
   * @type {Array<string>}
   * @memberof Account
   */
  supportedOrders: Array<AccountSupportedOrdersEnum>;
  /**
   * Set of interfaces to which this account is connected
   * @type {Array<AccountInterface>}
   * @memberof Account
   */
  interfaces?: Array<AccountInterface>;
  /**
   * List of clearing accounts that relate to this account. Clearing accounts can be used for money transfers (see field \'clearingAccountId\' of the \'Request SEPA Money Transfer\' service).<br><br>NOTE: This field is deprecated and will be removed at some point.
   * @type {Array<ClearingAccountData>}
   * @memberof Account
   */
  clearingAccounts?: Array<ClearingAccountData>;
}

/**
 * @export
 * @enum {string}
 */
export enum AccountAccountTypeEnum {
  Checking = "Checking",
  Savings = "Savings",
  CreditCard = "CreditCard",
  Security = "Security",
  Loan = "Loan",
  Pocket = "Pocket",
  Membership = "Membership",
  Bausparen = "Bausparen"
}
/**
 * @export
 * @enum {string}
 */
export enum AccountStatusEnum {
  UPDATED = "UPDATED",
  UPDATEDFIXED = "UPDATED_FIXED",
  DOWNLOADINPROGRESS = "DOWNLOAD_IN_PROGRESS",
  DOWNLOADFAILED = "DOWNLOAD_FAILED",
  DEPRECATED = "DEPRECATED"
}
/**
 * @export
 * @enum {string}
 */
export enum AccountSupportedOrdersEnum {
  MONEYTRANSFER = "SEPA_MONEY_TRANSFER",
  COLLECTIVEMONEYTRANSFER = "SEPA_COLLECTIVE_MONEY_TRANSFER",
  BASICDIRECTDEBIT = "SEPA_BASIC_DIRECT_DEBIT",
  BASICCOLLECTIVEDIRECTDEBIT = "SEPA_BASIC_COLLECTIVE_DIRECT_DEBIT",
  B2BDIRECTDEBIT = "SEPA_B2B_DIRECT_DEBIT",
  B2BCOLLECTIVEDIRECTDEBIT = "SEPA_B2B_COLLECTIVE_DIRECT_DEBIT"
}

/**
 * Account interface details
 * @export
 * @interface AccountInterface
 */
export interface AccountInterface {
  /**
   * Bank interface. Possible values:<br><br>&bull; <code>FINTS_SERVER</code> - finAPI will download account data via the bank\'s FinTS interface.<br>&bull; <code>WEB_SCRAPER</code> - finAPI will parse account data from the bank\'s online banking website.<br>&bull; <code>XS2A</code> - finAPI will download account data via the bank\'s XS2A interface.<br>
   * @type {string}
   * @memberof AccountInterface
   */
  _interface: AccountInterfaceInterfaceEnum;
  /**
   * The current status of the account from the perspective of this interface. Possible values are:<br/>&bull; <code>UPDATED</code> means that the account is up to date from finAPI\'s point of view. This means that no current import/update is running, and the previous import/update had successfully updated the account\'s data (e.g. transactions and securities), and the bank given balance matched the transaction\'s calculated sum, meaning that no adjusting entry (\'Zwischensaldo\' transaction) was inserted.<br/>&bull; <code>UPDATED_FIXED</code> means that the account is up to date from finAPI\'s point of view (no current import/update is running, and the previous import/update had successfully updated the account\'s data), BUT there was a deviation in the bank given balance which was fixed by adding an adjusting entry (\'Zwischensaldo\' transaction).<br/>&bull; <code>DOWNLOAD_IN_PROGRESS</code> means that the account\'s data is currently being imported/updated.<br/>&bull; <code>DOWNLOAD_FAILED</code> means that the account data was not successfully imported or updated. Possible reasons: finAPI could not get the account\'s balance, or it could not parse all transactions/securities, or some internal error has occurred. Also, it could mean that finAPI could not even get to the point of receiving the account data from the bank server, for example because of incorrect login credentials or a network problem. Note however that when we get a balance and just an empty list of transactions or securities, then this is regarded as valid and successful download. The reason for this is that for some accounts that have little activity, we may actually get no recent transactions but only a balance.<br/>&bull; <code>DEPRECATED</code> means that the account could no longer be matched with any account from the bank server. This can mean either that the account was terminated by the user and is no longer sent by the bank server, or that finAPI could no longer match it because the account\'s data (name, type, iban, account number, etc.) has been changed by the bank.
   * @type {string}
   * @memberof AccountInterface
   */
  status: AccountInterfaceStatusEnum;
  /**
   * List of account capabilities that this interface supports. Possible values are:<br/><br/>&bull; <code>DATA_DOWNLOAD</code> - download of balance and transactions/securities<br/>&bull; <code>IBAN_ONLY_SEPA_MONEY_TRANSFER</code> - money transfer where the recipient\'s account is defined just by the IBAN<br/>&bull; <code>IBAN_ONLY_SEPA_DIRECT_DEBIT</code> - direct debit where the debitor\'s account is defined just by the IBAN<br/>&bull; <code>SEPA_MONEY_TRANSFER</code> - single money transfer<br/>&bull; <code>SEPA_COLLECTIVE_MONEY_TRANSFER</code> - collective money transfer<br/>&bull; <code>SEPA_BASIC_DIRECT_DEBIT</code> - single basic direct debit<br/>&bull; <code>SEPA_BASIC_COLLECTIVE_DIRECT_DEBIT</code> - collective basic direct debit<br/>&bull; <code>SEPA_B2B_DIRECT_DEBIT</code> - single Business-To-Business direct debit<br/>&bull; <code>SEPA_B2B_COLLECTIVE_DIRECT_DEBIT</code> - collective Business-To-Business direct debit<br/><br/>Note that this list may be empty if the interface is not supporting any of the above capabilities. Also note that the list may be refreshed each time the account is being updated though this interface, so available capabilities may get added or removed in the course of an account update.<br/><br/>
   * @type {Array<string>}
   * @memberof AccountInterface
   */
  capabilities: Array<AccountInterfaceCapabilitiesEnum>;
  /**
   * Timestamp of when the account was last successfully updated using this interface (or initially imported); more precisely: time when the account data (balance and positions) has been stored into the finAPI databases. The value is returned in the format \'YYYY-MM-DD HH:MM:SS.SSS\' (german time).
   * @type {string}
   * @memberof AccountInterface
   */
  lastSuccessfulUpdate?: string;
  /**
   * Timestamp of when the account was last tried to be updated using this interface (or initially imported); more precisely: time when the update (or initial import) was triggered. The value is returned in the format \'YYYY-MM-DD HH:MM:SS.SSS\' (german time).
   * @type {string}
   * @memberof AccountInterface
   */
  lastUpdateAttempt?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum AccountInterfaceInterfaceEnum {
  WEBSCRAPER = "WEB_SCRAPER",
  FINTSSERVER = "FINTS_SERVER",
  XS2A = "XS2A"
}
/**
 * @export
 * @enum {string}
 */
export enum AccountInterfaceStatusEnum {
  UPDATED = "UPDATED",
  UPDATEDFIXED = "UPDATED_FIXED",
  DOWNLOADINPROGRESS = "DOWNLOAD_IN_PROGRESS",
  DOWNLOADFAILED = "DOWNLOAD_FAILED",
  DEPRECATED = "DEPRECATED"
}
/**
 * @export
 * @enum {string}
 */
export enum AccountInterfaceCapabilitiesEnum {
  DATADOWNLOAD = "DATA_DOWNLOAD",
  IBANONLYSEPAMONEYTRANSFER = "IBAN_ONLY_SEPA_MONEY_TRANSFER",
  IBANONLYSEPADIRECTDEBIT = "IBAN_ONLY_SEPA_DIRECT_DEBIT",
  SEPAMONEYTRANSFER = "SEPA_MONEY_TRANSFER",
  SEPACOLLECTIVEMONEYTRANSFER = "SEPA_COLLECTIVE_MONEY_TRANSFER",
  SEPABASICDIRECTDEBIT = "SEPA_BASIC_DIRECT_DEBIT",
  SEPABASICCOLLECTIVEDIRECTDEBIT = "SEPA_BASIC_COLLECTIVE_DIRECT_DEBIT",
  SEPAB2BDIRECTDEBIT = "SEPA_B2B_DIRECT_DEBIT",
  SEPAB2BCOLLECTIVEDIRECTDEBIT = "SEPA_B2B_COLLECTIVE_DIRECT_DEBIT"
}

/**
 * Container for data of multiple bank accounts
 * @export
 * @interface AccountList
 */
export interface AccountList {
  /**
   * List of bank accounts
   * @type {Array<Account>}
   * @memberof AccountList
   */
  accounts?: Array<Account>;
}
/**
 * Container for an account\'s name, type and \'isNew\' flag\'.
 * @export
 * @interface AccountParams
 */
export interface AccountParams {
  /**
   * Account name. Maximum length is 512.
   * @type {string}
   * @memberof AccountParams
   */
  accountName?: string;
  /**
   * Identifier of account type.<br/><br/>1 = Checking,<br/>2 = Savings,<br/>3 = CreditCard,<br/>4 = Security,<br/>5 = Loan,<br/>6 = Pocket (DEPRECATED; will not be returned for any account unless this type has explicitly been set via PATCH),<br/>7 = Membership,<br/>8 = Bausparen<br/><br/><br/> Note: this field is deprecated and will be removed at some point. Please refer to the accountType field instead.
   * @type {number}
   * @memberof AccountParams
   */
  accountTypeId?: number;
  /**
   * An account type.<br/><br/>Checking,<br/>Savings,<br/>CreditCard,<br/>Security,<br/>Loan,<br/>Pocket (DEPRECATED; will not be returned for any account unless this type has explicitly been set via PATCH),<br/>Membership,<br/>Bausparen<br/><br/>
   * @type {string}
   * @memberof AccountParams
   */
  accountType?: AccountParamsAccountTypeEnum;
  /**
   * Whether this account should be flagged as \'new\' or not. Any newly imported account will have this flag initially set to true, and remain so until you set it to false (see PATCH /accounts/<id>). How you use this field is up to your interpretation, however it is recommended to set the flag to false for all accounts right after the initial import of the bank connection. This way, you will be able recognize accounts that get newly imported during a later update of the bank connection, by checking for any accounts with the flag set to true after every update of the bank connection.
   * @type {boolean}
   * @memberof AccountParams
   */
  isNew?: boolean;
}

/**
 * @export
 * @enum {string}
 */
export enum AccountParamsAccountTypeEnum {
  Checking = "Checking",
  Savings = "Savings",
  CreditCard = "CreditCard",
  Security = "Security",
  Loan = "Loan",
  Pocket = "Pocket",
  Membership = "Membership",
  Bausparen = "Bausparen"
}

/**
 * Account reference data
 * @export
 * @interface AccountReference
 */
export interface AccountReference {
  /**
   * The account\'s IBAN
   * @type {string}
   * @memberof AccountReference
   */
  iban: string;
}
/**
 *
 * @export
 * @interface BadCredentialsError
 */
export interface BadCredentialsError {
  /**
   * Error type
   * @type {string}
   * @memberof BadCredentialsError
   */
  error: string;
  /**
   * Error description
   * @type {string}
   * @memberof BadCredentialsError
   */
  errorDescription: string;
}
/**
 * Container for a bank\'s data
 * @export
 * @interface Bank
 */
export interface Bank {
  /**
   * Bank identifier.<br/><br/>NOTE: Do NOT assume that the identifiers of banks are the same across different finAPI environments. In fact, the identifiers may change whenever a new finAPI version is released, even within the same environment. The identifiers are meant to be used for references within the finAPI services only, but not for hard-coding them in your application. If you need to hard-code the usage of a certain bank within your application, please instead refer to the BLZ.
   * @type {number}
   * @memberof Bank
   */
  id: number;
  /**
   * Name of bank
   * @type {string}
   * @memberof Bank
   */
  name: string;
  /**
   * THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the \'loginHint\' in the \'interfaces\' instead.<br/><br/>Login hint. Contains a German message for the user that explains what kind of credentials are expected.<br/><br/>Please note that it is strongly recommended to always show the login hint to the user if there is one, as the credentials that finAPI requires for the bank might be different to the credentials that the user knows from the bank\'s website.<br/><br/>Also note that the contents of this field should always be interpreted as HTML, as the text might contain HTML tags for highlighted words, paragraphs, etc.
   * @type {string}
   * @memberof Bank
   */
  loginHint?: string;
  /**
   * BIC of bank
   * @type {string}
   * @memberof Bank
   */
  bic?: string;
  /**
   * THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the \'blz\' field instead.
   * @type {Array<string>}
   * @memberof Bank
   */
  blzs: Array<string>;
  /**
   * BLZ of bank
   * @type {string}
   * @memberof Bank
   */
  blz: string;
  /**
   * Bank location (two-letter country code; ISO 3166 ALPHA-2). Note that when this field is not set, it means that this bank depicts an international institute which is not bound to any specific country.
   * @type {string}
   * @memberof Bank
   */
  location?: string;
  /**
   * City that this bank is located in. Note that this field may not be set for some banks.
   * @type {string}
   * @memberof Bank
   */
  city?: string;
  /**
   * THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Please refer to field \'interfaces\' instead.<br/><br/>Whether this bank is supported by finAPI, i.e. whether you can import/update a bank connection of this bank.
   * @type {boolean}
   * @memberof Bank
   */
  isSupported: boolean;
  /**
   * If true, then this bank does not depict a real bank, but rather a testing endpoint provided by a bank or by finAPI. You probably want to regard these banks only during the development of your application, but not in production. You can filter out these banks in production by making sure that the \'isTestBank\' parameter is always set to \'false\' whenever your application is calling the \'Get and search all banks\' service.
   * @type {boolean}
   * @memberof Bank
   */
  isTestBank: boolean;
  /**
   * Popularity of this bank with your users (mandator-wide, i.e. across all of your clients). The value equals the number of bank connections that are currently imported for this bank across all of your users (which means it is a constantly adjusting value). You can use this field for statistical evaluation, and also for ordering bank search results (see service \'Get and search all banks\').
   * @type {number}
   * @memberof Bank
   */
  popularity: number;
  /**
   * THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the \'health\' in the \'interfaces\' instead. <br/><br/>The health status of this bank. This is a value between 0 and 100, depicting the percentage of successful communication attempts with this bank during the latest couple of bank connection imports or updates (across the entire finAPI system). Note that \'successful\' means that there was no technical error trying to establish a communication with the bank. Non-technical errors (like incorrect credentials) are regarded successful communication attempts.
   * @type {number}
   * @memberof Bank
   */
  health: number;
  /**
   * THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the \'loginCredentials\' in the \'interfaces\' instead.<br/><br/>Label for the user ID login field, as it is called on the bank\'s website (e.g. \"Nutzerkennung\"). If this field is set (i.e. not null) then you should prompt your users to enter the required data in a text field which you can label with this field\'s value.
   * @type {string}
   * @memberof Bank
   */
  loginFieldUserId?: string;
  /**
   * THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the \'loginCredentials\' in the \'interfaces\' instead.<br/><br/>Label for the customer ID login field, as it is called on the bank\'s website (e.g. \"Kundennummer\"). If this field is set (i.e. not null) then you should prompt your users to enter the required data in a text field which you can label with this field\'s value.
   * @type {string}
   * @memberof Bank
   */
  loginFieldCustomerId?: string;
  /**
   * THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the \'loginCredentials\' in the \'interfaces\' instead.<br/><br/>Label for the PIN field, as it is called on the bank\'s website (mostly \"PIN\"). If this field is set (i.e. not null) then you should prompt your users to enter the required data in a text field which you can label with this field\'s value.
   * @type {string}
   * @memberof Bank
   */
  loginFieldPin?: string;
  /**
   * THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the \'isVolatile\' field of the \'loginCredentials\' in \'interfaces\' instead.<br/><br/>Whether the PINs that are used for authentication with the bank are volatile. If the PINs are volatile, it means that a PIN is usually valid only for a single authentication, and is then invalidated. If a bank uses volatile PINs, it is strongly inadvisable to store PINs in finAPI, as a stored PIN will not work for future authentications.<br><br>NOTE: This field is deprecated and will be removed at some point.
   * @type {boolean}
   * @memberof Bank
   */
  pinsAreVolatile: boolean;
  /**
   * THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the \'isSecret\' field of the \'loginCredentials\' in \'interfaces\' instead.<br/><br/>Whether the banking customer ID has to be treated like a password. Certain banks require a second password (besides the PIN) for the user to login. In this case your application should use a password input field when prompting users for their credentials.<br><br>NOTE: This field is deprecated and will be removed at some point.
   * @type {boolean}
   * @memberof Bank
   */
  isCustomerIdPassword: boolean;
  /**
   * THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the \'interfaces\' instead.<br/><br/>List of the data sources that finAPI will use for data download for this bank. Possible values:<br><br>&bull; <code>FINTS_SERVER</code> - means that finAPI will download data via the bank\'s FinTS interface.<br>&bull; <code>WEB_SCRAPER</code> - means that finAPI will parse data from the bank\'s online banking website.<br><br>Note that this list will be empty for non-supported banks. Note also that web scraping might be disabled for your client (see GET /clientConfiguration). When this is the case, then finAPI will not use the web scraper for data download, and if the web scraper is the only supported data source of this bank, then finAPI will not allow to download any data for this bank at all (for details, see POST /bankConnections/import and POST /bankConnections/update).
   * @type {Array<string>}
   * @memberof Bank
   */
  supportedDataSources: Array<BankSupportedDataSourcesEnum>;
  /**
   * Set of interfaces that finAPI can use to connect to the bank. Note that this set will be empty for non-supported banks. Note also that the WEB_SCRAPER interface might be disabled for your client (see GET /clientConfiguration). When this is the case, then finAPI will not use the web scraper for data download, and if the web scraper is the only supported interface of this bank, then finAPI will not allow to download any data for this bank at all (for details, see POST /bankConnections/import and POST /bankConnections/update).
   * @type {Array<BankInterface>}
   * @memberof Bank
   */
  interfaces?: Array<BankInterface>;
  /**
   * THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the \'lastCommunicationAttempt\' in the \'interfaces\' instead. <br/><br/>Time of the last communication attempt with this bank during a bank connection import or update (across the entire finAPI system). The value is returned in the format \'YYYY-MM-DD HH:MM:SS.SSS\' (german time).
   * @type {string}
   * @memberof Bank
   */
  lastCommunicationAttempt?: string;
  /**
   * THIS FIELD IS DEPRECATED AND WILL BE REMOVED. Refer to the \'lastSuccessfulCommunication\' in the \'interfaces\' instead. <br/><br/>Time of the last successful communication with this bank during a bank connection import or update (across the entire finAPI system). The value is returned in the format \'YYYY-MM-DD HH:MM:SS.SSS\' (german time).
   * @type {string}
   * @memberof Bank
   */
  lastSuccessfulCommunication?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum BankSupportedDataSourcesEnum {
  WEBSCRAPER = "WEB_SCRAPER",
  FINTSSERVER = "FINTS_SERVER"
}

/**
 * Container for a bank connection\'s data
 * @export
 * @interface BankConnection
 */
export interface BankConnection {
  /**
   * Bank connection identifier
   * @type {number}
   * @memberof BankConnection
   */
  id: number;
  /**
   * Identifier of the bank that this connection belongs to. NOTE: This field is DEPRECATED and will get removed at some point. Please refer to the \'bank\' field instead.
   * @type {number}
   * @memberof BankConnection
   */
  bankId: number;
  /**
   * Custom name for the bank connection. You can set this field with the \'Edit a bank connection\' service, as well as during the initial import of the bank connection. Maximum length is 64.
   * @type {string}
   * @memberof BankConnection
   */
  name?: string;
  /**
   * NOTE: This field is deprecated and will be removed at some point. Please refer to the \'loginCredentials\' in the \'interfaces\' field instead.<br><br>Stored online banking user ID credential. This field may be null for the \'demo connection\'. If your client has no license for processing banking credentials then a banking user ID will always be \'XXXXX\'
   * @type {string}
   * @memberof BankConnection
   */
  bankingUserId?: string;
  /**
   * NOTE: This field is deprecated and will be removed at some point. Please refer to the \'loginCredentials\' in the \'interfaces\' field instead.<br><br>Stored online banking customer ID credential. If your client has no license for processing banking credentials or if this field contains a value that requires password protection (see field ‘isCustomerIdPassword’ in Bank Resource) then the banking customer ID will always be \'XXXXX
   * @type {string}
   * @memberof BankConnection
   */
  bankingCustomerId?: string;
  /**
   * NOTE: This field is deprecated and will be removed at some point. Please refer to the \'loginCredentials\' in the \'interfaces\' field instead.<br><br>Stored online banking PIN. If a PIN is stored, this will always be \'XXXXX\'
   * @type {string}
   * @memberof BankConnection
   */
  bankingPin?: string;
  /**
   * Bank connection type
   * @type {string}
   * @memberof BankConnection
   */
  type: BankConnectionTypeEnum;
  /**
   * Current status of data download (account balances and transactions/securities). The POST /bankConnections/import and POST /bankConnections/<id>/update services will set this flag to IN_PROGRESS before they return. Once the import or update has finished, the status will be changed to READY.
   * @type {string}
   * @memberof BankConnection
   */
  updateStatus: BankConnectionUpdateStatusEnum;
  /**
   * Current status of transactions categorization. The asynchronous download process that is triggered by a call of the POST /bankConnections/import and POST /bankConnections/<id>/update services (and also by finAPI\'s auto update, if enabled) will set this flag to PENDING once the download has finished and a categorization is scheduled for the imported transactions. A separate categorization thread will then start to categorize the transactions (during this process, the status is IN_PROGRESS). When categorization has finished, the status will be (re-)set to READY. Note that the current categorization status should only be queried after the download has finished, i.e. once the download status has switched from IN_PROGRESS to READY.
   * @type {string}
   * @memberof BankConnection
   */
  categorizationStatus: BankConnectionCategorizationStatusEnum;
  /**
   *
   * @type {UpdateResult}
   * @memberof BankConnection
   */
  lastManualUpdate?: UpdateResult;
  /**
   *
   * @type {UpdateResult}
   * @memberof BankConnection
   */
  lastAutoUpdate?: UpdateResult;
  /**
   * NOTE: This field is deprecated and will be removed at some point. Please refer to the account capabilities instead.<br><br>Whether this bank connection accepts money transfer requests where the recipient\'s account is defined just by the IBAN (without an additional BIC). This field is re-evaluated each time this bank connection is updated. <br/>See also: /accounts/requestSepaMoneyTransfer
   * @type {boolean}
   * @memberof BankConnection
   */
  ibanOnlyMoneyTransferSupported: boolean;
  /**
   * NOTE: This field is deprecated and will be removed at some point. Please refer to the account capabilities instead.<br><br>Whether this bank connection accepts direct debit requests where the debitor\'s account is defined just by the IBAN (without an additional BIC). This field is re-evaluated each time this bank connection is updated. <br/>See also: /accounts/requestSepaDirectDebit
   * @type {boolean}
   * @memberof BankConnection
   */
  ibanOnlyDirectDebitSupported: boolean;
  /**
   * NOTE: This field is deprecated and will be removed at some point. Please refer to the account capabilities instead.<br><br>Whether this bank connection supports submitting collective money transfers. This field is re-evaluated each time this bank connection is updated. <br/>See also: /accounts/requestSepaMoneyTransfer
   * @type {boolean}
   * @memberof BankConnection
   */
  collectiveMoneyTransferSupported: boolean;
  /**
   * NOTE: This field is deprecated and will be removed at some point. Please refer to corresponding field in \'interfaces\' instead.<br><br>The default two-step-procedure. Must match one of the available \'procedureId\'s from the \'twoStepProcedures\' list. When this field is set, you can execute two-step-procedures (accounts/requestSepaMoneyTransfer or /requestSepaDirectDebit) without having to explicitly set a procedure. finAPI will use the default procedure in such cases. Note that the list of available procedures of a bank connection may change as a result of an update of the connection, and if this field references a procedure that is no longer available after an update, finAPI will automatically clear the default procedure (set it to null).s
   * @type {string}
   * @memberof BankConnection
   */
  defaultTwoStepProcedureId?: string;
  /**
   * NOTE: This field is deprecated and will be removed at some point. Please refer to corresponding field in \'interfaces\' instead.<br><br>Available two-step-procedures for this bank connection, used for submitting a money transfer or direct debit request (see /accounts/requestSepaMoneyTransfer or /requestSepaDirectDebit). The available two-step-procedures are re-evaluated each time this bank connection is updated (/bankConnections/update). This means that this list may change as a result of an update.
   * @type {Array<TwoStepProcedure>}
   * @memberof BankConnection
   */
  twoStepProcedures?: Array<TwoStepProcedure>;
  /**
   * Set of interfaces that are connected for this bank connection.
   * @type {Array<BankConnectionInterface>}
   * @memberof BankConnection
   */
  interfaces?: Array<BankConnectionInterface>;
  /**
   * Identifiers of the accounts that belong to this bank connection
   * @type {Array<number>}
   * @memberof BankConnection
   */
  accountIds: Array<number>;
  /**
   * Information about the owner(s) of the bank connection
   * @type {Array<BankConnectionOwner>}
   * @memberof BankConnection
   */
  owners?: Array<BankConnectionOwner>;
  /**
   *
   * @type {Bank}
   * @memberof BankConnection
   */
  bank: Bank;
  /**
   * This field indicates whether the last communication with the bank failed with an error that requires the user\'s attention or multi-step authentication error. If \'furtherLoginNotRecommended\' is true, finAPI will stop auto updates of this bank connection to mitigate the risk of the user\'s bank account getting locked by the bank. Every communication with the bank (via updates, money_transfers, direct debits. etc.) can change the value of this flag. If this field is true, we recommend the user to check his credentials and try a manual update of the bank connection. If the update is successful without any multi-step authentication error, the \'furtherLoginNotRecommended\' field will be set to false and the bank connection will be reincluded in the next batch update process. A manual update of the bank connection with incorrect credentials or if multi-step authentication error happens will set this field to true and lead to the exclusion of the bank connection from the following batch updates.
   * @type {boolean}
   * @memberof BankConnection
   */
  furtherLoginNotRecommended: boolean;
}

/**
 * @export
 * @enum {string}
 */
export enum BankConnectionTypeEnum {
  ONLINE = "ONLINE",
  DEMO = "DEMO"
}
/**
 * @export
 * @enum {string}
 */
export enum BankConnectionUpdateStatusEnum {
  INPROGRESS = "IN_PROGRESS",
  READY = "READY"
}
/**
 * @export
 * @enum {string}
 */
export enum BankConnectionCategorizationStatusEnum {
  INPROGRESS = "IN_PROGRESS",
  PENDING = "PENDING",
  READY = "READY"
}

/**
 * Resource representing a bank connection interface
 * @export
 * @interface BankConnectionInterface
 */
export interface BankConnectionInterface {
  /**
   * Bank interface. Possible values:<br><br>&bull; <code>FINTS_SERVER</code> - means that finAPI will download data via the bank\'s FinTS interface.<br>&bull; <code>WEB_SCRAPER</code> - means that finAPI will parse data from the bank\'s online banking website.<br>&bull; <code>XS2A</code> - means that finAPI will download data via the bank\'s XS2A interface.<br>
   * @type {string}
   * @memberof BankConnectionInterface
   */
  _interface: BankConnectionInterfaceInterfaceEnum;
  /**
   * Login fields for this interface, in the order that we suggest to show them to the user.
   * @type {Array<LoginCredentialResource>}
   * @memberof BankConnectionInterface
   */
  loginCredentials?: Array<LoginCredentialResource>;
  /**
   * The default two-step-procedure for this interface. Must match one of the available \'procedureId\'s from the \'twoStepProcedures\' list. When this field is set, then finAPI will automatically try to select the procedure wherever applicable. Note that the list of available procedures of a bank connection may change as a result of an update of the connection, and if this field references a procedure that is no longer available after an update, finAPI will automatically clear the default procedure (set it to null).
   * @type {string}
   * @memberof BankConnectionInterface
   */
  defaultTwoStepProcedureId?: string;
  /**
   * Available two-step-procedures in this interface, used for submitting a money transfer or direct debit request (see /accounts/requestSepaMoneyTransfer or /requestSepaDirectDebit),or for multi-step-authentication during bank connection import or update. The available two-step-procedures mya be re-evaluated each time this bank connection is updated (/bankConnections/update). This means that this list may change as a result of an update.
   * @type {Array<TwoStepProcedure>}
   * @memberof BankConnectionInterface
   */
  twoStepProcedures?: Array<TwoStepProcedure>;
  /**
   *
   * @type {BankConsent}
   * @memberof BankConnectionInterface
   */
  aisConsent?: BankConsent;
  /**
   *
   * @type {UpdateResult}
   * @memberof BankConnectionInterface
   */
  lastManualUpdate?: UpdateResult;
  /**
   *
   * @type {UpdateResult}
   * @memberof BankConnectionInterface
   */
  lastAutoUpdate?: UpdateResult;
}

/**
 * @export
 * @enum {string}
 */
export enum BankConnectionInterfaceInterfaceEnum {
  WEBSCRAPER = "WEB_SCRAPER",
  FINTSSERVER = "FINTS_SERVER",
  XS2A = "XS2A"
}

/**
 * Container for data of multiple bank connections
 * @export
 * @interface BankConnectionList
 */
export interface BankConnectionList {
  /**
   * List of bank connections
   * @type {Array<BankConnection>}
   * @memberof BankConnectionList
   */
  connections: Array<BankConnection>;
}
/**
 * Container for a bank connection owner\'s data
 * @export
 * @interface BankConnectionOwner
 */
export interface BankConnectionOwner {
  /**
   * First name
   * @type {string}
   * @memberof BankConnectionOwner
   */
  firstName?: string;
  /**
   * Last name
   * @type {string}
   * @memberof BankConnectionOwner
   */
  lastName?: string;
  /**
   * Salutation
   * @type {string}
   * @memberof BankConnectionOwner
   */
  salutation?: string;
  /**
   * Title
   * @type {string}
   * @memberof BankConnectionOwner
   */
  title?: string;
  /**
   * Email
   * @type {string}
   * @memberof BankConnectionOwner
   */
  email?: string;
  /**
   * Date of birth (in format \'YYYY-MM-DD\')
   * @type {string}
   * @memberof BankConnectionOwner
   */
  dateOfBirth?: string;
  /**
   * Post code
   * @type {string}
   * @memberof BankConnectionOwner
   */
  postCode?: string;
  /**
   * Country
   * @type {string}
   * @memberof BankConnectionOwner
   */
  country?: string;
  /**
   * City
   * @type {string}
   * @memberof BankConnectionOwner
   */
  city?: string;
  /**
   * Street
   * @type {string}
   * @memberof BankConnectionOwner
   */
  street?: string;
  /**
   * House number
   * @type {string}
   * @memberof BankConnectionOwner
   */
  houseNumber?: string;
}
/**
 * Bank consent information
 * @export
 * @interface BankConsent
 */
export interface BankConsent {
  /**
   * Status of the consent. If <code>PRESENT</code>, it means that finAPI has a consent stored and can use it to connect to the bank. If <code>NOT_PRESENT</code>, finAPI will need to acquire a consent when connecting to the bank, which may require login credentials (either passed by the client, or stored in finAPI), and/or user involvement. Note that even when a consent is <code>PRESENT</code>, it may no longer be valid and finAPI will still have to acquire a new consent.
   * @type {string}
   * @memberof BankConsent
   */
  status: BankConsentStatusEnum;
  /**
   * Expiration time of the consent in the format \'YYYY-MM-DD HH:MM:SS.SSS\' (german time).
   * @type {string}
   * @memberof BankConsent
   */
  expiresAt: string;
}

/**
 * @export
 * @enum {string}
 */
export enum BankConsentStatusEnum {
  PRESENT = "PRESENT",
  NOTPRESENT = "NOT_PRESENT"
}

/**
 * Interface used to connect to a bank
 * @export
 * @interface BankInterface
 */
export interface BankInterface {
  /**
   * Bank interface. Possible values:<br><br>&bull; <code>FINTS_SERVER</code> - means that finAPI will download data via the bank\'s FinTS server.<br>&bull; <code>WEB_SCRAPER</code> - means that finAPI will parse data from the bank\'s online banking website.<br>&bull; <code>XS2A</code> - means that finAPI will download data via the bank\'s XS2A interface.<br>
   * @type {string}
   * @memberof BankInterface
   */
  _interface: BankInterfaceInterfaceEnum;
  /**
   *
   * @type {TppAuthenticationGroup}
   * @memberof BankInterface
   */
  tppAuthenticationGroup?: TppAuthenticationGroup;
  /**
   * Login credentials fields which should be shown to the user.
   * @type {Array<BankInterfaceLoginField>}
   * @memberof BankInterface
   */
  loginCredentials: Array<BankInterfaceLoginField>;
  /**
   * Set of interface properties/specifics. Possible values:<br><br>&bull; <code>REDIRECT_APPROACH</code> - means that the interface uses a redirect approach when authorizing the user. It requires you to pass the \'redirectUrl\' field in all services which define the field.<br/><br/>&bull; <code>DECOUPLED_APPROACH</code> - means that the interface uses a decoupled approach when authorizing the user.<br/><br/>&bull; <code>DETAILED_CONSENT</code> - means that the interface requires a list of account references when authorizing the user. It requires you to pass the \'accountReferences\' field in all services which define the field.<br/><br/>Note that this set can be empty, if the interface does not have any specific properties.
   * @type {Array<string>}
   * @memberof BankInterface
   */
  properties?: Array<BankInterfacePropertiesEnum>;
  /**
   * Login hint. Contains a German message for the user that explains what kind of credentials are expected.<br/><br/>Please note that it is essential to always show the login hint to the user if there is one, as the credentials that finAPI requires for the bank might be different to the credentials that the user knows from his online banking.<br/><br/>Also note that the contents of this field should always be interpreted as HTML, as the text might contain HTML tags for highlighted words, paragraphs, etc.
   * @type {string}
   * @memberof BankInterface
   */
  loginHint?: string;
  /**
   * The health status of this interface. This is a value between 0 and 100, depicting the percentage of successful communication attempts with the bank via this interface during the latest couple of bank connection imports or updates (across the entire finAPI system). Note that \'successful\' means that there was no technical error trying to establish a communication with the bank. Non-technical errors (like incorrect credentials) are regarded successful communication attempts.
   * @type {number}
   * @memberof BankInterface
   */
  health: number;
  /**
   * Time of the last communication attempt with this interface during an import, update or connect interface (across the entire finAPI system). The value is returned in the format \'YYYY-MM-DD HH:MM:SS.SSS\' (german time).
   * @type {string}
   * @memberof BankInterface
   */
  lastCommunicationAttempt?: string;
  /**
   * Time of the last successful communication with this interface during an import, update or connect interface (across the entire finAPI system). The value is returned in the format \'YYYY-MM-DD HH:MM:SS.SSS\' (german time).
   * @type {string}
   * @memberof BankInterface
   */
  lastSuccessfulCommunication?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum BankInterfaceInterfaceEnum {
  WEBSCRAPER = "WEB_SCRAPER",
  FINTSSERVER = "FINTS_SERVER",
  XS2A = "XS2A"
}
/**
 * @export
 * @enum {string}
 */
export enum BankInterfacePropertiesEnum {
  REDIRECTAPPROACH = "REDIRECT_APPROACH",
  DECOUPLEDAPPROACH = "DECOUPLED_APPROACH",
  DETAILEDCONSENT = "DETAILED_CONSENT"
}

/**
 * Container for a bank\'s login credential field
 * @export
 * @interface BankInterfaceLoginField
 */
export interface BankInterfaceLoginField {
  /**
   * Contains a German label for the input field that you should provide to the user. Also, these labels are used to identify login fields on the API-level, when you pass credentials to the service.
   * @type {string}
   * @memberof BankInterfaceLoginField
   */
  label: string;
  /**
   * Whether this field has to be treated as a secret. In this case your application should use a password input field instead of a cleartext field.
   * @type {boolean}
   * @memberof BankInterfaceLoginField
   */
  isSecret: boolean;
  /**
   * Whether this field depicts a credential that is volatile. If a field is volatile, it means that the value for the field, as provided by the user, is usually valid only for a single authentication, and is then invalidated on bank-side. If a bank uses volatile login credentials, it is strongly inadvisable to store the credentials in finAPI, as stored credentials will not work for future authentications.
   * @type {boolean}
   * @memberof BankInterfaceLoginField
   */
  isVolatile: boolean;
}
/**
 * Container for data of multiple banks
 * @export
 * @interface BankList
 */
export interface BankList {
  /**
   * Banks
   * @type {Array<Bank>}
   * @memberof BankList
   */
  banks: Array<Bank>;
}
/**
 * Cash flow
 * @export
 * @interface CashFlow
 */
export interface CashFlow {
  /**
   *
   * @type {Category}
   * @memberof CashFlow
   */
  category?: Category;
  /**
   * The total calculated income for the given category
   * @type {number}
   * @memberof CashFlow
   */
  income: number;
  /**
   * The total calculated spending for the given category
   * @type {number}
   * @memberof CashFlow
   */
  spending: number;
  /**
   * The calculated balance for the given category
   * @type {number}
   * @memberof CashFlow
   */
  balance: number;
  /**
   * The total count of income transactions for the given category
   * @type {number}
   * @memberof CashFlow
   */
  countIncomeTransactions: number;
  /**
   * The total count of spending transactions for the given category
   * @type {number}
   * @memberof CashFlow
   */
  countSpendingTransactions: number;
  /**
   * The total count of all transactions for the given category
   * @type {number}
   * @memberof CashFlow
   */
  countAllTransactions: number;
}
/**
 * Cash flows
 * @export
 * @interface CashFlowList
 */
export interface CashFlowList {
  /**
   * Array of cash flows
   * @type {Array<CashFlow>}
   * @memberof CashFlowList
   */
  cashFlows: Array<CashFlow>;
  /**
   * The total income
   * @type {number}
   * @memberof CashFlowList
   */
  totalIncome: number;
  /**
   * The total spending
   * @type {number}
   * @memberof CashFlowList
   */
  totalSpending: number;
  /**
   * The total balance
   * @type {number}
   * @memberof CashFlowList
   */
  totalBalance: number;
}
/**
 *
 * @export
 * @interface CategorizationCheckResult
 */
export interface CategorizationCheckResult {
  /**
   * Transaction identifier
   * @type {string}
   * @memberof CategorizationCheckResult
   */
  transactionId: string;
  /**
   *
   * @type {Category}
   * @memberof CategorizationCheckResult
   */
  category?: Category;
}
/**
 *
 * @export
 * @interface CategorizationCheckResults
 */
export interface CategorizationCheckResults {
  /**
   * List of results
   * @type {Array<CategorizationCheckResult>}
   * @memberof CategorizationCheckResults
   */
  categorizationCheckResult: Array<CategorizationCheckResult>;
}
/**
 * Category data
 * @export
 * @interface Category
 */
export interface Category {
  /**
   * Category identifier.<br/><br/>NOTE: Do NOT assume that the identifiers of the global finAPI categories are the same across different finAPI environments. In fact, the identifiers may change whenever a new finAPI version is released, even within the same environment. The identifiers are meant to be used for references within the finAPI services only, but not for hard-coding them in your application. If you need to hard-code the usage of a certain global category within your application, please instead refer to the category name. Also, please make sure to check the \'isCustom\' flag, which is false for all global categories (if you are not regarding this flag, you might end up referring to a user-specific category, and not the global category).
   * @type {number}
   * @memberof Category
   */
  id: number;
  /**
   * Category name
   * @type {string}
   * @memberof Category
   */
  name: string;
  /**
   * Identifier of the parent category (if a parent category exists)
   * @type {number}
   * @memberof Category
   */
  parentId?: number;
  /**
   * Name of the parent category (if a parent category exists)
   * @type {string}
   * @memberof Category
   */
  parentName?: string;
  /**
   * Whether the category is a finAPI global category (in which case this field will be false), or the category was created by a user (in which case this field will be true)
   * @type {boolean}
   * @memberof Category
   */
  isCustom: boolean;
  /**
   * List of sub-categories identifiers (if any exist)
   * @type {Array<number>}
   * @memberof Category
   */
  children?: Array<number>;
}
/**
 * Container for data of multiple categories
 * @export
 * @interface CategoryList
 */
export interface CategoryList {
  /**
   * Categories
   * @type {Array<Category>}
   * @memberof CategoryList
   */
  categories: Array<Category>;
}
/**
 * Category parameters
 * @export
 * @interface CategoryParams
 */
export interface CategoryParams {
  /**
   * Name of the category. Maximum length is 128.
   * @type {string}
   * @memberof CategoryParams
   */
  name: string;
  /**
   * Identifier of the parent category, if the new category should be created as a sub-category. Must point to a main category in this case. If the new category should be a main category itself, this field must remain unset.
   * @type {number}
   * @memberof CategoryParams
   */
  parentId?: number;
}
/**
 * Parameters for changing client credentials
 * @export
 * @interface ChangeClientCredentialsParams
 */
export interface ChangeClientCredentialsParams {
  /**
   * client_id of the client that you want to change the secret for
   * @type {string}
   * @memberof ChangeClientCredentialsParams
   */
  clientId: string;
  /**
   * Old (=current) client_secret
   * @type {string}
   * @memberof ChangeClientCredentialsParams
   */
  oldClientSecret: string;
  /**
   * New client_secret. Required length is 36. Allowed symbols: Digits (0 through 9), lower-case and upper-case letters (A through Z), and the dash symbol (\"-\").
   * @type {string}
   * @memberof ChangeClientCredentialsParams
   */
  newClientSecret: string;
}
/**
 * Transactions data for categorization check
 * @export
 * @interface CheckCategorizationData
 */
export interface CheckCategorizationData {
  /**
   * Set of transaction data
   * @type {Array<CheckCategorizationTransactionData>}
   * @memberof CheckCategorizationData
   */
  transactionData: Array<CheckCategorizationTransactionData>;
}
/**
 * Transaction data for categorization check
 * @export
 * @interface CheckCategorizationTransactionData
 */
export interface CheckCategorizationTransactionData {
  /**
   * Identifier of transaction. This can be any arbitrary string that will be passed back in the response so that you can map the results to the given transactions. Note that the identifier must be unique within the given list of transactions.
   * @type {string}
   * @memberof CheckCategorizationTransactionData
   */
  transactionId: string;
  /**
   * Identifier of account type.<br/><br/>1 = Checking,<br/>2 = Savings,<br/>3 = CreditCard,<br/>4 = Security,<br/>5 = Loan,<br/>6 = Pocket (DEPRECATED; will not be returned for any account unless this type has explicitly been set via PATCH),<br/>7 = Membership,<br/>8 = Bausparen<br/><br/>
   * @type {number}
   * @memberof CheckCategorizationTransactionData
   */
  accountTypeId: number;
  /**
   * Amount
   * @type {number}
   * @memberof CheckCategorizationTransactionData
   */
  amount: number;
  /**
   * Purpose. Any symbols are allowed. Maximum length is 2000. Default value: null.
   * @type {string}
   * @memberof CheckCategorizationTransactionData
   */
  purpose?: string;
  /**
   * Counterpart. Any symbols are allowed. Maximum length is 80. Default value: null.
   * @type {string}
   * @memberof CheckCategorizationTransactionData
   */
  counterpart?: string;
  /**
   * Counterpart IBAN. Default value: null.
   * @type {string}
   * @memberof CheckCategorizationTransactionData
   */
  counterpartIban?: string;
  /**
   * Counterpart account number. Default value: null.
   * @type {string}
   * @memberof CheckCategorizationTransactionData
   */
  counterpartAccountNumber?: string;
  /**
   * Counterpart BLZ. Default value: null.
   * @type {string}
   * @memberof CheckCategorizationTransactionData
   */
  counterpartBlz?: string;
  /**
   * Counterpart BIC. Default value: null.
   * @type {string}
   * @memberof CheckCategorizationTransactionData
   */
  counterpartBic?: string;
  /**
   * Merchant category code (for credit card transactions only). May only contain up to 4 digits. Default value: null.
   * @type {string}
   * @memberof CheckCategorizationTransactionData
   */
  mcCode?: string;
  /**
   * ZKA business transaction code which relates to the transaction\'s type (Number from 0 through 999). Default value: null.
   * @type {string}
   * @memberof CheckCategorizationTransactionData
   */
  typeCodeZka?: string;
}
/**
 *
 * @export
 * @interface ClearingAccountData
 */
export interface ClearingAccountData {
  /**
   * Technical identifier of the clearing account
   * @type {string}
   * @memberof ClearingAccountData
   */
  clearingAccountId: string;
  /**
   * Name of the clearing account
   * @type {string}
   * @memberof ClearingAccountData
   */
  clearingAccountName: string;
}
/**
 * Client configuration parameters
 * @export
 * @interface ClientConfiguration
 */
export interface ClientConfiguration {
  /**
   * Whether finAPI performs a regular automatic update of your users\' bank connections. To find out how the automatic batch update is configured for your client, i.e. which bank connections get updated, and at which time and interval, please contact your Sys-Admin. Note that even if the automatic batch update is enabled for your client, individual users can still disable the feature for their own bank connections.
   * @type {boolean}
   * @memberof ClientConfiguration
   */
  isAutomaticBatchUpdateEnabled: boolean;
  /**
   * Callback URL to which finAPI sends the notification messages that are triggered from the automatic batch update of the users\' bank connections. This field is only relevant if the automatic batch update is enabled for your client. For details about what the notification messages look like, please see the documentation in the \'Notification Rules\' section. finAPI will call this URL with HTTP method POST. Note that the response of the call is not processed by finAPI. Also note that while the callback URL may be a non-secured (http) URL on the finAPI sandbox or alpha environment, it MUST be a SSL-secured (https) URL on the finAPI live system.
   * @type {string}
   * @memberof ClientConfiguration
   */
  userNotificationCallbackUrl?: string;
  /**
   * Callback URL for user synchronization. This field should be set if you - as a finAPI customer - have multiple clients using finAPI. In such case, all of your clients will share the same user base, making it possible for a user to be created in one client, but then deleted in another. To keep the client-side user data consistent in all clients, you should set a callback URL for each client. finAPI will send a notification to the callback URL of each client whenever a user of your user base gets deleted. Note that finAPI will send a deletion notification to ALL clients, including the one that made the user deletion request to finAPI. So when deleting a user in finAPI, a client should rely on the callback to delete the user on its own side. <p>The notification that finAPI sends to the clients\' callback URLs will be a POST request, with this body: <pre>{    \"userId\" : string // contains the identifier of the deleted user    \"event\" : string // this will always be \"DELETED\" }</pre><br/>Note that finAPI does not process the response of this call. Also note that while the callback URL may be a non-secured (http) URL on the finAPI sandbox or alpha environment, it MUST be a SSL-secured (https) URL on the finAPI live system.</p>As long as you have just one client, you can ignore this field and let it be null. However keep in mind that in this case your client will not receive any callback when a user gets deleted - so the deletion of the user on the client-side must not be forgotten. Of course you may still use the callback URL even for just one client, if you want to implement the deletion of the user on the client-side via the callback from finAPI.
   * @type {string}
   * @memberof ClientConfiguration
   */
  userSynchronizationCallbackUrl?: string;
  /**
   * The validity period that newly requested refresh tokens initially have (in seconds). A value of 0 means that the tokens never expire (Unless explicitly invalidated, e.g. by revocation, or when a user gets locked, or when the password is reset for a user).
   * @type {number}
   * @memberof ClientConfiguration
   */
  refreshTokensValidityPeriod?: number;
  /**
   * The validity period that newly requested access tokens for users initially have (in seconds). A value of 0 means that the tokens never expire (Unless explicitly invalidated, e.g. by revocation, or when a user gets locked, or when the password is reset for a user).
   * @type {number}
   * @memberof ClientConfiguration
   */
  userAccessTokensValidityPeriod?: number;
  /**
   * The validity period that newly requested access tokens for clients initially have (in seconds). A value of 0 means that the tokens never expire (Unless explicitly invalidated, e.g. by revocation).
   * @type {number}
   * @memberof ClientConfiguration
   */
  clientAccessTokensValidityPeriod?: number;
  /**
   * Number of consecutive failed login attempts of a user into his finAPI account that is allowed before finAPI locks the user\'s account. When a user\'s account is locked, finAPI will invalidate all user\'s tokens and it will deny any service call in the context of this user (i.e. any call to a service using one of the user\'s authorization tokens, as well as the service for requesting a new token for this user). To unlock a user\'s account, a new password must be set for the account by the client (see the services /users/requestPasswordChange and /users/executePasswordChange). Once a new password has been set, all services will be available again for this user and the user\'s failed login attempts counter is reset to 0. The user\'s failed login attempts counter is also reset whenever a new authorization token has been successfully retrieved, or whenever the user himself changes his password.<br/><br/>Note that when this field has a value of 0, it means that there is no limit for user login attempts, i.e. finAPI will never lock user accounts.
   * @type {number}
   * @memberof ClientConfiguration
   */
  maxUserLoginAttempts: number;
  /**
   * Whether users that are created with this client are automatically verified on creation. If this field is set to \'false\', then any user that is created with this client must first be verified with the \"Verify a user\" service before he can be authorized. If the field is \'true\', then no verification is required by the client and the user can be authorized immediately after creation.
   * @type {boolean}
   * @memberof ClientConfiguration
   */
  isUserAutoVerificationEnabled: boolean;
  /**
   * Whether this client is a \'Mandator Admin\'. Mandator Admins are special clients that can access the \'Mandator Administration\' section of finAPI. If you do not yet have credentials for a Mandator Admin, please contact us at support@finapi.io. For further information, please refer to <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>this article</a> on our Dev Portal.
   * @type {boolean}
   * @memberof ClientConfiguration
   */
  isMandatorAdmin: boolean;
  /**
   * Whether finAPI is allowed to use the WEB_SCRAPER interface for data download. If this field is set to \'true\', then finAPI might download data from the online banking websites of banks (either in addition to other interfaces, or as the sole data source for the download). If this field is set to \'false\', then finAPI will not use any web scrapers. For banks where no other interface except WEB_SCRAPER is available, finAPI will not allow any data download at all if web scraping is disabled for your client. Please contact your Sys-Admin if you want to change this setting.
   * @type {boolean}
   * @memberof ClientConfiguration
   */
  isWebScrapingEnabled: boolean;
  /**
   * Whether this client is allowed to access XS2A services.
   * @type {boolean}
   * @memberof ClientConfiguration
   */
  isXs2aEnabled: boolean;
  /**
   * List of bank groups that are available to this client. A bank group is a collection of all banks that are located in a certain country, and is defined by the country\'s ISO 3166 ALPHA-2 code (see also field \'location\' of Bank resource). If you want to extend or limit the available bank groups for your client, please contact your Sys-Admin.<br/><br/>Note: There is no bank group for international institutes (i.e. institutes that are not bound to any specific country). Instead, those institutes are always available. If this list is empty, it means that ONLY international institutes are available.
   * @type {Array<string>}
   * @memberof ClientConfiguration
   */
  availableBankGroups: Array<string>;
  /**
   * Application name. When an application name is set (e.g. \"My App\"), then <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s web form</a> will display a text to the user \"Weiterleitung auf finAPI von ...\" (e.g. \"Weiterleitung auf finAPI von MyApp\").
   * @type {string}
   * @memberof ClientConfiguration
   */
  applicationName?: string;
  /**
   * The FinTS product registration number. If a value is stored, this will always be \'XXXXX\'.
   * @type {string}
   * @memberof ClientConfiguration
   */
  finTSProductRegistrationNumber?: string;
  /**
   * Whether <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s web form</a> will provide a checkbox for the user allowing him to choose whether to store login secrets (like a PIN) in finAPI. If this field is set to false, then the user won\'t have an option to store this data.
   * @type {boolean}
   * @memberof ClientConfiguration
   */
  storeSecretsAvailableInWebForm: boolean;
  /**
   * Whether this client is allowed to do payments
   * @type {boolean}
   * @memberof ClientConfiguration
   */
  paymentsEnabled: boolean;
  /**
   * Whether <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s web form</a> will provide a checkbox for the user allowing him to choose whether to store his banking PIN in finAPI. If this field is set to false, then the user won\'t have an option to store his PIN.<br><br>NOTE: This field is deprecated and will be removed at some point. Refer to field \'storeSecretsAvailableInWebForm\' instead.
   * @type {boolean}
   * @memberof ClientConfiguration
   */
  pinStorageAvailableInWebForm: boolean;
}
/**
 * Client configuration parameters
 * @export
 * @interface ClientConfigurationParams
 */
export interface ClientConfigurationParams {
  /**
   * Callback URL to which finAPI sends the notification messages that are triggered from the automatic batch update of the users\' bank connections. This field is only relevant if the automatic batch update is enabled for your client. For details about what the notification messages look like, please see the documentation in the \'Notification Rules\' section. finAPI will call this URL with HTTP method POST. Note that the response of the call is not processed by finAPI. Also note that while the callback URL may be a non-secured (http) URL on the finAPI sandbox or alpha environment, it MUST be a SSL-secured (https) URL on the finAPI live system.<p>The maximum allowed length of the URL is 512. If you have previously set a callback URL and now want to clear it (thus disabling user-related notifications altogether), you can pass an empty string (\"\").
   * @type {string}
   * @memberof ClientConfigurationParams
   */
  userNotificationCallbackUrl?: string;
  /**
   * Callback URL for user synchronization. This field should be set if you - as a finAPI customer - have multiple clients using finAPI. In such case, all of your clients will share the same user base, making it possible for a user to be created in one client, but then deleted in another. To keep the client-side user data consistent in all clients, you should set a callback URL for each client. finAPI will send a notification to the callback URL of each client whenever a user of your user base gets deleted. Note that finAPI will send a deletion notification to ALL clients, including the one that made the user deletion request to finAPI. So when deleting a user in finAPI, a client should rely on the callback to delete the user on its own side. <p>The notification that finAPI sends to the clients\' callback URLs will be a POST request, with this body: <pre>{    \"userId\" : string // contains the identifier of the deleted user    \"event\" : string // this will always be \"DELETED\" }</pre><br/>Note that finAPI does not process the response of this call. Also note that while the callback URL may be a non-secured (http) URL on the finAPI sandbox or alpha system, it MUST be a SSL-secured (https) URL on the live system.</p>As long as you have just one client, you can ignore this field and let it be null. However keep in mind that in this case your client will not receive any callback when a user gets deleted - so the deletion of the user on the client-side must not be forgotten. Of course you may still use the callback URL even for just one client, if you want to implement the deletion of the user on the client-side via the callback from finAPI.<p> The maximum allowed length of the URL is 512. If you have previously set a callback URL and now want to clear it (thus disabling user synchronization related notifications for this client), you can pass an empty string (\"\").
   * @type {string}
   * @memberof ClientConfigurationParams
   */
  userSynchronizationCallbackUrl?: string;
  /**
   * The validity period that newly requested refresh tokens initially have (in seconds). The value must be greater than or equal to 60, or 0. A value of 0 means that the tokens never expire (Unless explicitly invalidated, e.g. by revocation , or when a user gets locked, or when the password is reset for a user).
   * @type {number}
   * @memberof ClientConfigurationParams
   */
  refreshTokensValidityPeriod?: number;
  /**
   * The validity period that newly requested access tokens for users initially have (in seconds). The value must be greater than or equal to 60, or 0. A value of 0 means that the tokens never expire.
   * @type {number}
   * @memberof ClientConfigurationParams
   */
  userAccessTokensValidityPeriod?: number;
  /**
   * The validity period that newly requested access tokens for clients initially have (in seconds). The value must be greater than or equal to 60, or 0. A value of 0 means that the tokens never expire.
   * @type {number}
   * @memberof ClientConfigurationParams
   */
  clientAccessTokensValidityPeriod?: number;
  /**
   * Whether <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s web form</a> should provide a checkbox for the user allowing him to choose whether to store his banking PIN in finAPI. If this field is set to false, then the user won\'t have an option to store his PIN.<br><br>NOTE: This field is deprecated and will be removed at some point. Use \'storeSecretsAvailableInWebForm\' instead.
   * @type {boolean}
   * @memberof ClientConfigurationParams
   */
  isPinStorageAvailableInWebForm?: boolean;
  /**
   * Whether <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s web form</a> will provide a checkbox for the user allowing him to choose whether to store login secrets (like a PIN) in finAPI. If this field is set to false, then the user won\'t have an option to store this data.
   * @type {boolean}
   * @memberof ClientConfigurationParams
   */
  storeSecretsAvailableInWebForm?: boolean;
  /**
   * When an application name is set (e.g. \"My App\"), then <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s web form</a> will display a text to the user \"Weiterleitung auf finAPI von ...\" (e.g. \"Weiterleitung auf finAPI von My App\"). If you have previously set a application name and now want to clear it, you can pass an empty string (\"\"). Maximum length: 64
   * @type {string}
   * @memberof ClientConfigurationParams
   */
  applicationName?: string;
  /**
   * The FinTS product registration number. Please follow <a href=\'https://www.hbci-zka.de/register/prod_register.htm\' target=\'_blank\'>this link</a> to apply for a registration number. Only customers who have an AISP or PISP license must define their FinTS product registration number. Customers who are relying on the finAPI web form will be assigned to finAPI\'s FinTS product registration number automatically and do not have to register themselves. During a batch update, finAPI is using the FinTS product registration number of the client, that was used to create the user. If you have previously set a FinTS product registration number and now want to clear it, you can pass an empty string (\"\"). Only hexa decimal characters in capital case with a maximum length of 25 characters are allowed. E.g. \'ABCDEF1234567890ABCDEF123\'
   * @type {string}
   * @memberof ClientConfigurationParams
   */
  finTSProductRegistrationNumber?: string;
}
/**
 * Container for interface connection parameters
 * @export
 * @interface ConnectInterfaceParams
 */
export interface ConnectInterfaceParams {
  /**
   * Bank connection identifier
   * @type {number}
   * @memberof ConnectInterfaceParams
   */
  bankConnectionId: number;
  /**
   * The interface to use for connecting with the bank.
   * @type {string}
   * @memberof ConnectInterfaceParams
   */
  _interface?: ConnectInterfaceParamsInterfaceEnum;
  /**
   * Set of login credentials. Must be passed in combination with the \'interface\' field. For mandators requiring a web form, no matter the passed login credentials, the web form will contain all login fields defined by the bank for the respective interface.
   * @type {Array<LoginCredential>}
   * @memberof ConnectInterfaceParams
   */
  loginCredentials?: Array<LoginCredential>;
  /**
   * Whether to store the secret login fields. If the secret fields are stored, then updates can be triggered without the involvement of the users, as long as the credentials remain valid and the bank consent has not expired. Note that bank consent will be stored regardless of the field value. Default value is false.<br/><br/>NOTES:<br/> - this field is ignored in case when the user will need to use finAPI\'s web form. The user will be able to decide whether to store the secrets or not in the web form, depending on the \'storeSecretsAvailableInWebForm\' setting (see Client Configuration).
   * @type {boolean}
   * @memberof ConnectInterfaceParams
   */
  storeSecrets?: boolean;
  /**
   * Whether to skip the download of transactions and securities or not. If set to true, then finAPI will download just the accounts list with the accounts\' information (like account name, number, holder, etc), as well as the accounts\' balances (if possible), but skip the download of transactions and securities. Default is false.<br/><br/>NOTES:<br/>&bull; If you skip the download of transactions and securities during an import or update, you can still download them on a later update (though you might not get all positions at a later point, because the date range in which the bank servers provide this data is usually limited). However, once finAPI has downloaded the transactions or securities for the first time, you will not be able to go back to skipping the download of transactions and securities! In other words: Once you make your first request with skipPositionsDownload=false for a certain bank connection, you will no longer be able to make a request with skipPositionsDownload=true for that same bank connection.<br/>&bull; If this bank connection is updated via finAPI\'s automatic batch update, then transactions and security positions <u>will</u> be downloaded in any case!<br/>&bull; For security accounts, skipping the downloading of the securities might result in the account\'s balance also not being downloaded.<br/>&bull; For Bausparen accounts, this field is ignored. finAPI will always download transactions for Bausparen accounts.<br/>
   * @type {boolean}
   * @memberof ConnectInterfaceParams
   */
  skipPositionsDownload?: boolean;
  /**
   * Whether to load information about the bank connection owner(s) - see field \'owners\'. Default value is \'false\'.<br><br>NOTE: This feature is supported only by the WEB_SCRAPER interface.
   * @type {boolean}
   * @memberof ConnectInterfaceParams
   */
  loadOwnerData?: boolean;
  /**
   * List of accounts for which access is requested from the bank. It must only be passed if the bank interface has the DETAILED_CONSENT property set.
   * @type {Array<AccountReference>}
   * @memberof ConnectInterfaceParams
   */
  accountReferences?: Array<AccountReference>;
  /**
   *
   * @type {MultiStepAuthenticationCallback}
   * @memberof ConnectInterfaceParams
   */
  multiStepAuthentication?: MultiStepAuthenticationCallback;
  /**
   * Must only be passed when the used interface has the property REDIRECT_APPROACH and no web form flow is used. The user will be redirected to the given URL from the bank\'s website after having entered his credentials. Must use HTTPS protocol.
   * @type {string}
   * @memberof ConnectInterfaceParams
   */
  redirectUrl?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum ConnectInterfaceParamsInterfaceEnum {
  FINTSSERVER = "FINTS_SERVER",
  WEBSCRAPER = "WEB_SCRAPER",
  XS2A = "XS2A"
}

/**
 * Balance data for a single day
 * @export
 * @interface DailyBalance
 */
export interface DailyBalance {
  /**
   * Date in the format \'YYYY-MM-DD HH:MM:SS.SSS\' (german time).
   * @type {string}
   * @memberof DailyBalance
   */
  date: string;
  /**
   * Calculated balance at the end of day (aggregation of all regarded accounts).
   * @type {number}
   * @memberof DailyBalance
   */
  balance: number;
  /**
   * The sum of income of the given day (aggregation of all regarded accounts).
   * @type {number}
   * @memberof DailyBalance
   */
  income: number;
  /**
   * The sum of spending of the given day (aggregation of all regarded accounts).
   * @type {number}
   * @memberof DailyBalance
   */
  spending: number;
  /**
   * Identifiers of the transactions for the given day
   * @type {Array<number>}
   * @memberof DailyBalance
   */
  transactions: Array<number>;
}
/**
 * Contains a list of daily balances
 * @export
 * @interface DailyBalanceList
 */
export interface DailyBalanceList {
  /**
   * The latestCommonBalanceTimestamp is the latest timestamp at which all regarded  accounts have been up to date. Only balances with their date being smaller than the latestCommonBalanceTimestamp are reliable. Example: A user has two accounts: A (last update today, so balance from today) and B (last update yesterday, so balance from yesterday). The service /accounts/dailyBalances will return a balance for yesterday and for today, with the info latestCommonBalanceTimestamp=yesterday. Since account B might have received transactions this morning, today\'s balance might be wrong. So either make sure that all regarded accounts are up to date before calling this service, or use the results carefully in combination with the latestCommonBalanceTimestamp. The format is \'YYYY-MM-DD HH:MM:SS.SSS\' (german time).
   * @type {string}
   * @memberof DailyBalanceList
   */
  latestCommonBalanceTimestamp?: string;
  /**
   * List of daily balances for the requested period and account(s)
   * @type {Array<DailyBalance>}
   * @memberof DailyBalanceList
   */
  dailyBalances: Array<DailyBalance>;
  /**
   *
   * @type {Paging}
   * @memberof DailyBalanceList
   */
  paging: Paging;
}
/**
 * Bank server\'s response to a direct debit order request
 * @export
 * @interface DirectDebitOrderingResponse
 */
export interface DirectDebitOrderingResponse {
  /**
   * Technical message from the bank server, confirming the success of the request. Typically, you would not want to present this message to the user. Note that this field may not be set. However if it is not set, it does not necessarily mean that there was an error in processing the request.
   * @type {string}
   * @memberof DirectDebitOrderingResponse
   */
  successMessage?: string;
  /**
   * In some cases, a bank server may accept the requested order, but return a warn message. This message may be of technical nature, but could also be of interest to the user.
   * @type {string}
   * @memberof DirectDebitOrderingResponse
   */
  warnMessage?: string;
  /**
   * Payment identifier. Can be used to retrieve the status of the payment (see \'Get payments\' service).
   * @type {number}
   * @memberof DirectDebitOrderingResponse
   */
  paymentId: number;
  /**
   * Message from the bank server containing information or instructions on how to retrieve the TAN that is needed to execute the requested order. This message should be presented to the user. Note that some bank servers may limit the message to just the most crucial information, e.g. the message may contain just a single number that depicts the target TAN number on a user\'s TAN list. You may want to parse the challenge message for such cases and extend it with more detailed information before showing it to the user.
   * @type {string}
   * @memberof DirectDebitOrderingResponse
   */
  challengeMessage?: string;
  /**
   * Suggestion from the bank server on how you can label your input field where the user must enter his TAN. A typical value that many bank servers give is \'TAN-Nummer\'.
   * @type {string}
   * @memberof DirectDebitOrderingResponse
   */
  answerFieldLabel?: string;
  /**
   * In case that the bank server has instructed the user to look up a TAN from a TAN list, this field may contain the identification number of the TAN list. However in most cases, this field is only set (i.e. not null) when the user has multiple active TAN lists.
   * @type {string}
   * @memberof DirectDebitOrderingResponse
   */
  tanListNumber?: string;
  /**
   * In case that the bank server has instructed the user to scan a flicker code, then this field will contain the raw data for the flicker animation as a BASE-64 string. Otherwise, this field will be not set (i.e. null). For more information on how to process the flicker code data, please address the <a href=\'https://finapi.zendesk.com\' target=\'_blank\'>finAPI Developer Portal</a>.
   * @type {string}
   * @memberof DirectDebitOrderingResponse
   */
  opticalData?: string;
  /**
   * In case that the \'photoTanData\' field is set (i.e. not null), this field contains the MIME type to use for interpreting the photo data (e.g.: \'image/png\')
   * @type {string}
   * @memberof DirectDebitOrderingResponse
   */
  photoTanMimeType?: string;
  /**
   * In case that the bank server has instructed the user to scan a photo (or more generally speaking, any kind of QR-code-like data), then this field will contain the raw data of the photo as a BASE-64 string. Otherwise, this field will be not set (i.e. null). For more information on how to process the photo data, please address the <a href=\'https://finapi.zendesk.com\' target=\'_blank\'>finAPI Developer Portal</a>.
   * @type {string}
   * @memberof DirectDebitOrderingResponse
   */
  photoTanData?: string;
}
/**
 * Container for bank connection edit params
 * @export
 * @interface EditBankConnectionParams
 */
export interface EditBankConnectionParams {
  /**
   * New name for the bank connection. Maximum length is 64. If you do not want to change the current name let this field remain unset. If you want to clear the current name, set the field\'s value to an empty string (\"\").
   * @type {string}
   * @memberof EditBankConnectionParams
   */
  name?: string;
  /**
   * NOTE: This field is deprecated and will be removed at some point. Use \'loginCredentials\' + \'interface\' instead. If any of those two fields is used, then the value of this field will be ignored.<br><br>New online banking user ID. If you do not want to change the current user ID let this field remain unset. In case you need to use finAPI\'s web form to let the user update the field, just set the field to any value, so that the service recognizes that you wish to use the web form flow. Note that you cannot clear the current user ID, i.e. a bank connection must always have a user ID (except for when it is a \'demo connection\'). Max length: 170.
   * @type {string}
   * @memberof EditBankConnectionParams
   */
  bankingUserId?: string;
  /**
   * NOTE: This field is deprecated and will be removed at some point. Use \'loginCredentials\' + \'interface\' instead. If any of those two fields is used, then the value of this field will be ignored.<br><br>New online banking customer ID. If you do not want to change the current customer ID let this field remain unset. In case you need to use finAPI\'s web form to let the user update the field, just set the field to non-empty value, so that the service recognizes that you wish to use the web form flow. If you want to clear the current customer ID, set the field\'s value to an empty string (\"\"). Max length: 170.
   * @type {string}
   * @memberof EditBankConnectionParams
   */
  bankingCustomerId?: string;
  /**
   * NOTE: This field is deprecated and will be removed at some point. Use \'loginCredentials\' + \'interface\' instead. If any of those two fields is used, then the value of this field will be ignored.<br><br>New online banking PIN. If you do not want to change the current PIN let this field remain unset. In case you need to use finAPI\'s web form to let the user update the field, just set the field to non-empty value, so that the service recognizes that you wish to use the web form flow. If you want to clear the current PIN, set the field\'s value to an empty string (\"\").<br/><br/>Any symbols are allowed. Max length: 170.
   * @type {string}
   * @memberof EditBankConnectionParams
   */
  bankingPin?: string;
  /**
   * The interface for which you want to edit data. Must be given when you pass \'loginCredentials\' and/or a \'defaultTwoStepProcedureId\'.
   * @type {string}
   * @memberof EditBankConnectionParams
   */
  _interface?: EditBankConnectionParamsInterfaceEnum;
  /**
   * Set of login credentials that you want to edit. Must be passed in combination with the \'interface\' field. The labels that you pass must match with the login credential labels that the respective interface defines. If you want to clear the stored value for a credential, you can pass an empty string (\"\") as value.In case you need to use finAPI\'s web form to let the user update the login credentials, send all fields the user wishes to update with a non-empty value.In case all fields contain an empty string (\"\"), no webform will be generated. Note that any change in the credentials will automatically remove the saved consent data associated with those credentials.<br><br>NOTE: When you pass this field, then the fields \'bankingUserId\',\'bankingCustomerId\' and \'bankingPin\' will be ignored.
   * @type {Array<LoginCredential>}
   * @memberof EditBankConnectionParams
   */
  loginCredentials?: Array<LoginCredential>;
  /**
   * NOTE: In the future, this field will work only in combination with the \'interface\' field.<br><br>New default two-step-procedure. Must match the \'procedureId\' of one of the procedures that are listed in the bank connection. If you do not want to change this field let it remain unset. If you want to clear the current default two-step-procedure, set the field\'s value to an empty string (\"\").
   * @type {string}
   * @memberof EditBankConnectionParams
   */
  defaultTwoStepProcedureId?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum EditBankConnectionParamsInterfaceEnum {
  FINTSSERVER = "FINTS_SERVER",
  WEBSCRAPER = "WEB_SCRAPER",
  XS2A = "XS2A"
}

/**
 * Container for category edit params
 * @export
 * @interface EditCategoryParams
 */
export interface EditCategoryParams {
  /**
   * New name of the category. Maximum length is 128.
   * @type {string}
   * @memberof EditCategoryParams
   */
  name: string;
}
/**
 * A container for editing TPP client credentials data
 * @export
 * @interface EditTppCredentialParams
 */
export interface EditTppCredentialParams {
  /**
   * The TPP Authentication Group Id for which the credentials can be used
   * @type {number}
   * @memberof EditTppCredentialParams
   */
  tppAuthenticationGroupId?: number;
  /**
   * Optional label for credentials
   * @type {string}
   * @memberof EditTppCredentialParams
   */
  label?: string;
  /**
   * ID of the TPP accessing the ASPSP API, as provided by the ASPSP as the result of registration
   * @type {string}
   * @memberof EditTppCredentialParams
   */
  tppClientId?: string;
  /**
   * Secret of the TPP accessing the ASPSP API, as provided by the ASPSP as the result of registration
   * @type {string}
   * @memberof EditTppCredentialParams
   */
  tppClientSecret?: string;
  /**
   * API Key provided by ASPSP  as the result of registration
   * @type {string}
   * @memberof EditTppCredentialParams
   */
  tppApiKey?: string;
  /**
   * Credentials \"valid from\" date in the format \'YYYY-MM-DD\'. Default is today\'s date
   * @type {string}
   * @memberof EditTppCredentialParams
   */
  validFromDate?: string;
  /**
   * Credentials \"valid until\" date in the format \'YYYY-MM-DD\'. Default is null which means \"indefinite\" (no limit)
   * @type {string}
   * @memberof EditTppCredentialParams
   */
  validUntilDate?: string;
}
/**
 * Error details
 * @export
 * @interface ErrorDetails
 */
export interface ErrorDetails {
  /**
   * Error message
   * @type {string}
   * @memberof ErrorDetails
   */
  message?: string;
  /**
   * Error code. See the documentation of the individual services for details about what values may be returned.
   * @type {string}
   * @memberof ErrorDetails
   */
  code: ErrorDetailsCodeEnum;
  /**
   * Error type. BUSINESS errors depict German error messages for the user, e.g. from a bank server. TECHNICAL errors depict internal errors.
   * @type {string}
   * @memberof ErrorDetails
   */
  type: ErrorDetailsTypeEnum;
  /**
   *
   * @type {MultiStepAuthenticationChallenge}
   * @memberof ErrorDetails
   */
  multiStepAuthentication?: MultiStepAuthenticationChallenge;
}

/**
 * @export
 * @enum {string}
 */
export enum ErrorDetailsCodeEnum {
  MISSINGFIELD = "MISSING_FIELD",
  UNKNOWNENTITY = "UNKNOWN_ENTITY",
  METHODNOTALLOWED = "METHOD_NOT_ALLOWED",
  ENTITYEXISTS = "ENTITY_EXISTS",
  ILLEGALENTITYSTATE = "ILLEGAL_ENTITY_STATE",
  UNEXPECTEDERROR = "UNEXPECTED_ERROR",
  ILLEGALFIELDVALUE = "ILLEGAL_FIELD_VALUE",
  UNAUTHORIZEDACCESS = "UNAUTHORIZED_ACCESS",
  BADREQUEST = "BAD_REQUEST",
  UNSUPPORTEDORDER = "UNSUPPORTED_ORDER",
  ILLEGALPAGESIZE = "ILLEGAL_PAGE_SIZE",
  INVALIDFILTEROPTIONS = "INVALID_FILTER_OPTIONS",
  TOOMANYIDS = "TOO_MANY_IDS",
  BANKSERVERREJECTION = "BANK_SERVER_REJECTION",
  IBANONLYMONEYTRANSFERNOTSUPPORTED = "IBAN_ONLY_MONEY_TRANSFER_NOT_SUPPORTED",
  IBANONLYDIRECTDEBITNOTSUPPORTED = "IBAN_ONLY_DIRECT_DEBIT_NOT_SUPPORTED",
  COLLECTIVEMONEYTRANSFERNOTSUPPORTED = "COLLECTIVE_MONEY_TRANSFER_NOT_SUPPORTED",
  INVALIDTWOSTEPPROCEDURE = "INVALID_TWO_STEP_PROCEDURE",
  MISSINGTWOSTEPPROCEDURE = "MISSING_TWO_STEP_PROCEDURE",
  UNSUPPORTEDMEDIATYPE = "UNSUPPORTED_MEDIA_TYPE",
  UNSUPPORTEDBANK = "UNSUPPORTED_BANK",
  USERNOTVERIFIED = "USER_NOT_VERIFIED",
  USERALREADYVERIFIED = "USER_ALREADY_VERIFIED",
  INVALIDTOKEN = "INVALID_TOKEN",
  LOCKED = "LOCKED",
  NOACCOUNTSFORTYPELIST = "NO_ACCOUNTS_FOR_TYPE_LIST",
  FORBIDDEN = "FORBIDDEN",
  NOEXISTINGCHALLENGE = "NO_EXISTING_CHALLENGE",
  ADDITIONALAUTHENTICATIONREQUIRED = "ADDITIONAL_AUTHENTICATION_REQUIRED",
  WEBFORMREQUIRED = "WEB_FORM_REQUIRED",
  WEBFORMABORTED = "WEB_FORM_ABORTED",
  INVALIDCONSENT = "INVALID_CONSENT",
  NOCERTIFICATE = "NO_CERTIFICATE",
  NOTPPCLIENTCREDENTIALS = "NO_TPP_CLIENT_CREDENTIALS"
}
/**
 * @export
 * @enum {string}
 */
export enum ErrorDetailsTypeEnum {
  BUSINESS = "BUSINESS",
  TECHNICAL = "TECHNICAL"
}

/**
 * Response type when a service call was not successful. Contains details about the error(s) that occurred.
 * @export
 * @interface ErrorMessage
 */
export interface ErrorMessage {
  /**
   * List of errors
   * @type {Array<ErrorDetails>}
   * @memberof ErrorMessage
   */
  errors: Array<ErrorDetails>;
  /**
   * Server date of when the error(s) occurred, in the format YYYY-MM-DD HH:MM:SS.SSS
   * @type {string}
   * @memberof ErrorMessage
   */
  date: string;
  /**
   * ID of the request that caused this error. This is either what you have passed for the header \'X-REQUEST-ID\', or an auto-generated ID in case you didn\'t pass any value for that header.
   * @type {string}
   * @memberof ErrorMessage
   */
  requestId?: string;
  /**
   * The service endpoint that was called
   * @type {string}
   * @memberof ErrorMessage
   */
  endpoint: string;
  /**
   * Information about the authorization context of the service call
   * @type {string}
   * @memberof ErrorMessage
   */
  authContext: string;
  /**
   * BLZ and name (in format \"<BLZ> - <name>\") of a bank that was used for the original request
   * @type {string}
   * @memberof ErrorMessage
   */
  bank?: string;
}
/**
 * Execute password change parameters
 * @export
 * @interface ExecutePasswordChangeParams
 */
export interface ExecutePasswordChangeParams {
  /**
   * User identifier
   * @type {string}
   * @memberof ExecutePasswordChangeParams
   */
  userId: string;
  /**
   * User\'s new password. Minimum length is 6, and maximum length is 128.
   * @type {string}
   * @memberof ExecutePasswordChangeParams
   */
  password: string;
  /**
   * Decrypted password change token (the token that you received from the /users/requestPasswordChange service, decrypted with your data decryption key)
   * @type {string}
   * @memberof ExecutePasswordChangeParams
   */
  passwordChangeToken: string;
}
/**
 * Container for parameters for the execution of a submitted SEPA direct debit order
 * @export
 * @interface ExecuteSepaDirectDebitParams
 */
export interface ExecuteSepaDirectDebitParams {
  /**
   * Identifier of the bank account that you want to transfer money to
   * @type {number}
   * @memberof ExecuteSepaDirectDebitParams
   */
  accountId: number;
  /**
   * Banking TAN that the user received from the bank for executing the direct debit order. The field is required if you are licensed to perform SEPA direct debits yourself. Otherwise, i.e. when finAPI\'s web form flow is required, the web form will deal with executing the service itself.
   * @type {string}
   * @memberof ExecuteSepaDirectDebitParams
   */
  bankingTan?: string;
}
/**
 * Container for parameters for the execution of a submitted SEPA money transfer order
 * @export
 * @interface ExecuteSepaMoneyTransferParams
 */
export interface ExecuteSepaMoneyTransferParams {
  /**
   * Identifier of the bank account that you want to transfer money from
   * @type {number}
   * @memberof ExecuteSepaMoneyTransferParams
   */
  accountId: number;
  /**
   * Banking TAN that the user received from the bank for executing the money transfer order. The field is required if you are licensed to perform SEPA money transfers yourself. Otherwise, i.e. when finAPI\'s web form flow is required, the web form will deal with executing the service itself.
   * @type {string}
   * @memberof ExecuteSepaMoneyTransferParams
   */
  bankingTan?: string;
}
/**
 * Container for an IBAN rule
 * @export
 * @interface IbanRule
 */
export interface IbanRule {
  /**
   * Rule identifier
   * @type {number}
   * @memberof IbanRule
   */
  id: number;
  /**
   *
   * @type {Category}
   * @memberof IbanRule
   */
  category: Category;
  /**
   * Direction for the rule. \'Income\' means that the rule applies to transactions with a positive amount only, \'Spending\' means it applies to transactions with a negative amount only.
   * @type {string}
   * @memberof IbanRule
   */
  direction: IbanRuleDirectionEnum;
  /**
   * Timestamp of when the rule was created, in the format \'YYYY-MM-DD HH:MM:SS.SSS\' (german time)
   * @type {string}
   * @memberof IbanRule
   */
  creationDate: string;
  /**
   * The IBAN for this rule
   * @type {string}
   * @memberof IbanRule
   */
  iban: string;
}

/**
 * @export
 * @enum {string}
 */
export enum IbanRuleDirectionEnum {
  Income = "Income",
  Spending = "Spending"
}

/**
 * Container for IBAN rules
 * @export
 * @interface IbanRuleList
 */
export interface IbanRuleList {
  /**
   * List of IBAN rules
   * @type {Array<IbanRule>}
   * @memberof IbanRuleList
   */
  ibanRules: Array<IbanRule>;
}
/**
 * Parameters of IBAN rule
 * @export
 * @interface IbanRuleParams
 */
export interface IbanRuleParams {
  /**
   * ID of the category that this rule should assign to the matching transactions
   * @type {number}
   * @memberof IbanRuleParams
   */
  categoryId: number;
  /**
   * Direction for the rule. \'Income\' means that the rule applies to transactions with a positive amount only, \'Spending\' means it applies to transactions with a negative amount only. \'Both\' means that it applies to both kind of transactions. Note that in case of \'Both\', finAPI will create two individual rules (one with direction \'Income\' and one with direction \'Spending\').
   * @type {string}
   * @memberof IbanRuleParams
   */
  direction: IbanRuleParamsDirectionEnum;
  /**
   * IBAN (case-insensitive)
   * @type {string}
   * @memberof IbanRuleParams
   */
  iban: string;
}

/**
 * @export
 * @enum {string}
 */
export enum IbanRuleParamsDirectionEnum {
  Income = "Income",
  Spending = "Spending",
  Both = "Both"
}

/**
 * Params for creation IBAN rules
 * @export
 * @interface IbanRulesParams
 */
export interface IbanRulesParams {
  /**
   * IBAN rule definitions. The minimum number of rule definitions is 1. The maximum number of rule definitions is 100.
   * @type {Array<IbanRuleParams>}
   * @memberof IbanRulesParams
   */
  ibanRules: Array<IbanRuleParams>;
}
/**
 * Set of identifiers (in ascending order)
 * @export
 * @interface IdentifierList
 */
export interface IdentifierList {
  /**
   * Set of identifiers (in ascending order)
   * @type {Array<number>}
   * @memberof IdentifierList
   */
  identifiers?: Array<number>;
}
/**
 * Identifiers params
 * @export
 * @interface IdentifiersParams
 */
export interface IdentifiersParams {
  /**
   * List of identifiers
   * @type {Array<number>}
   * @memberof IdentifiersParams
   */
  ids: Array<number>;
}
/**
 * Container for bank connection import parameters
 * @export
 * @interface ImportBankConnectionParams
 */
export interface ImportBankConnectionParams {
  /**
   * Bank Identifier
   * @type {number}
   * @memberof ImportBankConnectionParams
   */
  bankId: number;
  /**
   * Custom name for the bank connection. Maximum length is 64. If you do not want to set a name, you can leave this field unset.
   * @type {string}
   * @memberof ImportBankConnectionParams
   */
  name?: string;
  /**
   * NOTE: This field is deprecated and will be removed at some point. Use \'loginCredentials\' + \'interface\' instead. If any of those two fields is used, then the value of this field will be ignored.<br><br>Online banking user ID credential. Max length: 170. NOTES:<br/>- if you import the \'demo connection\', this field can be left unset;<br/> - if the user will need to enter his credentials in finAPI\'s web form, this field can contain any value. It will be ignored.
   * @type {string}
   * @memberof ImportBankConnectionParams
   */
  bankingUserId?: string;
  /**
   * NOTE: This field is deprecated and will be removed at some point. Use \'loginCredentials\' + \'interface\' instead. If any of those two fields is used, then the value of this field will be ignored.<br><br>Online banking customer ID credential (for most banks this field can remain unset). Max length: 170. NOTES:<br/>- if the user will need to enter his credentials in finAPI\'s web form, this field can contain any value. It will be ignored.
   * @type {string}
   * @memberof ImportBankConnectionParams
   */
  bankingCustomerId?: string;
  /**
   * NOTE: This field is deprecated and will be removed at some point. Use \'loginCredentials\' + \'interface\' instead. If any of those two fields is used, then the value of this field will be ignored.<br><br>Online banking PIN. Max length: 170. Any symbols are allowed. NOTES:<br/>- if you import the \'demo connection\', this field can be left unset;<br/> - if the user will need to enter his credentials in finAPI\'s web form, this field can be left unset or contain any value. It will be ignored.
   * @type {string}
   * @memberof ImportBankConnectionParams
   */
  bankingPin?: string;
  /**
   * NOTE: This field is deprecated and will be removed at some point. Use \'storeSecrets\' instead.<br><br>Whether to store the PIN. If the PIN is stored, it is not required to pass the PIN again when updating this bank connection or when executing orders (like money transfers). Default is false. <br/><br/>NOTES:<br/> - before you set this field to true, please regard the \'pinsAreVolatile\' flag of this connection\'s bank;<br/> - this field is ignored in case when the user will need to use finAPI\'s web form. The user will be able to decide whether to store the PIN or not in the web form, depending on the \'storeSecretsAvailableInWebForm\' setting (see Client Configuration).
   * @type {boolean}
   * @memberof ImportBankConnectionParams
   */
  storePin?: boolean;
  /**
   * The interface to use for connecting with the bank.
   * @type {string}
   * @memberof ImportBankConnectionParams
   */
  _interface?: ImportBankConnectionParamsInterfaceEnum;
  /**
   * Set of login credentials. Must be passed in combination with the \'interface\' field. For mandators requiring a web form, no matter the passed login credentials, the web form will contain all login fields defined by the bank for the respective interface.
   * @type {Array<LoginCredential>}
   * @memberof ImportBankConnectionParams
   */
  loginCredentials?: Array<LoginCredential>;
  /**
   * Whether to store the secret login fields. If the secret fields are stored, then updates can be triggered without the involvement of the users, as long as the credentials remain valid and the bank consent has not expired. Note that bank consent will be stored regardless of the field value. Default value is false.<br/><br/>NOTES:<br/> - this field is ignored in case when the user will need to use finAPI\'s web form. The user will be able to decide whether to store the secrets or not in the web form, depending on the \'storeSecretsAvailableInWebForm\' setting (see Client Configuration).
   * @type {boolean}
   * @memberof ImportBankConnectionParams
   */
  storeSecrets?: boolean;
  /**
   * Whether to skip the download of transactions and securities or not. If set to true, then finAPI will download just the accounts list with the accounts\' information (like account name, number, holder, etc), as well as the accounts\' balances (if possible), but skip the download of transactions and securities. Default is false.<br/><br/>NOTES:<br/>&bull; If you skip the download of transactions and securities during an import or update, you can still download them on a later update (though you might not get all positions at a later point, because the date range in which the bank servers provide this data is usually limited). However, once finAPI has downloaded the transactions or securities for the first time, you will not be able to go back to skipping the download of transactions and securities! In other words: Once you make your first request with skipPositionsDownload=false for a certain bank connection, you will no longer be able to make a request with skipPositionsDownload=true for that same bank connection.<br/>&bull; If this bank connection is updated via finAPI\'s automatic batch update, then transactions and security positions <u>will</u> be downloaded in any case!<br/>&bull; For security accounts, skipping the downloading of the securities might result in the account\'s balance also not being downloaded.<br/>&bull; For Bausparen accounts, this field is ignored. finAPI will always download transactions for Bausparen accounts.<br/>
   * @type {boolean}
   * @memberof ImportBankConnectionParams
   */
  skipPositionsDownload?: boolean;
  /**
   * Whether to load information about the bank connection owner(s) - see field \'owners\'. Default value is \'false\'.<br><br>NOTE: This feature is supported only by the WEB_SCRAPER interface.
   * @type {boolean}
   * @memberof ImportBankConnectionParams
   */
  loadOwnerData?: boolean;
  /**
   * Use this parameter if you want to limit the date range for transactions download. The value depicts the number of days that finAPI will download transactions for, starting from - and including - today. For example, if you want to download only transactions from within the past 30 days (including today), then pass the value 30. The minimum allowed value is 14, the maximum value is 3650. You may also pass the value 0 though (which is also the default value when you do not specify this parameter), in which case there will be no limit to the transactions download and finAPI will try to get all transactions that it can. Please note that when you specify the parameter there is no guarantee that finAPI will actually download transactions for the entire given date range, as the bank servers may limit the date range on their own. Also note that this parameter only applies to transactions, not to security positions; finAPI will always download all positions that it can get.<br/><br/><b>Please note: If you are not limiting the maxDaysForDownload with a value smaller than 90 days, the bank is more likely to trigger a strong customer authentication request for the user.</b>
   * @type {number}
   * @memberof ImportBankConnectionParams
   */
  maxDaysForDownload?: number;
  /**
   * A set of account types of finAPI account types that are considered for the import. Only accounts whose type matches with one of the given types will be imported. Note that when the bank connection does not contain any accounts of the given types, the import will fail with error code NO_ACCOUNTS_FOR_TYPE_LIST. If no values is given, then all accounts will be imported.<br/><br/><br/>Checking,<br/>Savings,<br/>CreditCard,<br/>Security,<br/>Loan,<br/>Pocket (DEPRECATED; will not be returned for any account unless this type has explicitly been set via PATCH),<br/>Membership,<br/>Bausparen<br/><br/><b>This flag is currently not guaranteed to work for all banks!</b>
   * @type {Array<string>}
   * @memberof ImportBankConnectionParams
   */
  accountTypes?: Array<ImportBankConnectionParamsAccountTypesEnum>;
  /**
   * Whitelist of identifiers of finAPI account types that are considered for the import. Only accounts whose type matches with one of the given types will be imported. Note that when the bank connection does not contain any accounts of the given types, the import will fail with error code NO_ACCOUNTS_FOR_TYPE_LIST. If no whitelist is given, then all accounts will be imported.<br/><br/>NOTE: This field is deprecated and would be removed at some point. Please refer to the accountTypes field instead.<br/><br/><br/>1 = Checking,<br/>2 = Savings,<br/>3 = CreditCard,<br/>4 = Security,<br/>5 = Loan,<br/>6 = Pocket (DEPRECATED; will not be returned for any account unless this type has explicitly been set via PATCH),<br/>7 = Membership,<br/>8 = Bausparen<br/><br/><b>This flag is currently not guaranteed to work for all banks!</b>
   * @type {Array<number>}
   * @memberof ImportBankConnectionParams
   */
  accountTypeIds?: Array<number>;
  /**
   * List of accounts for which access is requested from the bank. It must only be passed if the bank interface has the DETAILED_CONSENT property set.
   * @type {Array<AccountReference>}
   * @memberof ImportBankConnectionParams
   */
  accountReferences?: Array<AccountReference>;
  /**
   * NOTE: This field is DEPRECATED and will get removed at some point. Please refer to the \'multiStepAuthentication\' field instead.<br/><br/>Challenge response. This field should be set only when the previous attempt of importing the bank connection failed with HTTP code 510, i.e. the bank sent a challenge for the user for an additional authentication. In this case, this field must contain the response to the bank\'s challenge. Note that in the context of finAPI\'s web form flow, finAPI will automatically deal with getting the challenge response from the user via the web form.
   * @type {string}
   * @memberof ImportBankConnectionParams
   */
  challengeResponse?: string;
  /**
   *
   * @type {MultiStepAuthenticationCallback}
   * @memberof ImportBankConnectionParams
   */
  multiStepAuthentication?: MultiStepAuthenticationCallback;
  /**
   * Must only be passed when the used interface has the property REDIRECT_APPROACH and no web form flow is used. The user will be redirected to the given URL from the bank\'s website after having entered his credentials. Must use HTTPS protocol.
   * @type {string}
   * @memberof ImportBankConnectionParams
   */
  redirectUrl?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum ImportBankConnectionParamsInterfaceEnum {
  FINTSSERVER = "FINTS_SERVER",
  WEBSCRAPER = "WEB_SCRAPER",
  XS2A = "XS2A"
}
/**
 * @export
 * @enum {string}
 */
export enum ImportBankConnectionParamsAccountTypesEnum {
  Checking = "Checking",
  Savings = "Savings",
  CreditCard = "CreditCard",
  Security = "Security",
  Loan = "Loan",
  Pocket = "Pocket",
  Membership = "Membership",
  Bausparen = "Bausparen"
}

/**
 * Container for a keyword rule
 * @export
 * @interface KeywordRule
 */
export interface KeywordRule {
  /**
   * Rule identifier
   * @type {number}
   * @memberof KeywordRule
   */
  id: number;
  /**
   *
   * @type {Category}
   * @memberof KeywordRule
   */
  category: Category;
  /**
   * Direction for the rule. \'Income\' means that the rule applies to transactions with a positive amount only, \'Spending\' means it applies to transactions with a negative amount only.
   * @type {string}
   * @memberof KeywordRule
   */
  direction: KeywordRuleDirectionEnum;
  /**
   * Timestamp of when the rule was created, in the format \'YYYY-MM-DD HH:MM:SS.SSS\' (german time)
   * @type {string}
   * @memberof KeywordRule
   */
  creationDate: string;
  /**
   * Set of keywords that this rule defines.
   * @type {Array<string>}
   * @memberof KeywordRule
   */
  keywords: Array<string>;
}

/**
 * @export
 * @enum {string}
 */
export enum KeywordRuleDirectionEnum {
  Income = "Income",
  Spending = "Spending"
}

/**
 * Container for keyword rules
 * @export
 * @interface KeywordRuleList
 */
export interface KeywordRuleList {
  /**
   * List of keyword rules
   * @type {Array<KeywordRule>}
   * @memberof KeywordRuleList
   */
  keywordRules: Array<KeywordRule>;
}
/**
 * Parameters of keyword rule
 * @export
 * @interface KeywordRuleParams
 */
export interface KeywordRuleParams {
  /**
   * ID of the category that this rule should assign to the matching transactions
   * @type {number}
   * @memberof KeywordRuleParams
   */
  categoryId: number;
  /**
   * Direction for the rule. \'Income\' means that the rule applies to transactions with a positive amount only, \'Spending\' means it applies to transactions with a negative amount only. \'Both\' means that it applies to both kind of transactions. Note that in case of \'Both\', finAPI will create two individual rules (one with direction \'Income\' and one with direction \'Spending\').
   * @type {string}
   * @memberof KeywordRuleParams
   */
  direction: KeywordRuleParamsDirectionEnum;
  /**
   * Set of keywords for the rule (Keywords are regarded case-insensitive). The minimum number of keywords is 1. The maximum number of keywords is 100.
   * @type {Array<string>}
   * @memberof KeywordRuleParams
   */
  keywords: Array<string>;
}

/**
 * @export
 * @enum {string}
 */
export enum KeywordRuleParamsDirectionEnum {
  Income = "Income",
  Spending = "Spending",
  Both = "Both"
}

/**
 * Params for creation keyword rules
 * @export
 * @interface KeywordRulesParams
 */
export interface KeywordRulesParams {
  /**
   * Keyword rule definitions. The minimum number of rule definitions is 1. The maximum number of rule definitions is 100.
   * @type {Array<KeywordRuleParams>}
   * @memberof KeywordRulesParams
   */
  keywordRules: Array<KeywordRuleParams>;
}
/**
 * Container for a label\'s data
 * @export
 * @interface Label
 */
export interface Label {
  /**
   * Label identifier
   * @type {number}
   * @memberof Label
   */
  id: number;
  /**
   * Label name
   * @type {string}
   * @memberof Label
   */
  name: string;
}
/**
 * Container for labels
 * @export
 * @interface LabelList
 */
export interface LabelList {
  /**
   * Labels
   * @type {Array<Label>}
   * @memberof LabelList
   */
  labels: Array<Label>;
}
/**
 * Label\'s name
 * @export
 * @interface LabelParams
 */
export interface LabelParams {
  /**
   * Label\'s name. Maximum length is 288.
   * @type {string}
   * @memberof LabelParams
   */
  name: string;
}
/**
 * Login credential
 * @export
 * @interface LoginCredential
 */
export interface LoginCredential {
  /**
   * The login field label, as defined by the respective bank interface.
   * @type {string}
   * @memberof LoginCredential
   */
  label: string;
  /**
   * The value for the login field
   * @type {string}
   * @memberof LoginCredential
   */
  value: string;
}
/**
 * Container for a bank login credential
 * @export
 * @interface LoginCredentialResource
 */
export interface LoginCredentialResource {
  /**
   * Label for this login credential, as we suggest to show it to the user.
   * @type {string}
   * @memberof LoginCredentialResource
   */
  label?: string;
  /**
   * Stored value for this login credential
   * @type {string}
   * @memberof LoginCredentialResource
   */
  value?: string;
}
/**
 * Mock account data
 * @export
 * @interface MockAccountData
 */
export interface MockAccountData {
  /**
   * Account identifier
   * @type {number}
   * @memberof MockAccountData
   */
  accountId: number;
  /**
   * The balance that this account should be set to. Note that when the balance does not add up to the current balance plus the sum of the transactions you pass in the \'newTransactions\' field, finAPI will fix the balance deviation with the insertion of an adjusting entry (\'Zwischensaldo\' transaction).
   * @type {number}
   * @memberof MockAccountData
   */
  accountBalance: number;
  /**
   * New transactions that should be imported into the account (maximum 1000 transactions at once). Please make sure that the value you pass in the \'accountBalance\' field equals the current account balance plus the sum of the new transactions that you pass here, otherwise finAPI will detect a deviation in the balance and fix it with the insertion of an adjusting entry (\'Zwischensaldo\' transaction). Please also note that it is not guaranteed that all transactions that you pass here will actually get imported. More specifically, finAPI will ignore any transactions whose booking date is prior to the booking date of the latest currently existing transactions minus 10 days (which is the \'update window\' that finAPI uses when importing new transactions). Also, finAPI will ignore any transactions that are considered duplicates of already existing transactions within the update window. This is the case for instance when you try to import a new transaction with the same booking date and same amount as an already existing transaction. In such cases, you might get an adjusting entry too (\'Zwischensaldo\' transaction), as your given balance might not add up to the transactions that will exist in the account after the update.
   * @type {Array<NewTransaction>}
   * @memberof MockAccountData
   */
  newTransactions?: Array<NewTransaction>;
}
/**
 * Data for a mock bank connection update
 * @export
 * @interface MockBankConnectionUpdate
 */
export interface MockBankConnectionUpdate {
  /**
   * Bank connection identifier
   * @type {number}
   * @memberof MockBankConnectionUpdate
   */
  bankConnectionId: number;
  /**
   * Banking interface to update. If not specified, then first available interface in bank connection will be used.
   * @type {string}
   * @memberof MockBankConnectionUpdate
   */
  _interface?: MockBankConnectionUpdateInterfaceEnum;
  /**
   * Whether to simulate the case that the update fails due to incorrect banking credentials. Note that there is no real communication to any bank server involved, so you won\'t lock your accounts when enabling this flag. Default value is \'false\'.
   * @type {boolean}
   * @memberof MockBankConnectionUpdate
   */
  simulateBankLoginError?: boolean;
  /**
   * Mock accounts data. Note that for accounts that exist in a bank connection but that you do not specify in this list, the service will act like those accounts are not received by the bank servers. This means that any accounts that you do not specify here will be marked as deprecated. If you do not specify this list at all, all accounts in the bank connection will be marked as deprecated.
   * @type {Array<MockAccountData>}
   * @memberof MockBankConnectionUpdate
   */
  mockAccountsData?: Array<MockAccountData>;
}

/**
 * @export
 * @enum {string}
 */
export enum MockBankConnectionUpdateInterfaceEnum {
  FINTSSERVER = "FINTS_SERVER",
  WEBSCRAPER = "WEB_SCRAPER",
  XS2A = "XS2A"
}

/**
 * Data for mock bank connection updates
 * @export
 * @interface MockBatchUpdateParams
 */
export interface MockBatchUpdateParams {
  /**
   * List of mock bank connection updates
   * @type {Array<MockBankConnectionUpdate>}
   * @memberof MockBatchUpdateParams
   */
  mockBankConnectionUpdates: Array<MockBankConnectionUpdate>;
  /**
   * Whether this call should trigger the dispatching of notifications. Default is \'false\'.
   * @type {boolean}
   * @memberof MockBatchUpdateParams
   */
  triggerNotifications?: boolean;
}
/**
 * Bank server\'s response to a money transfer order request
 * @export
 * @interface MoneyTransferOrderingResponse
 */
export interface MoneyTransferOrderingResponse {
  /**
   * Technical message from the bank server, confirming the success of the request. Typically, you would not want to present this message to the user. Note that this field may not be set. However if it is not set, it does not necessarily mean that there was an error in processing the request.
   * @type {string}
   * @memberof MoneyTransferOrderingResponse
   */
  successMessage?: string;
  /**
   * In some cases, a bank server may accept the requested order, but return a warn message. This message may be of technical nature, but could also be of interest to the user.
   * @type {string}
   * @memberof MoneyTransferOrderingResponse
   */
  warnMessage?: string;
  /**
   * Payment identifier. Can be used to retrieve the status of the payment (see \'Get payments\' service).
   * @type {number}
   * @memberof MoneyTransferOrderingResponse
   */
  paymentId: number;
  /**
   * Message from the bank server containing information or instructions on how to retrieve the TAN that is needed to execute the requested order. This message should be presented to the user. Note that some bank servers may limit the message to just the most crucial information, e.g. the message may contain just a single number that depicts the target TAN number on a user\'s TAN list. You may want to parse the challenge message for such cases and extend it with more detailed information before showing it to the user.
   * @type {string}
   * @memberof MoneyTransferOrderingResponse
   */
  challengeMessage?: string;
  /**
   * Suggestion from the bank server on how you can label your input field where the user must enter his TAN. A typical value that many bank servers give is \'TAN-Nummer\'.
   * @type {string}
   * @memberof MoneyTransferOrderingResponse
   */
  answerFieldLabel?: string;
  /**
   * In case that the bank server has instructed the user to look up a TAN from a TAN list, this field may contain the identification number of the TAN list. However in most cases, this field is only set (i.e. not null) when the user has multiple active TAN lists.
   * @type {string}
   * @memberof MoneyTransferOrderingResponse
   */
  tanListNumber?: string;
  /**
   * In case that the bank server has instructed the user to scan a flicker code, then this field will contain the raw data for the flicker animation as a BASE-64 string. Otherwise, this field will be not set (i.e. null). For more information on how to process the flicker code data, please address the <a href=\'https://finapi.zendesk.com\' target=\'_blank\'>finAPI Developer Portal</a>.
   * @type {string}
   * @memberof MoneyTransferOrderingResponse
   */
  opticalData?: string;
  /**
   * In case that the \'photoTanData\' field is set (i.e. not null), this field contains the MIME type to use for interpreting the photo data (e.g.: \'image/png\')
   * @type {string}
   * @memberof MoneyTransferOrderingResponse
   */
  photoTanMimeType?: string;
  /**
   * In case that the bank server has instructed the user to scan a photo (or more generally speaking, any kind of QR-code-like data), then this field will contain the raw data of the photo as a BASE-64 string. Otherwise, this field will be not set (i.e. null). For more information on how to process the photo data, please address the <a href=\'https://finapi.zendesk.com\' target=\'_blank\'>finAPI Developer Portal</a>.
   * @type {string}
   * @memberof MoneyTransferOrderingResponse
   */
  photoTanData?: string;
}
/**
 * Information about a user\'s data or activities for a certain month
 * @export
 * @interface MonthlyUserStats
 */
export interface MonthlyUserStats {
  /**
   * The month that the contained information applies to, in the format \'YYYY-MM\'.
   * @type {string}
   * @memberof MonthlyUserStats
   */
  month: string;
  /**
   * Minimum count of bank connections that this user has had at any point during the month.
   * @type {number}
   * @memberof MonthlyUserStats
   */
  minBankConnectionCount: number;
  /**
   * Maximum count of bank connections that this user has had at any point during the month.
   * @type {number}
   * @memberof MonthlyUserStats
   */
  maxBankConnectionCount: number;
}
/**
 * Container for multi-step authentication data, as passed by the client to finAPI
 * @export
 * @interface MultiStepAuthenticationCallback
 */
export interface MultiStepAuthenticationCallback {
  /**
   * Hash that was returned in the previous multi-step authentication error.
   * @type {string}
   * @memberof MultiStepAuthenticationCallback
   */
  hash: string;
  /**
   * Challenge response. Must be set when the previous multi-step authentication error had status \'CHALLENGE_RESPONSE_REQUIRED.
   * @type {string}
   * @memberof MultiStepAuthenticationCallback
   */
  challengeResponse?: string;
  /**
   * The bank-given ID of the two-step-procedure that should be used for authentication. Must be set when the previous multi-step authentication error had status \'TWO_STEP_PROCEDURE_REQUIRED.
   * @type {string}
   * @memberof MultiStepAuthenticationCallback
   */
  twoStepProcedureId?: string;
  /**
   * Must be passed when the previous multi-step authentication error had status \'REDIRECT_REQUIRED\'. The value must consist of the complete query parameter list that was contained in the received redirect from the bank.
   * @type {string}
   * @memberof MultiStepAuthenticationCallback
   */
  redirectCallback?: string;
  /**
   * Must be passed when the previous multi-step authentication error had status \'DECOUPLED_AUTH_REQUIRED\' or \'DECOUPLED_AUTH_IN_PROGRESS\'. The field represents the state of the decoupled authentication meaning that when it\'s set to \'true\', the end-user has completed the authentication process on bank\'s side.
   * @type {boolean}
   * @memberof MultiStepAuthenticationCallback
   */
  decoupledCallback?: boolean;
}
/**
 * Container for multi-step authentication data, as returned by finAPI to the client
 * @export
 * @interface MultiStepAuthenticationChallenge
 */
export interface MultiStepAuthenticationChallenge {
  /**
   * Hash for this multi-step authentication flow. Must be passed back to finAPI when continuing the flow.
   * @type {string}
   * @memberof MultiStepAuthenticationChallenge
   */
  hash: string;
  /**
   * Indicates the current status of the multi-step authentication flow:<br/><br/>TWO_STEP_PROCEDURE_REQUIRED means that the bank has requested an SCA method selection for the user. In this case, the service should be recalled with a chosen TSP-ID set to the \'twoStepProcedureId\' field.<br/>When the web form flow is used, the user is forwarded to finAPI\'s web form to prompt for his credentials (if they are not stored in finAPI) and to select the preferred SCA method.<br/><br/>CHALLENGE_RESPONSE_REQUIRED means that the bank has requested a challenge code for the previously given TSP (SCA). This status can be completed by setting the \'challengeResponse\' field.<br/>When the web form flow is used, the user should submit the challenge response for the challenge message shown by the web form.<br/><br/>REDIRECT_REQUIRED means that the user must be redirected to the bank\'s website, where the authentication can be finished.<br/>When the web form flow is used, the user should visit the web form, get a redirect to the bank\'s website, complete the authentication and will then be redirected back to the web form.<br/><br/>DECOUPLED_AUTH_REQUIRED means that the bank has asked for the decoupled authentication. In this case, the \'decoupledCallback\' field must be set to true to complete the authentication.<br/><br/>DECOUPLED_AUTH_IN_PROGRESS means that the bank is waiting for the completion of the decoupled authentication by the user. Until this is done, the service should be recalled with the \'decoupledCallback\' field set to ‘true’. Once the decoupled authentication is completed by the user, the service returns a successful response.
   * @type {string}
   * @memberof MultiStepAuthenticationChallenge
   */
  status: MultiStepAuthenticationChallengeStatusEnum;
  /**
   * In case of status = CHALLENGE_RESPONSE_REQUIRED, this field contains a message from the bank containing instructions for the user on how to proceed with the authorization.
   * @type {string}
   * @memberof MultiStepAuthenticationChallenge
   */
  challengeMessage?: string;
  /**
   * Suggestion from the bank on how you can label your input field where the user should enter his challenge response.
   * @type {string}
   * @memberof MultiStepAuthenticationChallenge
   */
  answerFieldLabel?: string;
  /**
   * In case of status = REDIRECT_REQUIRED, this field contains the URL to which you must direct the user. It already includes the redirect URL back to your client that you have passed when initiating the service call.
   * @type {string}
   * @memberof MultiStepAuthenticationChallenge
   */
  redirectUrl?: string;
  /**
   * Set in case of status = REDIRECT_REQUIRED. When the bank redirects the user back to your client, the redirect URL will contain this string, which you must process to identify the user context for the callback on your side.
   * @type {string}
   * @memberof MultiStepAuthenticationChallenge
   */
  redirectContext?: string;
  /**
   * Set in case of status = REDIRECT_REQUIRED. This field is set to the name of the query parameter that contains the \'redirectContext\' in the redirect URL from the bank back to your client.
   * @type {string}
   * @memberof MultiStepAuthenticationChallenge
   */
  redirectContextField?: string;
  /**
   * In case of status = TWO_STEP_PROCEDURE_REQUIRED, this field contains the available two-step procedures. Note that this set does not necessarily match the set that is stored in the respective bank connection interface. You should always use the set from this field for the multi-step authentication flow.
   * @type {Array<TwoStepProcedure>}
   * @memberof MultiStepAuthenticationChallenge
   */
  twoStepProcedures?: Array<TwoStepProcedure>;
  /**
   * In case that the bank server has instructed the user to scan a flicker code, then this field will contain the raw data for the flicker animation as a BASE-64 string.
   * @type {string}
   * @memberof MultiStepAuthenticationChallenge
   */
  opticalData?: string;
  /**
   * In case that the \'photoTanData\' field is set (i.e. not null), this field contains the MIME type to use for interpreting the photo data (e.g.: \'image/png\')
   * @type {string}
   * @memberof MultiStepAuthenticationChallenge
   */
  photoTanMimeType?: string;
  /**
   * In case that the bank server has instructed the user to scan a photo (or more generally speaking, any kind of QR-code-like data), then this field will contain the raw data of the photo as a BASE-64 string.
   * @type {string}
   * @memberof MultiStepAuthenticationChallenge
   */
  photoTanData?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum MultiStepAuthenticationChallengeStatusEnum {
  CHALLENGERESPONSEREQUIRED = "CHALLENGE_RESPONSE_REQUIRED",
  TWOSTEPPROCEDUREREQUIRED = "TWO_STEP_PROCEDURE_REQUIRED",
  REDIRECTREQUIRED = "REDIRECT_REQUIRED",
  DECOUPLEDAUTHREQUIRED = "DECOUPLED_AUTH_REQUIRED",
  DECOUPLEDAUTHINPROGRESS = "DECOUPLED_AUTH_IN_PROGRESS"
}

/**
 * Mock transaction data
 * @export
 * @interface NewTransaction
 */
export interface NewTransaction {
  /**
   * Amount. Required.
   * @type {number}
   * @memberof NewTransaction
   */
  amount: number;
  /**
   * Purpose. Any symbols are allowed. Maximum length is 2000. Optional. Default value: null.
   * @type {string}
   * @memberof NewTransaction
   */
  purpose?: string;
  /**
   * Counterpart. Any symbols are allowed. Maximum length is 80. Optional. Default value: null.
   * @type {string}
   * @memberof NewTransaction
   */
  counterpart?: string;
  /**
   * Counterpart IBAN. Optional. Default value: null.
   * @type {string}
   * @memberof NewTransaction
   */
  counterpartIban?: string;
  /**
   * Counterpart BLZ. Optional. Default value: null.
   * @type {string}
   * @memberof NewTransaction
   */
  counterpartBlz?: string;
  /**
   * Counterpart BIC. Optional. Default value: null.
   * @type {string}
   * @memberof NewTransaction
   */
  counterpartBic?: string;
  /**
   * Counterpart account number. Maximum length is 34. Optional. Default value: null.
   * @type {string}
   * @memberof NewTransaction
   */
  counterpartAccountNumber?: string;
  /**
   * Booking date in the format \'YYYY-MM-DD\'.<br/><br/>If the date lies back more than 10 days from the booking date of the latest transaction that currently exists in the account, then this transaction will be ignored and not imported. If the date depicts a date in the future, then finAPI will deal with it the same way as it does with real transactions during a real update (see fields \'bankBookingDate\' and \'finapiBookingDate\' in the Transaction Resource for explanation).<br/><br/>This field is optional, default value is the current date.
   * @type {string}
   * @memberof NewTransaction
   */
  bookingDate?: string;
  /**
   * Value date in the format \'YYYY-MM-DD\'. Optional. Default value: Same as the booking date.
   * @type {string}
   * @memberof NewTransaction
   */
  valueDate?: string;
}
/**
 * Data of notification rule
 * @export
 * @interface NotificationRule
 */
export interface NotificationRule {
  /**
   * Notification rule identifier
   * @type {number}
   * @memberof NotificationRule
   */
  id: number;
  /**
   * Trigger event type
   * @type {string}
   * @memberof NotificationRule
   */
  triggerEvent: NotificationRuleTriggerEventEnum;
  /**
   * Additional parameters that are specific to the trigger event type. Please refer to the documentation for details.
   * @type {{ [key: string]: string; }}
   * @memberof NotificationRule
   */
  params?: { [key: string]: string };
  /**
   * The string that finAPI includes into the notifications that it sends based on this rule.
   * @type {string}
   * @memberof NotificationRule
   */
  callbackHandle?: string;
  /**
   * Whether the notification messages that will be sent based on this rule contain encrypted detailed data or not
   * @type {boolean}
   * @memberof NotificationRule
   */
  includeDetails: boolean;
}

/**
 * @export
 * @enum {string}
 */
export enum NotificationRuleTriggerEventEnum {
  NEWACCOUNTBALANCE = "NEW_ACCOUNT_BALANCE",
  NEWTRANSACTIONS = "NEW_TRANSACTIONS",
  BANKLOGINERROR = "BANK_LOGIN_ERROR",
  FOREIGNMONEYTRANSFER = "FOREIGN_MONEY_TRANSFER",
  LOWACCOUNTBALANCE = "LOW_ACCOUNT_BALANCE",
  HIGHTRANSACTIONAMOUNT = "HIGH_TRANSACTION_AMOUNT",
  CATEGORYCASHFLOW = "CATEGORY_CASH_FLOW",
  NEWTERMSANDCONDITIONS = "NEW_TERMS_AND_CONDITIONS"
}

/**
 * Container for notification rules
 * @export
 * @interface NotificationRuleList
 */
export interface NotificationRuleList {
  /**
   * List of notification rules
   * @type {Array<NotificationRule>}
   * @memberof NotificationRuleList
   */
  notificationRules?: Array<NotificationRule>;
}
/**
 * Parameters of notification rule
 * @export
 * @interface NotificationRuleParams
 */
export interface NotificationRuleParams {
  /**
   * Trigger event type
   * @type {string}
   * @memberof NotificationRuleParams
   */
  triggerEvent: NotificationRuleParamsTriggerEventEnum;
  /**
   * Additional parameters that are specific to the chosen trigger event type. Please refer to the documentation for details.
   * @type {{ [key: string]: string; }}
   * @memberof NotificationRuleParams
   */
  params?: { [key: string]: string };
  /**
   * An arbitrary string that finAPI will include into the notifications that it sends based on this rule and that you can use to identify the notification in your application. For instance, you could include the identifier of the user that you create this rule for. Maximum allowed length of the string is 512 characters.<br/><br/>Note that for this parameter, you can pass the symbols \'/\', \'=\', \'%\' and \'\"\' in addition to the symbols that are generally allowed in finAPI (see https://finapi.zendesk.com/hc/en-us/articles/222013148). This was done to enable you to set Base64 encoded strings and JSON structures for the callback handle.
   * @type {string}
   * @memberof NotificationRuleParams
   */
  callbackHandle?: string;
  /**
   * Whether the notification messages that will be sent based on this rule should contain encrypted detailed data or not
   * @type {boolean}
   * @memberof NotificationRuleParams
   */
  includeDetails?: boolean;
}

/**
 * @export
 * @enum {string}
 */
export enum NotificationRuleParamsTriggerEventEnum {
  NEWACCOUNTBALANCE = "NEW_ACCOUNT_BALANCE",
  NEWTRANSACTIONS = "NEW_TRANSACTIONS",
  BANKLOGINERROR = "BANK_LOGIN_ERROR",
  FOREIGNMONEYTRANSFER = "FOREIGN_MONEY_TRANSFER",
  LOWACCOUNTBALANCE = "LOW_ACCOUNT_BALANCE",
  HIGHTRANSACTIONAMOUNT = "HIGH_TRANSACTION_AMOUNT",
  CATEGORYCASHFLOW = "CATEGORY_CASH_FLOW",
  NEWTERMSANDCONDITIONS = "NEW_TERMS_AND_CONDITIONS"
}

/**
 * Container for banks with paging info
 * @export
 * @interface PageableBankList
 */
export interface PageableBankList {
  /**
   * Banks
   * @type {Array<Bank>}
   * @memberof PageableBankList
   */
  banks: Array<Bank>;
  /**
   *
   * @type {Paging}
   * @memberof PageableBankList
   */
  paging: Paging;
}
/**
 * Container for categories with paging info
 * @export
 * @interface PageableCategoryList
 */
export interface PageableCategoryList {
  /**
   * Categories
   * @type {Array<Category>}
   * @memberof PageableCategoryList
   */
  categories: Array<Category>;
  /**
   *
   * @type {Paging}
   * @memberof PageableCategoryList
   */
  paging: Paging;
}
/**
 * Container for IBAN rule information with paging info
 * @export
 * @interface PageableIbanRuleList
 */
export interface PageableIbanRuleList {
  /**
   * List of iban rules information
   * @type {Array<IbanRule>}
   * @memberof PageableIbanRuleList
   */
  ibanRules: Array<IbanRule>;
  /**
   *
   * @type {Paging}
   * @memberof PageableIbanRuleList
   */
  paging: Paging;
}
/**
 * Container for keyword rule information with paging info
 * @export
 * @interface PageableKeywordRuleList
 */
export interface PageableKeywordRuleList {
  /**
   * List of keyword rules
   * @type {Array<KeywordRule>}
   * @memberof PageableKeywordRuleList
   */
  keywordRules: Array<KeywordRule>;
  /**
   *
   * @type {Paging}
   * @memberof PageableKeywordRuleList
   */
  paging: Paging;
}
/**
 * Label resources with paging information
 * @export
 * @interface PageableLabelList
 */
export interface PageableLabelList {
  /**
   * Labels
   * @type {Array<Label>}
   * @memberof PageableLabelList
   */
  labels: Array<Label>;
  /**
   *
   * @type {Paging}
   * @memberof PageableLabelList
   */
  paging: Paging;
}
/**
 * Payment resources with paging information
 * @export
 * @interface PageablePaymentResources
 */
export interface PageablePaymentResources {
  /**
   * List of received account payments
   * @type {Array<Payment>}
   * @memberof PageablePaymentResources
   */
  payments: Array<Payment>;
  /**
   *
   * @type {Paging}
   * @memberof PageablePaymentResources
   */
  paging: Paging;
}
/**
 * Container for page of securities
 * @export
 * @interface PageableSecurityList
 */
export interface PageableSecurityList {
  /**
   * List of securities
   * @type {Array<Security>}
   * @memberof PageableSecurityList
   */
  securities: Array<Security>;
  /**
   *
   * @type {Paging}
   * @memberof PageableSecurityList
   */
  paging: Paging;
}
/**
 * TPP Authentication groups with paging information
 * @export
 * @interface PageableTppAuthenticationGroupResources
 */
export interface PageableTppAuthenticationGroupResources {
  /**
   * List of received TPP authentication groups
   * @type {Array<TppAuthenticationGroup>}
   * @memberof PageableTppAuthenticationGroupResources
   */
  tppAuthenticationGroups: Array<TppAuthenticationGroup>;
  /**
   *
   * @type {Paging}
   * @memberof PageableTppAuthenticationGroupResources
   */
  paging: Paging;
}
/**
 * Container for bank certificate information with paging info
 * @export
 * @interface PageableTppCertificateList
 */
export interface PageableTppCertificateList {
  /**
   * List of certificates
   * @type {Array<TppCertificate>}
   * @memberof PageableTppCertificateList
   */
  tppCertificates: Array<TppCertificate>;
  /**
   *
   * @type {Paging}
   * @memberof PageableTppCertificateList
   */
  paging: Paging;
}
/**
 * Container for TPP client credentials information with paging info
 * @export
 * @interface PageableTppCredentialResources
 */
export interface PageableTppCredentialResources {
  /**
   * List of TPP client credentials
   * @type {Array<TppCredentials>}
   * @memberof PageableTppCredentialResources
   */
  tppCredentials: Array<TppCredentials>;
  /**
   *
   * @type {Paging}
   * @memberof PageableTppCredentialResources
   */
  paging: Paging;
}
/**
 * Container for a page of transactions, with data about the total count of transactions and their balance
 * @export
 * @interface PageableTransactionList
 */
export interface PageableTransactionList {
  /**
   * Array of transactions (for the requested page)
   * @type {Array<Transaction>}
   * @memberof PageableTransactionList
   */
  transactions: Array<Transaction>;
  /**
   *
   * @type {Paging}
   * @memberof PageableTransactionList
   */
  paging: Paging;
  /**
   * The total income of all transactions (across all pages)
   * @type {number}
   * @memberof PageableTransactionList
   */
  income: number;
  /**
   * The total spending of all transactions (across all pages)
   * @type {number}
   * @memberof PageableTransactionList
   */
  spending: number;
  /**
   * The total sum of all transactions (across all pages)
   * @type {number}
   * @memberof PageableTransactionList
   */
  balance: number;
}
/**
 * Container for users information with paging info
 * @export
 * @interface PageableUserInfoList
 */
export interface PageableUserInfoList {
  /**
   * List of users information
   * @type {Array<UserInfo>}
   * @memberof PageableUserInfoList
   */
  users: Array<UserInfo>;
  /**
   *
   * @type {Paging}
   * @memberof PageableUserInfoList
   */
  paging: Paging;
}
/**
 * Container for pagination information
 * @export
 * @interface Paging
 */
export interface Paging {
  /**
   * Current page number
   * @type {number}
   * @memberof Paging
   */
  page: number;
  /**
   * Current page size (number of entries in this page)
   * @type {number}
   * @memberof Paging
   */
  perPage: number;
  /**
   * Total number of pages
   * @type {number}
   * @memberof Paging
   */
  pageCount: number;
  /**
   * Total number of entries across all pages
   * @type {number}
   * @memberof Paging
   */
  totalCount: number;
}
/**
 * Password changing details
 * @export
 * @interface PasswordChangingResource
 */
export interface PasswordChangingResource {
  /**
   * User identifier
   * @type {string}
   * @memberof PasswordChangingResource
   */
  userId: string;
  /**
   * User\'s email, encrypted. Decrypt with your data decryption key. If the user has no email set, then this field will be null.
   * @type {string}
   * @memberof PasswordChangingResource
   */
  userEmail?: string;
  /**
   * Encrypted password change token. Decrypt this token with your data decryption key, and pass the decrypted token to the /users/executePasswordChange service in order to set a new password for the user.
   * @type {string}
   * @memberof PasswordChangingResource
   */
  passwordChangeToken: string;
}
/**
 * Container for a payment\'s data
 * @export
 * @interface Payment
 */
export interface Payment {
  /**
   * Payment identifier
   * @type {number}
   * @memberof Payment
   */
  id: number;
  /**
   * Identifier of the account to which this payment relates
   * @type {number}
   * @memberof Payment
   */
  accountId: number;
  /**
   * Payment type
   * @type {string}
   * @memberof Payment
   */
  type: PaymentTypeEnum;
  /**
   * Total money amount of the payment order(s), as absolute value
   * @type {number}
   * @memberof Payment
   */
  amount: number;
  /**
   * Total count of orders included in this payment
   * @type {number}
   * @memberof Payment
   */
  orderCount: number;
  /**
   * Current payment status:<br/> &bull; OPEN: means that this payment has been created in finAPI, but not yet submitted to the bank.<br/> &bull; PENDING: means that this payment has been requested at the bank, but not yet executed.<br/> &bull; SUCCESSFUL: means that this payment has been successfully executed.<br/> &bull; NOT_SUCCESSFUL: means that this payment could not be executed successfully.<br/> &bull; DISCARDED: means that this payment was discarded, either because another payment was requested for the same account before this payment was executed and the bank does not support this, or because the bank has rejected the payment even before the execution.
   * @type {string}
   * @memberof Payment
   */
  status: PaymentStatusEnum;
  /**
   * Contains the bank\'s response to the execution of this payment. This field is not set until the payment gets executed. Note that even after the execution of the payment, the field might still not be set, if the bank did not send any response message.
   * @type {string}
   * @memberof Payment
   */
  bankMessage?: string;
  /**
   * Time of when this payment was requested, in the format \'YYYY-MM-DD HH:MM:SS.SSS\' (german time)
   * @type {string}
   * @memberof Payment
   */
  requestDate?: string;
  /**
   * Time of when this payment was executed, in the format \'YYYY-MM-DD HH:MM:SS.SSS\' (german time)
   * @type {string}
   * @memberof Payment
   */
  executionDate?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum PaymentTypeEnum {
  MONEYTRANSFER = "MONEY_TRANSFER",
  DIRECTDEBIT = "DIRECT_DEBIT"
}
/**
 * @export
 * @enum {string}
 */
export enum PaymentStatusEnum {
  OPEN = "OPEN",
  PENDING = "PENDING",
  SUCCESSFUL = "SUCCESSFUL",
  NOTSUCCESSFUL = "NOT_SUCCESSFUL",
  DISCARDED = "DISCARDED"
}

/**
 * Bank server\'s response to Money Transfer / Direct Debit execution
 * @export
 * @interface PaymentExecutionResponse
 */
export interface PaymentExecutionResponse {
  /**
   * Technical message from the bank server, confirming the success of the request. Typically, you would not want to present this message to the user. Note that this field may not be set. However if it is not set, it does not necessarily mean that there was an error in processing the request.
   * @type {string}
   * @memberof PaymentExecutionResponse
   */
  successMessage?: string;
  /**
   * In some cases, a bank server may accept the requested order, but return a warn message. This message may be of technical nature, but could also be of interest to the user.
   * @type {string}
   * @memberof PaymentExecutionResponse
   */
  warnMessage?: string;
  /**
   * Payment identifier. Can be used to retrieve the status of the payment (see \'Get payments\' service).
   * @type {number}
   * @memberof PaymentExecutionResponse
   */
  paymentId: number;
}
/**
 * Additional, PayPal-specific transaction data. This field is only set for transactions that belong to an account of the \'PayPal\' bank (BLZ \'PAYPAL\').
 * @export
 * @interface PaypalTransactionData
 */
export interface PaypalTransactionData {
  /**
   * Invoice Number.<br/>NOTE: This field is deprecated as the bank with blz \'PAYPAL\' is no longer supported. Do not use this field, as it will be removed at some point.
   * @type {string}
   * @memberof PaypalTransactionData
   */
  invoiceNumber?: string;
  /**
   * Fee value.<br/>NOTE: This field is deprecated as the bank with blz \'PAYPAL\' is no longer supported. Do not use this field, as it will be removed at some point.
   * @type {number}
   * @memberof PaypalTransactionData
   */
  fee?: number;
  /**
   * Net value.<br/>NOTE: This field is deprecated as the bank with blz \'PAYPAL\' is no longer supported. Do not use this field, as it will be removed at some point.
   * @type {number}
   * @memberof PaypalTransactionData
   */
  net?: number;
  /**
   * Auction Site.<br/>NOTE: This field is deprecated as the bank with blz \'PAYPAL\' is no longer supported. Do not use this field, as it will be removed at some point.
   * @type {string}
   * @memberof PaypalTransactionData
   */
  auctionSite?: string;
}
/**
 * Container for interface removal parameters
 * @export
 * @interface RemoveInterfaceParams
 */
export interface RemoveInterfaceParams {
  /**
   * Bank connection identifier
   * @type {number}
   * @memberof RemoveInterfaceParams
   */
  bankConnectionId: number;
  /**
   * The interface which you want to remove.
   * @type {string}
   * @memberof RemoveInterfaceParams
   */
  _interface?: RemoveInterfaceParamsInterfaceEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum RemoveInterfaceParamsInterfaceEnum {
  FINTSSERVER = "FINTS_SERVER",
  WEBSCRAPER = "WEB_SCRAPER",
  XS2A = "XS2A"
}

/**
 * Request password change parameters
 * @export
 * @interface RequestPasswordChangeParams
 */
export interface RequestPasswordChangeParams {
  /**
   * User identifier
   * @type {string}
   * @memberof RequestPasswordChangeParams
   */
  userId: string;
}
/**
 * Parameters for a single or collective SEPA direct debit order request
 * @export
 * @interface RequestSepaDirectDebitParams
 */
export interface RequestSepaDirectDebitParams {
  /**
   * Identifier of the bank account to which you want to transfer the money.
   * @type {number}
   * @memberof RequestSepaDirectDebitParams
   */
  accountId: number;
  /**
   * Online banking PIN. Any symbols are allowed. Max length: 170. If a PIN is stored in the bank connection, then this field may remain unset. If finAPI\'s web form is not required and the field is set though then it will always be used (even if there is some other PIN stored in the bank connection). If you want the user to enter a PIN in finAPI\'s web form even when a PIN is stored, then just set the field to any value, so that the service recognizes that you wish to use the web form flow.
   * @type {string}
   * @memberof RequestSepaDirectDebitParams
   */
  bankingPin?: string;
  /**
   * Whether to store the PIN. If the PIN is stored, it is not required to pass the PIN again when executing SEPA orders. Default value is \'false\'. <br/><br/>NOTES:<br/> - before you set this field to true, please regard the \'pinsAreVolatile\' flag of the bank connection that the account belongs to;<br/> - this field is ignored in case when the user will need to use finAPI\'s web form. The user will be able to decide whether to store the PIN or not in the web form, depending on the \'storeSecretsAvailableInWebForm\' setting (see Client Configuration).
   * @type {boolean}
   * @memberof RequestSepaDirectDebitParams
   */
  storeSecrets?: boolean;
  /**
   * The bank-given ID of the two-step-procedure that should be used for the order. For a list of available two-step-procedures, see the corresponding bank connection (GET /bankConnections). If this field is not set, then the bank connection\'s default two-step-procedure will be used. Note that in this case, when the bank connection has no default two-step-procedure set, then the response of the service depends on whether you need to use finAPI\'s web form or not. If you need to use the web form, the user will be prompted to select the two-step-procedure within the web form. If you don\'t need to use the web form, then the service will return an error (passing a value for this field is required in this case).
   * @type {string}
   * @memberof RequestSepaDirectDebitParams
   */
  twoStepProcedureId?: string;
  /**
   * Type of the direct debit; either <code>BASIC</code> or <code>B2B</code> (Business-To-Business). Please note that an account which supports the basic type must not necessarily support B2B (or vice versa). Check the source account\'s \'supportedOrders\' field to find out which types of direct debit it supports.<br/><br/>
   * @type {string}
   * @memberof RequestSepaDirectDebitParams
   */
  directDebitType: RequestSepaDirectDebitParamsDirectDebitTypeEnum;
  /**
   * Sequence type of the direct debit. Possible values:<br/><br/>&bull; <code>OOFF</code> - means that this is a one-time direct debit order<br/>&bull; <code>FRST</code> - means that this is the first in a row of multiple direct debit orders<br/>&bull; <code>RCUR</code> - means that this is one (but not the first or final) within a row of multiple direct debit orders<br/>&bull; <code>FNAL</code> - means that this is the final in a row of multiple direct debit orders<br/><br/>
   * @type {string}
   * @memberof RequestSepaDirectDebitParams
   */
  sequenceType: RequestSepaDirectDebitParamsSequenceTypeEnum;
  /**
   * Execution date for the direct debit(s), in the format \'YYYY-MM-DD\'.
   * @type {string}
   * @memberof RequestSepaDirectDebitParams
   */
  executionDate: string;
  /**
   * This field is only regarded when you pass multiple orders. It determines whether the orders should be processed by the bank as one collective booking (in case of \'false\'), or as single bookings (in case of \'true\'). Default value is \'false\'.
   * @type {boolean}
   * @memberof RequestSepaDirectDebitParams
   */
  singleBooking?: boolean;
  /**
   * List of the direct debits that you want to execute (may contain at most 15000 items). Please check the account\'s \'supportedOrders\' field to find out whether you can pass multiple direct debits or just one.
   * @type {Array<SingleDirectDebitData>}
   * @memberof RequestSepaDirectDebitParams
   */
  directDebits: Array<SingleDirectDebitData>;
  /**
   * Whether the finAPI web form should hide transaction details when prompting the caller for the second factor. Default value is false.
   * @type {boolean}
   * @memberof RequestSepaDirectDebitParams
   */
  hideTransactionDetailsInWebForm?: boolean;
  /**
   *
   * @type {MultiStepAuthenticationCallback}
   * @memberof RequestSepaDirectDebitParams
   */
  multiStepAuthentication?: MultiStepAuthenticationCallback;
  /**
   * Whether to store the PIN. If the PIN is stored, it is not required to pass the PIN again when executing SEPA orders. Default value is \'false\'. <br/><br/>NOTES:<br/> - before you set this field to true, please regard the \'pinsAreVolatile\' flag of the bank connection that the account belongs to;<br/> - this field is ignored in case when the user will need to use finAPI\'s web form. The user will be able to decide whether to store the PIN or not in the web form, depending on the \'storeSecretsAvailableInWebForm\' setting (see Client Configuration).<br><br>NOTE: This field is deprecated and will be removed at some point. Use \'storeSecrets\' instead.
   * @type {boolean}
   * @memberof RequestSepaDirectDebitParams
   */
  storePin?: boolean;
}

/**
 * @export
 * @enum {string}
 */
export enum RequestSepaDirectDebitParamsDirectDebitTypeEnum {
  B2B = "B2B",
  BASIC = "BASIC"
}
/**
 * @export
 * @enum {string}
 */
export enum RequestSepaDirectDebitParamsSequenceTypeEnum {
  OOFF = "OOFF",
  FRST = "FRST",
  RCUR = "RCUR",
  FNAL = "FNAL"
}

/**
 * Parameters for a single or collective SEPA money transfer order request
 * @export
 * @interface RequestSepaMoneyTransferParams
 */
export interface RequestSepaMoneyTransferParams {
  /**
   * Name of the recipient. Note: Neither finAPI nor the involved bank servers are guaranteed to validate the recipient name. Even if the recipient name does not depict the actual registered account holder of the specified recipient account, the money transfer request might still be successful. This field is optional only when you pass a clearing account as the recipient. Otherwise, this field is required.
   * @type {string}
   * @memberof RequestSepaMoneyTransferParams
   */
  recipientName?: string;
  /**
   * IBAN of the recipient\'s account. This field is optional only when you pass a clearing account as the recipient. Otherwise, this field is required.
   * @type {string}
   * @memberof RequestSepaMoneyTransferParams
   */
  recipientIban?: string;
  /**
   * BIC of the recipient\'s account. Note: This field is optional when you pass a clearing account as the recipient or if the bank connection of the account that you want to transfer money from supports the IBAN-Only money transfer. You can find this out via GET /bankConnections/<id>. If no BIC is given, finAPI will try to recognize it using the given recipientIban value (if it\'s given). And then if the result value is not empty, it will be used for the money transfer request independent of whether it is required or not (unless you pass a clearing account, in which case the value will always be ignored).
   * @type {string}
   * @memberof RequestSepaMoneyTransferParams
   */
  recipientBic?: string;
  /**
   * Identifier of a clearing account. If this field is set, then the fields \'recipientName\', \'recipientIban\' and \'recipientBic\' will be ignored and the recipient account will be the specified clearing account.
   * @type {string}
   * @memberof RequestSepaMoneyTransferParams
   */
  clearingAccountId?: string;
  /**
   * The amount to transfer. Must be a positive decimal number with at most two decimal places (e.g. 99.99)
   * @type {number}
   * @memberof RequestSepaMoneyTransferParams
   */
  amount: number;
  /**
   * The purpose of the transfer transaction
   * @type {string}
   * @memberof RequestSepaMoneyTransferParams
   */
  purpose?: string;
  /**
   * SEPA purpose code, according to ISO 20022, external codes set.
   * @type {string}
   * @memberof RequestSepaMoneyTransferParams
   */
  sepaPurposeCode?: string;
  /**
   * Identifier of the bank account that you want to transfer money from
   * @type {number}
   * @memberof RequestSepaMoneyTransferParams
   */
  accountId: number;
  /**
   * Online banking PIN. Any symbols are allowed. Max length: 170. If a PIN is stored in the bank connection, then this field may remain unset. If finAPI\'s web form is not required and the field is set though then it will always be used (even if there is some other PIN stored in the bank connection). If you want the user to enter a PIN in finAPI\'s web form even when a PIN is stored, then just set the field to any value, so that the service recognizes that you wish to use the web form flow.
   * @type {string}
   * @memberof RequestSepaMoneyTransferParams
   */
  bankingPin?: string;
  /**
   * Whether to store the PIN. If the PIN is stored, it is not required to pass the PIN again when executing SEPA orders. Default value is \'false\'. <br/><br/>NOTES:<br/> - before you set this field to true, please regard the \'pinsAreVolatile\' flag of the bank connection that the account belongs to;<br/> - this field is ignored in case when the user will need to use finAPI\'s web form. The user will be able to decide whether to store the PIN or not in the web form, depending on the \'storeSecretsAvailableInWebForm\' setting (see Client Configuration).
   * @type {boolean}
   * @memberof RequestSepaMoneyTransferParams
   */
  storeSecrets?: boolean;
  /**
   * The bank-given ID of the two-step-procedure that should be used for the order. For a list of available two-step-procedures, see the corresponding bank connection (GET /bankConnections). If this field is not set, then the bank connection\'s default two-step-procedure will be used. Note that in this case, when the bank connection has no default two-step-procedure set, then the response of the service depends on whether you need to use finAPI\'s web form or not. If you need to use the web form, the user will be prompted to select the two-step-procedure within the web form. If you don\'t need to use the web form, then the service will return an error (passing a value for this field is required in this case).
   * @type {string}
   * @memberof RequestSepaMoneyTransferParams
   */
  twoStepProcedureId?: string;
  /**
   * Execution date for the money transfer(s), in the format \'YYYY-MM-DD\'. If not specified, then the current date will be used.
   * @type {string}
   * @memberof RequestSepaMoneyTransferParams
   */
  executionDate?: string;
  /**
   * This field is only regarded when you pass multiple orders. It determines whether the orders should be processed by the bank as one collective booking (in case of \'false\'), or as single bookings (in case of \'true\'). Default value is \'false\'.
   * @type {boolean}
   * @memberof RequestSepaMoneyTransferParams
   */
  singleBooking?: boolean;
  /**
   * In case that you want to submit not just a single money transfer, but do a collective money transfer, use this field to pass a list of additional money transfer orders. The service will then pass a collective money transfer request to the bank, including both the money transfer specified on the top-level, as well as all money transfers specified in this list. The maximum count of money transfers that you can pass (in total) is 15000. Note that you should check the account\'s \'supportedOrders\' field to find out whether or not it is supporting collective money transfers.
   * @type {Array<SingleMoneyTransferRecipientData>}
   * @memberof RequestSepaMoneyTransferParams
   */
  additionalMoneyTransfers?: Array<SingleMoneyTransferRecipientData>;
  /**
   * NOTE: This field is DEPRECATED and will get removed at some point. Please refer to the \'multiStepAuthentication\' field instead.<br/><br/>Challenge response. This field should be set only when the previous attempt to request a SEPA money transfer failed with HTTP code 510, i.e. the bank sent a challenge for the user for an additional authentication. In this case, this field must contain the response to the bank\'s challenge. Please note that in case of using finAPI\'s web form you have to leave this field unset and the application will automatically recognize that the user has to input challenge response and then a web form will be shown to the user.
   * @type {string}
   * @memberof RequestSepaMoneyTransferParams
   */
  challengeResponse?: string;
  /**
   *
   * @type {MultiStepAuthenticationCallback}
   * @memberof RequestSepaMoneyTransferParams
   */
  multiStepAuthentication?: MultiStepAuthenticationCallback;
  /**
   * Whether the finAPI web form should hide transaction details when prompting the caller for the second factor. Default value is false.
   * @type {boolean}
   * @memberof RequestSepaMoneyTransferParams
   */
  hideTransactionDetailsInWebForm?: boolean;
  /**
   * Whether to store the PIN. If the PIN is stored, it is not required to pass the PIN again when executing SEPA orders. Default value is \'false\'. <br/><br/>NOTES:<br/> - before you set this field to true, please regard the \'pinsAreVolatile\' flag of the bank connection that the account belongs to;<br/> - this field is ignored in case when the user will need to use finAPI\'s web form. The user will be able to decide whether to store the PIN or not in the web form, depending on the \'storeSecretsAvailableInWebForm\' setting (see Client Configuration).<br><br>NOTE: This field is deprecated and will be removed at some point. Use \'storeSecrets\' instead.
   * @type {boolean}
   * @memberof RequestSepaMoneyTransferParams
   */
  storePin?: boolean;
}
/**
 * Container for a security position\'s data
 * @export
 * @interface Security
 */
export interface Security {
  /**
   * Identifier. Note: Whenever a security account is being updated, its security positions will be internally re-created, meaning that the identifier of a security position might change over time.
   * @type {number}
   * @memberof Security
   */
  id: number;
  /**
   * Security account identifier
   * @type {number}
   * @memberof Security
   */
  accountId: number;
  /**
   * Name
   * @type {string}
   * @memberof Security
   */
  name?: string;
  /**
   * ISIN
   * @type {string}
   * @memberof Security
   */
  isin?: string;
  /**
   * WKN
   * @type {string}
   * @memberof Security
   */
  wkn?: string;
  /**
   * Quote
   * @type {number}
   * @memberof Security
   */
  quote?: number;
  /**
   * Currency of quote
   * @type {string}
   * @memberof Security
   */
  quoteCurrency?: string;
  /**
   * Type of quote. \'PERC\' if quote is a percentage value, \'ACTU\' if quote is the actual amount
   * @type {string}
   * @memberof Security
   */
  quoteType?: SecurityQuoteTypeEnum;
  /**
   * Quote date in the format \'YYYY-MM-DD HH:MM:SS.SSS\' (german time).
   * @type {string}
   * @memberof Security
   */
  quoteDate?: string;
  /**
   * Value of quantity or nominal
   * @type {number}
   * @memberof Security
   */
  quantityNominal?: number;
  /**
   * Type of quantity or nominal value. \'UNIT\' if value is a quantity, \'FAMT\' if value is the nominal amount
   * @type {string}
   * @memberof Security
   */
  quantityNominalType?: SecurityQuantityNominalTypeEnum;
  /**
   * Market value
   * @type {number}
   * @memberof Security
   */
  marketValue?: number;
  /**
   * Currency of market value
   * @type {string}
   * @memberof Security
   */
  marketValueCurrency?: string;
  /**
   * Entry quote
   * @type {number}
   * @memberof Security
   */
  entryQuote?: number;
  /**
   * Currency of entry quote
   * @type {string}
   * @memberof Security
   */
  entryQuoteCurrency?: string;
  /**
   * Current profit or loss
   * @type {number}
   * @memberof Security
   */
  profitOrLoss?: number;
}

/**
 * @export
 * @enum {string}
 */
export enum SecurityQuoteTypeEnum {
  ACTU = "ACTU",
  PERC = "PERC"
}
/**
 * @export
 * @enum {string}
 */
export enum SecurityQuantityNominalTypeEnum {
  UNIT = "UNIT",
  FAMT = "FAMT"
}

/**
 * Container for securities resources
 * @export
 * @interface SecurityList
 */
export interface SecurityList {
  /**
   * List of securities
   * @type {Array<Security>}
   * @memberof SecurityList
   */
  securities: Array<Security>;
}
/**
 * Data for a single direct debit
 * @export
 * @interface SingleDirectDebitData
 */
export interface SingleDirectDebitData {
  /**
   * Name of the debitor. Note: Neither finAPI nor the involved bank servers are guaranteed to validate the debitor name. Even if the debitor name does not depict the actual registered account holder of the specified debitor account, the direct debit request might still be successful.
   * @type {string}
   * @memberof SingleDirectDebitData
   */
  debitorName: string;
  /**
   * IBAN of the debitor\'s account
   * @type {string}
   * @memberof SingleDirectDebitData
   */
  debitorIban: string;
  /**
   * BIC of the debitor\'s account. Note: This field is optional if - and only if - the bank connection of the account that you want to transfer money to supports the IBAN-Only direct debit. You can find this out via GET /bankConnections/<id>. If no BIC is given, finAPI will try to recognize it using the given debitorIban value (if it\'s given). And then if the result value is not empty, it will be used for the direct debit request independent of whether it is required or not.
   * @type {string}
   * @memberof SingleDirectDebitData
   */
  debitorBic?: string;
  /**
   * The amount to transfer. Must be a positive decimal number with at most two decimal places (e.g. 99.99)
   * @type {number}
   * @memberof SingleDirectDebitData
   */
  amount: number;
  /**
   * The purpose of the transfer transaction
   * @type {string}
   * @memberof SingleDirectDebitData
   */
  purpose?: string;
  /**
   * SEPA purpose code, according to ISO 20022, external codes set.
   * @type {string}
   * @memberof SingleDirectDebitData
   */
  sepaPurposeCode?: string;
  /**
   * Mandate ID that this direct debit order is based on.
   * @type {string}
   * @memberof SingleDirectDebitData
   */
  mandateId: string;
  /**
   * Date of the mandate that this direct debit order is based on, in the format \'YYYY-MM-DD\'
   * @type {string}
   * @memberof SingleDirectDebitData
   */
  mandateDate: string;
  /**
   * Creditor ID of the source account\'s holder
   * @type {string}
   * @memberof SingleDirectDebitData
   */
  creditorId?: string;
  /**
   * End-To-End ID for the transfer transaction
   * @type {string}
   * @memberof SingleDirectDebitData
   */
  endToEndId?: string;
}
/**
 * Recipient data for a single money transfer order
 * @export
 * @interface SingleMoneyTransferRecipientData
 */
export interface SingleMoneyTransferRecipientData {
  /**
   * Name of the recipient. Note: Neither finAPI nor the involved bank servers are guaranteed to validate the recipient name. Even if the recipient name does not depict the actual registered account holder of the specified recipient account, the money transfer request might still be successful. This field is optional only when you pass a clearing account as the recipient. Otherwise, this field is required.
   * @type {string}
   * @memberof SingleMoneyTransferRecipientData
   */
  recipientName?: string;
  /**
   * IBAN of the recipient\'s account. This field is optional only when you pass a clearing account as the recipient. Otherwise, this field is required.
   * @type {string}
   * @memberof SingleMoneyTransferRecipientData
   */
  recipientIban?: string;
  /**
   * BIC of the recipient\'s account. Note: This field is optional when you pass a clearing account as the recipient or if the bank connection of the account that you want to transfer money from supports the IBAN-Only money transfer. You can find this out via GET /bankConnections/<id>. If no BIC is given, finAPI will try to recognize it using the given recipientIban value (if it\'s given). And then if the result value is not empty, it will be used for the money transfer request independent of whether it is required or not (unless you pass a clearing account, in which case the value will always be ignored).
   * @type {string}
   * @memberof SingleMoneyTransferRecipientData
   */
  recipientBic?: string;
  /**
   * Identifier of a clearing account. If this field is set, then the fields \'recipientName\', \'recipientIban\' and \'recipientBic\' will be ignored and the recipient account will be the specified clearing account.
   * @type {string}
   * @memberof SingleMoneyTransferRecipientData
   */
  clearingAccountId?: string;
  /**
   * The amount to transfer. Must be a positive decimal number with at most two decimal places (e.g. 99.99)
   * @type {number}
   * @memberof SingleMoneyTransferRecipientData
   */
  amount: number;
  /**
   * The purpose of the transfer transaction
   * @type {string}
   * @memberof SingleMoneyTransferRecipientData
   */
  purpose?: string;
  /**
   * SEPA purpose code, according to ISO 20022, external codes set.
   * @type {string}
   * @memberof SingleMoneyTransferRecipientData
   */
  sepaPurposeCode?: string;
}
/**
 * Set of logical sub-transactions that a transaction should get split into
 * @export
 * @interface SplitTransactionsParams
 */
export interface SplitTransactionsParams {
  /**
   * List of sub-transactions
   * @type {Array<SubTransactionParams>}
   * @memberof SplitTransactionsParams
   */
  subTransactions: Array<SubTransactionParams>;
}
/**
 * Data of a sub-transaction
 * @export
 * @interface SubTransactionParams
 */
export interface SubTransactionParams {
  /**
   * Amount
   * @type {number}
   * @memberof SubTransactionParams
   */
  amount: number;
  /**
   * Category identifier. If not specified, the original transaction\'s category will be applied. If you explicitly want the sub-transaction to have no category, then pass this field with value \'0\' (zero).
   * @type {number}
   * @memberof SubTransactionParams
   */
  categoryId?: number;
  /**
   * Purpose. Maximum length is 2000. If not specified, the original transaction\'s value will be applied.
   * @type {string}
   * @memberof SubTransactionParams
   */
  purpose?: string;
  /**
   * Counterpart. Maximum length is 80. If not specified, the original transaction\'s value will be applied.
   * @type {string}
   * @memberof SubTransactionParams
   */
  counterpart?: string;
  /**
   * Counterpart account number. If not specified, the original transaction\'s value will be applied.
   * @type {string}
   * @memberof SubTransactionParams
   */
  counterpartAccountNumber?: string;
  /**
   * Counterpart IBAN. If not specified, the original transaction\'s value will be applied.
   * @type {string}
   * @memberof SubTransactionParams
   */
  counterpartIban?: string;
  /**
   * Counterpart BIC. If not specified, the original transaction\'s value will be applied.
   * @type {string}
   * @memberof SubTransactionParams
   */
  counterpartBic?: string;
  /**
   * Counterpart BLZ. If not specified, the original transaction\'s value will be applied.
   * @type {string}
   * @memberof SubTransactionParams
   */
  counterpartBlz?: string;
  /**
   * List of connected labels. Note that when this field is not specified, then the labels of the original transaction will NOT get applied to the sub-transaction. Instead, the sub-transaction will have no labels assigned to it.
   * @type {Array<number>}
   * @memberof SubTransactionParams
   */
  labelIds?: Array<number>;
}
/**
 * TPP Authentication group to which the bank interface belongs to
 * @export
 * @interface TppAuthenticationGroup
 */
export interface TppAuthenticationGroup {
  /**
   * TPP Authentication Group ID
   * @type {number}
   * @memberof TppAuthenticationGroup
   */
  id: number;
  /**
   * TPP Authentication Group name
   * @type {string}
   * @memberof TppAuthenticationGroup
   */
  name?: string;
}
/**
 * A container for the bank certificate\'s data
 * @export
 * @interface TppCertificate
 */
export interface TppCertificate {
  /**
   * A certificate identifier.
   * @type {number}
   * @memberof TppCertificate
   */
  id: number;
  /**
   * Type of certificate.
   * @type {string}
   * @memberof TppCertificate
   */
  certificateType: TppCertificateCertificateTypeEnum;
  /**
   * Optional label of certificate.
   * @type {string}
   * @memberof TppCertificate
   */
  label?: string;
  /**
   * Valid from date in the format \'YYYY-MM-DD\'.
   * @type {string}
   * @memberof TppCertificate
   */
  validFrom?: string;
  /**
   * Valid until date in the format \'YYYY-MM-DD\'.
   * @type {string}
   * @memberof TppCertificate
   */
  validUntil?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum TppCertificateCertificateTypeEnum {
  QWAC = "QWAC",
  QSEALC = "QSEALC"
}

/**
 * A container for the new certificate data
 * @export
 * @interface TppCertificateParams
 */
export interface TppCertificateParams {
  /**
   * A type of certificate submitted
   * @type {string}
   * @memberof TppCertificateParams
   */
  type: TppCertificateParamsTypeEnum;
  /**
   * A certificate (public key)
   * @type {string}
   * @memberof TppCertificateParams
   */
  publicKey: string;
  /**
   * A private key in PKCS #8 format. PKCS #8 private keys are typically exchanged in the PEM base64-encoded format (https://support.quovadisglobal.com/kb/a37/what-is-pem-format.aspx)</br></br>NOTE: The certificate should have one of the following headers:</br>- \'-----BEGIN PRIVATE KEY-----\'</br>- \'-----BEGIN ENCRYPTED PRIVATE KEY-----\'<br>Any other header denotes that the private key is NOT in PKCS #8 format!
   * @type {string}
   * @memberof TppCertificateParams
   */
  privateKey: string;
  /**
   * Optional passphrase for the private key
   * @type {string}
   * @memberof TppCertificateParams
   */
  passphrase?: string;
  /**
   * Optional label to certificate to identify in the list of certificates
   * @type {string}
   * @memberof TppCertificateParams
   */
  label: string;
  /**
   * Start day of the certificate\'s validity, in the format \'YYYY-MM-DD\'. Default is the passed certificate validFrom date
   * @type {string}
   * @memberof TppCertificateParams
   */
  validFromDate?: string;
  /**
   * Expiration day of the certificate\'s validity, in the format \'YYYY-MM-DD\'. Default is the passed certificate validUntil date
   * @type {string}
   * @memberof TppCertificateParams
   */
  validUntilDate?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum TppCertificateParamsTypeEnum {
  QWAC = "QWAC",
  QSEALC = "QSEALC"
}

/**
 * A container for the TPP client credentials data
 * @export
 * @interface TppCredentials
 */
export interface TppCredentials {
  /**
   * The credential identifier.
   * @type {number}
   * @memberof TppCredentials
   */
  id: number;
  /**
   * Optional label of tpp client credentials set.
   * @type {string}
   * @memberof TppCredentials
   */
  label?: string;
  /**
   * TPP Authentication Group ID
   * @type {number}
   * @memberof TppCredentials
   */
  tppAuthenticationGroupId?: number;
  /**
   * Valid from date in the format \'YYYY-MM-DD\'.
   * @type {string}
   * @memberof TppCredentials
   */
  validFrom?: string;
  /**
   * Valid until date in the format \'YYYY-MM-DD\'.
   * @type {string}
   * @memberof TppCredentials
   */
  validUntil?: string;
}
/**
 * A container for new TPP client credentials data
 * @export
 * @interface TppCredentialsParams
 */
export interface TppCredentialsParams {
  /**
   * The TPP Authentication Group Id for which the credentials can be used
   * @type {number}
   * @memberof TppCredentialsParams
   */
  tppAuthenticationGroupId: number;
  /**
   * Optional label to credentials
   * @type {string}
   * @memberof TppCredentialsParams
   */
  label: string;
  /**
   * ID of the TPP accessing the ASPSP API, as provided by the ASPSP as the result of registration
   * @type {string}
   * @memberof TppCredentialsParams
   */
  tppClientId?: string;
  /**
   * Secret of the TPP accessing the ASPSP API, as provided by the ASPSP as the result of registration
   * @type {string}
   * @memberof TppCredentialsParams
   */
  tppClientSecret?: string;
  /**
   * API Key provided by ASPSP  as the result of registration
   * @type {string}
   * @memberof TppCredentialsParams
   */
  tppApiKey?: string;
  /**
   * Credentials \"valid from\" date in the format \'YYYY-MM-DD\'. Default is today\'s date
   * @type {string}
   * @memberof TppCredentialsParams
   */
  validFromDate?: string;
  /**
   * Credentials \"valid until\" date in the format \'YYYY-MM-DD\'. Default is null which means \"indefinite\" (no limit)
   * @type {string}
   * @memberof TppCredentialsParams
   */
  validUntilDate?: string;
}
/**
 * Sample data to train categorization
 * @export
 * @interface TrainCategorizationData
 */
export interface TrainCategorizationData {
  /**
   * Set of transaction data (at most 100 transactions at once)
   * @type {Array<TrainCategorizationTransactionData>}
   * @memberof TrainCategorizationData
   */
  transactionData: Array<TrainCategorizationTransactionData>;
  /**
   * Category identifier
   * @type {number}
   * @memberof TrainCategorizationData
   */
  categoryId: number;
}
/**
 * Transaction data for categorization training
 * @export
 * @interface TrainCategorizationTransactionData
 */
export interface TrainCategorizationTransactionData {
  /**
   * Identifier of account type.<br/><br/>1 = Checking,<br/>2 = Savings,<br/>3 = CreditCard,<br/>4 = Security,<br/>5 = Loan,<br/>6 = Pocket (DEPRECATED; will not be returned for any account unless this type has explicitly been set via PATCH),<br/>7 = Membership,<br/>8 = Bausparen<br/><br/>
   * @type {number}
   * @memberof TrainCategorizationTransactionData
   */
  accountTypeId: number;
  /**
   * Amount
   * @type {number}
   * @memberof TrainCategorizationTransactionData
   */
  amount: number;
  /**
   * Purpose. Any symbols are allowed. Maximum length is 2000. Default value: null.
   * @type {string}
   * @memberof TrainCategorizationTransactionData
   */
  purpose?: string;
  /**
   * Counterpart. Any symbols are allowed. Maximum length is 80. Default value: null.
   * @type {string}
   * @memberof TrainCategorizationTransactionData
   */
  counterpart?: string;
  /**
   * Counterpart IBAN. Default value: null.
   * @type {string}
   * @memberof TrainCategorizationTransactionData
   */
  counterpartIban?: string;
  /**
   * Counterpart account number. Default value: null.
   * @type {string}
   * @memberof TrainCategorizationTransactionData
   */
  counterpartAccountNumber?: string;
  /**
   * Counterpart BLZ. Default value: null.
   * @type {string}
   * @memberof TrainCategorizationTransactionData
   */
  counterpartBlz?: string;
  /**
   * Counterpart BIC. Default value: null.
   * @type {string}
   * @memberof TrainCategorizationTransactionData
   */
  counterpartBic?: string;
  /**
   * Merchant category code (for credit card transactions only). Default value: null. NOTE: This field is currently not regarded.
   * @type {string}
   * @memberof TrainCategorizationTransactionData
   */
  mcCode?: string;
}
/**
 * Container for a transaction\'s data
 * @export
 * @interface Transaction
 */
export interface Transaction {
  /**
   * Transaction identifier
   * @type {number}
   * @memberof Transaction
   */
  id: number;
  /**
   * Parent transaction identifier
   * @type {number}
   * @memberof Transaction
   */
  parentId?: number;
  /**
   * Account identifier
   * @type {number}
   * @memberof Transaction
   */
  accountId: number;
  /**
   * Value date in the format \'YYYY-MM-DD HH:MM:SS.SSS\' (german time).
   * @type {string}
   * @memberof Transaction
   */
  valueDate: string;
  /**
   * Bank booking date in the format \'YYYY-MM-DD HH:MM:SS.SSS\' (german time).
   * @type {string}
   * @memberof Transaction
   */
  bankBookingDate: string;
  /**
   * finAPI Booking date in the format \'YYYY-MM-DD HH:MM:SS.SSS\' (german time). NOTE: In some cases, banks may deliver transactions that are booked in future, but already included in the current account balance. To keep the account balance consistent with the set of transactions, such \"future transactions\" will be imported with their finapiBookingDate set to the current date (i.e.: date of import). The finapiBookingDate will automatically get adjusted towards the bankBookingDate each time the associated bank account is updated. Example: A transaction is imported on July, 3rd, with a bank reported booking date of July, 6th. The transaction will be imported with its finapiBookingDate set to July, 3rd. Then, on July 4th, the associated account is updated. During this update, the transaction\'s finapiBookingDate will be automatically adjusted to July 4th. This adjustment of the finapiBookingDate takes place on each update until the bank account is updated on July 6th or later, in which case the transaction\'s finapiBookingDate will be adjusted to its final value, July 6th.<br/> The finapiBookingDate is the date that is used by the finAPI PFM services. E.g. when you calculate the spendings of an account for the current month, and have a transaction with finapiBookingDate in the current month but bankBookingDate at the beginning of the next month, then this transaction is included in the calculations (as the bank has this transaction\'s amount included in the current account balance as well).
   * @type {string}
   * @memberof Transaction
   */
  finapiBookingDate: string;
  /**
   * Transaction amount
   * @type {number}
   * @memberof Transaction
   */
  amount: number;
  /**
   * Transaction purpose. Maximum length: 2000
   * @type {string}
   * @memberof Transaction
   */
  purpose?: string;
  /**
   * Counterpart name. Maximum length: 80
   * @type {string}
   * @memberof Transaction
   */
  counterpartName?: string;
  /**
   * Counterpart account number
   * @type {string}
   * @memberof Transaction
   */
  counterpartAccountNumber?: string;
  /**
   * Counterpart IBAN
   * @type {string}
   * @memberof Transaction
   */
  counterpartIban?: string;
  /**
   * Counterpart BLZ
   * @type {string}
   * @memberof Transaction
   */
  counterpartBlz?: string;
  /**
   * Counterpart BIC
   * @type {string}
   * @memberof Transaction
   */
  counterpartBic?: string;
  /**
   * Counterpart Bank name
   * @type {string}
   * @memberof Transaction
   */
  counterpartBankName?: string;
  /**
   * The mandate reference of the counterpart
   * @type {string}
   * @memberof Transaction
   */
  counterpartMandateReference?: string;
  /**
   * The customer reference of the counterpart
   * @type {string}
   * @memberof Transaction
   */
  counterpartCustomerReference?: string;
  /**
   * The creditor ID of the counterpart. Exists only for SEPA direct debit transactions (\"Lastschrift\").
   * @type {string}
   * @memberof Transaction
   */
  counterpartCreditorId?: string;
  /**
   * The originator\'s identification code. Exists only for SEPA money transfer transactions (\"Überweisung\").
   * @type {string}
   * @memberof Transaction
   */
  counterpartDebitorId?: string;
  /**
   * Transaction type, according to the bank. If set, this will contain a German term that you can display to the user. Some examples of common values are: \"Lastschrift\", \"Auslands&uuml;berweisung\", \"Geb&uuml;hren\", \"Zinsen\". The maximum possible length of this field is 255 characters.
   * @type {string}
   * @memberof Transaction
   */
  type?: string;
  /**
   * ZKA business transaction code which relates to the transaction\'s type. Possible values range from 1 through 999. If no information about the ZKA type code is available, then this field will be null.
   * @type {string}
   * @memberof Transaction
   */
  typeCodeZka?: string;
  /**
   * SWIFT transaction type code. If no information about the SWIFT code is available, then this field will be null.
   * @type {string}
   * @memberof Transaction
   */
  typeCodeSwift?: string;
  /**
   * SEPA purpose code, according to ISO 20022
   * @type {string}
   * @memberof Transaction
   */
  sepaPurposeCode?: string;
  /**
   * Transaction primanota (bank side identification number)
   * @type {string}
   * @memberof Transaction
   */
  primanota?: string;
  /**
   *
   * @type {Category}
   * @memberof Transaction
   */
  category?: Category;
  /**
   * Array of assigned labels
   * @type {Array<Label>}
   * @memberof Transaction
   */
  labels?: Array<Label>;
  /**
   * While finAPI uses a well-elaborated algorithm for uniquely identifying transactions, there is still the possibility that during an account update, a transaction that was imported previously may be imported a second time as a new transaction. For example, this can happen if some transaction data changes on the bank server side. However, finAPI also includes an algorithm of identifying such \"potential duplicate\" transactions. If this field is set to true, it means that finAPI detected a similar transaction that might actually be the same. It is recommended to communicate this information to the end user, and give him an option to delete the transaction in case he confirms that it really is a duplicate.
   * @type {boolean}
   * @memberof Transaction
   */
  isPotentialDuplicate: boolean;
  /**
   * Indicating whether this transaction is an adjusting entry (\'Zwischensaldo\').<br/><br/>Adjusting entries do not originate from the bank, but are added by finAPI during an account update when the bank reported account balance does not add up to the set of transactions that finAPI receives for the account. In this case, the adjusting entry will fix the deviation between the balance and the received transactions so that both adds up again.<br/><br/>Possible causes for such deviations are:<br/>- Inconsistencies in how the bank calculates the balance, for instance when not yet booked transactions are already included in the balance, but not included in the set of transactions<br/>- Gaps in the transaction history that finAPI receives, for instance because the account has not been updated for a while and older transactions are no longer available
   * @type {boolean}
   * @memberof Transaction
   */
  isAdjustingEntry: boolean;
  /**
   * Indicating whether this transaction is \'new\' or not. Any newly imported transaction will have this flag initially set to true. How you use this field is up to your interpretation. For example, you might want to set it to false once a user has clicked on/seen the transaction. You can change this flag to \'false\' with the PATCH method.
   * @type {boolean}
   * @memberof Transaction
   */
  isNew: boolean;
  /**
   * Date of transaction import, in the format \'YYYY-MM-DD HH:MM:SS.SSS\' (german time).
   * @type {string}
   * @memberof Transaction
   */
  importDate: string;
  /**
   * Sub-transactions identifiers (if this transaction is split)
   * @type {Array<number>}
   * @memberof Transaction
   */
  children?: Array<number>;
  /**
   *
   * @type {PaypalTransactionData}
   * @memberof Transaction
   */
  paypalData?: PaypalTransactionData;
  /**
   * End-To-End reference
   * @type {string}
   * @memberof Transaction
   */
  endToEndReference?: string;
  /**
   * Compensation Amount. Sum of reimbursement of out-of-pocket expenses plus processing brokerage in case of a national return / refund debit as well as an optional interest equalisation. Exists predominantly for SEPA direct debit returns.
   * @type {number}
   * @memberof Transaction
   */
  compensationAmount?: number;
  /**
   * Original Amount of the original direct debit. Exists predominantly for SEPA direct debit returns.
   * @type {number}
   * @memberof Transaction
   */
  originalAmount?: number;
  /**
   * Payer\'s/debtor\'s reference party (in the case of a credit transfer) or payee\'s/creditor\'s reference party (in the case of a direct debit)
   * @type {string}
   * @memberof Transaction
   */
  differentDebitor?: string;
  /**
   * Payee\'s/creditor\'s reference party (in the case of a credit transfer) or payer\'s/debtor\'s reference party (in the case of a direct debit)
   * @type {string}
   * @memberof Transaction
   */
  differentCreditor?: string;
}
/**
 * Container for data of multiple transactions
 * @export
 * @interface TransactionList
 */
export interface TransactionList {
  /**
   * List of transactions
   * @type {Array<Transaction>}
   * @memberof TransactionList
   */
  transactions: Array<Transaction>;
}
/**
 * Trigger categorization parameters
 * @export
 * @interface TriggerCategorizationParams
 */
export interface TriggerCategorizationParams {
  /**
   * List of identifiers of the bank connections that you want to trigger categorization for. Leaving the list unset or empty will trigger categorization for all of the user\'s bank connections. Please note that if there are no bank connections, then the service will return with HTTP code 422.
   * @type {Array<number>}
   * @memberof TriggerCategorizationParams
   */
  bankConnectionIds?: Array<number>;
}
/**
 * Two-step-procedure for user authorization on bank-side
 * @export
 * @interface TwoStepProcedure
 */
export interface TwoStepProcedure {
  /**
   * Bank-given ID of the procedure
   * @type {string}
   * @memberof TwoStepProcedure
   */
  procedureId: string;
  /**
   * Bank-given name of the procedure
   * @type {string}
   * @memberof TwoStepProcedure
   */
  procedureName: string;
  /**
   * The challenge type of the procedure. Possible values are:<br/><br/>&bull; <code>TEXT</code> - the challenge will be a text that contains instructions for the user on how to proceed with the authorization.<br/>&bull; <code>PHOTO</code> - the challenge will contain a BASE-64 string depicting a photo (or any kind of QR-code-like data) that must be shown to the user.<br/>&bull; <code>FLICKER_CODE</code> - the challenge will contain a BASE-64 string depicting a flicker code animation that must be shown to the user.<br/><br/>Note that this challenge type information does not originate from the bank, but is determined by finAPI internally. There is no guarantee that the determined challenge type is correct. Note also that this field may not be set, meaning that finAPI could not determine the challenge type of the procedure.
   * @type {string}
   * @memberof TwoStepProcedure
   */
  procedureChallengeType?: string;
  /**
   * If \'true\', then there is no need for your client to pass back anything to finAPI to continue the authorization when using this procedure. The authorization will be dealt with directly between the user, finAPI, and the bank.
   * @type {boolean}
   * @memberof TwoStepProcedure
   */
  implicitExecute: boolean;
}
/**
 * Container for bank connection update parameters
 * @export
 * @interface UpdateBankConnectionParams
 */
export interface UpdateBankConnectionParams {
  /**
   * Bank connection identifier
   * @type {number}
   * @memberof UpdateBankConnectionParams
   */
  bankConnectionId: number;
  /**
   * NOTE: This field is deprecated and will be removed at some point. Use \'loginCredentials\' + \'interface\' instead. If any of those two fields is used, then the value of this field will be ignored.<br><br>Online banking PIN. Any symbols are allowed. Max length: 170. If a PIN is stored in the bank connection, then this field may remain unset. If finAPI\'s web form is not required and the field is set though then it will always be used (even if there is some other PIN stored in the bank connection). If you want the user to enter a PIN in finAPI\'s web form even when a PIN is stored, then just set the field to any value, so that the service recognizes that you wish to use the web form flow.
   * @type {string}
   * @memberof UpdateBankConnectionParams
   */
  bankingPin?: string;
  /**
   * NOTE: This field is deprecated and will be removed at some point. Use \'storeSecrets\' instead.<br><br>Whether to store the PIN. If the PIN is stored, it is not required to pass the PIN again when updating this bank connection or when executing orders (like money transfers). Default is false. <br/><br/>NOTES:<br/> - before you set this field to true, please regard the \'pinsAreVolatile\' flag of this connection\'s bank;<br/> - this field is ignored in case when the user will need to use finAPI\'s web form. The user will be able to decide whether to store the PIN or not in the web form, depending on the \'storeSecretsAvailableInWebForm\' setting (see Client Configuration).
   * @type {boolean}
   * @memberof UpdateBankConnectionParams
   */
  storePin?: boolean;
  /**
   * The interface to use for connecting with the bank.
   * @type {string}
   * @memberof UpdateBankConnectionParams
   */
  _interface?: UpdateBankConnectionParamsInterfaceEnum;
  /**
   * Set of login credentials. Must be passed in combination with the \'interface\' field. The labels that you pass must match with the login credential labels that the respective interface defines. finAPI will combine the given credentials with any credentials that it has stored. You can leave this field unset in case finAPI has stored all required credentials. When you must use a web form, you can also leave this field unset and the web form will take care of getting the credentials from the user. However, if you do pass credentials in that case, the web form will show only those fields that you have given.
   * @type {Array<LoginCredential>}
   * @memberof UpdateBankConnectionParams
   */
  loginCredentials?: Array<LoginCredential>;
  /**
   * Whether to store the secret login fields. If the secret fields are stored, then updates can be triggered without the involvement of the users, as long as the credentials remain valid and the bank consent has not expired. Note that bank consent will be stored regardless of the field value. Default value is false.<br/><br/>NOTES:<br/> - this field is ignored in case when the user will need to use finAPI\'s web form. The user will be able to decide whether to store the secrets or not in the web form, depending on the \'storeSecretsAvailableInWebForm\' setting (see Client Configuration).
   * @type {boolean}
   * @memberof UpdateBankConnectionParams
   */
  storeSecrets?: boolean;
  /**
   * Whether new accounts that have not yet been imported will be imported or not. Default is false. <br/><br/>NOTES:<br/>&bull; For best performance of the bank connection update, you should not enable this flag unless you really expect new accounts to be available in the connection. It is recommended to let your users tell you through your application when they want the service to look for new accounts.<br/>&bull; If you have imported a bank connection using specific <code>accountTypeIds</code> (e.g. <code>1,2</code> to import checking and saving accounts), you would import all other accounts (e.g. security accounts or credit cards) by setting <code>importNewAccounts</code> to <code>true</code>. To avoid importing account types that you are not interested in, make sure this field is undefined or set to false.
   * @type {boolean}
   * @memberof UpdateBankConnectionParams
   */
  importNewAccounts?: boolean;
  /**
   * Whether to skip the download of transactions and securities or not. If set to true, then finAPI will download just the accounts list with the accounts\' information (like account name, number, holder, etc), as well as the accounts\' balances (if possible), but skip the download of transactions and securities. Default is false.<br/><br/>NOTES:<br/>&bull; If you skip the download of transactions and securities during an import or update, you can still download them on a later update (though you might not get all positions at a later point, because the date range in which the bank servers provide this data is usually limited). However, once finAPI has downloaded the transactions or securities for the first time, you will not be able to go back to skipping the download of transactions and securities! In other words: Once you make your first request with <code>skipPositionsDownload=false</code> for a certain bank connection, you will no longer be able to make a request with <code>skipPositionsDownload=true</code> for that same bank connection.<br/>&bull; If this bank connection is updated via finAPI\'s automatic batch update, then transactions and security positions <u>will</u> be downloaded in any case!<br/>&bull; For security accounts, skipping the downloading of the securities might result in the account\'s balance also not being downloaded.<br/>
   * @type {boolean}
   * @memberof UpdateBankConnectionParams
   */
  skipPositionsDownload?: boolean;
  /**
   * Whether to load/refresh information about the bank connection owner(s) - see field \'owners\'. Default value is \'false\'. Note that owner data is NOT loaded/refreshed during finAPI\'s automatic bank connection update.
   * @type {boolean}
   * @memberof UpdateBankConnectionParams
   */
  loadOwnerData?: boolean;
  /**
   * List of accounts for which access is requested from the bank. It may only be passed if the bank interface has the DETAILED_CONSENT property set. if omitted, finAPI will use the list of existing accounts. Note that the parameter is still required if you want to import new accounts (i.e. call with importNewAccounts=true).
   * @type {Array<AccountReference>}
   * @memberof UpdateBankConnectionParams
   */
  accountReferences?: Array<AccountReference>;
  /**
   * NOTE: This field is DEPRECATED and will get removed at some point. Please refer to the \'multiStepAuthentication\' field instead.<br/><br/>Challenge response. This field should be set only when the previous attempt of update the bank connection failed with HTTP code 510, i.e. the bank sent a challenge for the user for an additional authentication. In this case, this field must contain the response to the bank\'s challenge. Note that in the context of finAPI\'s web form flow, finAPI will automatically deal with getting the challenge response from the user via the web form.
   * @type {string}
   * @memberof UpdateBankConnectionParams
   */
  challengeResponse?: string;
  /**
   *
   * @type {MultiStepAuthenticationCallback}
   * @memberof UpdateBankConnectionParams
   */
  multiStepAuthentication?: MultiStepAuthenticationCallback;
  /**
   * Must only be passed when the used interface has the property REDIRECT_APPROACH and no web form flow is used. The user will be redirected to the given URL from the bank\'s website after having entered his credentials. Must use HTTPS protocol.
   * @type {string}
   * @memberof UpdateBankConnectionParams
   */
  redirectUrl?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum UpdateBankConnectionParamsInterfaceEnum {
  FINTSSERVER = "FINTS_SERVER",
  WEBSCRAPER = "WEB_SCRAPER",
  XS2A = "XS2A"
}

/**
 * Update specific transactions parameters
 * @export
 * @interface UpdateMultipleTransactionsParams
 */
export interface UpdateMultipleTransactionsParams {
  /**
   * Whether this transactions should be flagged as \'new\' or not. Any newly imported transaction will have this flag initially set to true. How you use this field is up to your interpretation. For example, you might want to set it to false once a user has clicked on/seen the transaction.
   * @type {boolean}
   * @memberof UpdateMultipleTransactionsParams
   */
  isNew?: boolean;
  /**
   * You can set this field only to \'false\'. finAPI marks transactions as a potential duplicates  when its internal duplicate detection algorithm is signaling so. Transactions that are flagged as duplicates can be deleted by the user. To prevent the user from deleting original transactions, which might lead to incorrect balances, it is not possible to manually set this flag to \'true\'.
   * @type {boolean}
   * @memberof UpdateMultipleTransactionsParams
   */
  isPotentialDuplicate?: boolean;
  /**
   * Identifier of the new category to apply to the transaction. When updating the transaction\'s category, the category\'s fields \'id\', \'name\', \'parentId\', \'parentName\', and \'isCustom\' will all get updated. To clear the category for the transaction, the categoryId field must be passed with value 0.
   * @type {number}
   * @memberof UpdateMultipleTransactionsParams
   */
  categoryId?: number;
  /**
   * This field is only regarded when the field \'categoryId\' is set. It controls whether finAPI\'s categorization system should learn from the given categorization(s). If set to \'true\', then the user\'s categorization rules will be updated so that similar transactions will get categorized accordingly in future. If set to \'false\', then the service will simply change the category of the given transaction(s), without updating the user\'s categorization rules. The field defaults to \'true\' if not specified.
   * @type {boolean}
   * @memberof UpdateMultipleTransactionsParams
   */
  trainCategorization?: boolean;
  /**
   * Identifiers of labels to apply to the transaction. To clear transactions\' labels, pass an empty array of identifiers: \'[]\'
   * @type {Array<number>}
   * @memberof UpdateMultipleTransactionsParams
   */
  labelIds?: Array<number>;
  /**
   * A comma-separated list of transaction identifiers. If specified, then only transactions whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 100.
   * @type {Array<number>}
   * @memberof UpdateMultipleTransactionsParams
   */
  ids?: Array<number>;
  /**
   * A comma-separated list of account identifiers. If specified, then only transactions whose account\'s identifier is included in this list will be regarded.
   * @type {Array<number>}
   * @memberof UpdateMultipleTransactionsParams
   */
  accountIds?: Array<number>;
}
/**
 * Container for a status of bank connection update
 * @export
 * @interface UpdateResult
 */
export interface UpdateResult {
  /**
   * Note that \'OK\' just means that finAPI could successfully connect and log in to the bank server. However, it does not necessarily mean that all accounts could be updated successfully. For the latter, please refer to the \'status\' field of the Account resource.
   * @type {string}
   * @memberof UpdateResult
   */
  result: UpdateResultResultEnum;
  /**
   * In case the update result is not <code>OK</code>, this field may contain an error message with details about why the update failed (it is not guaranteed that a message is available though). In case the update result is <code>OK</code>, the field will always be null.
   * @type {string}
   * @memberof UpdateResult
   */
  errorMessage?: string;
  /**
   * In case the update result is not <code>OK</code>, this field contains the type of the error that occurred. BUSINESS means that the bank server responded with a non-technical error message for the user. TECHNICAL means that some internal error has occurred in finAPI or at the bank server.
   * @type {string}
   * @memberof UpdateResult
   */
  errorType?: UpdateResultErrorTypeEnum;
  /**
   * Time of the update. The value is returned in the format \'YYYY-MM-DD HH:MM:SS.SSS\' (german time).
   * @type {string}
   * @memberof UpdateResult
   */
  timestamp: string;
}

/**
 * @export
 * @enum {string}
 */
export enum UpdateResultResultEnum {
  OK = "OK",
  BANKSERVERREJECTION = "BANK_SERVER_REJECTION",
  INTERNALSERVERERROR = "INTERNAL_SERVER_ERROR"
}
/**
 * @export
 * @enum {string}
 */
export enum UpdateResultErrorTypeEnum {
  BUSINESS = "BUSINESS",
  TECHNICAL = "TECHNICAL"
}

/**
 * Update transactions parameters
 * @export
 * @interface UpdateTransactionsParams
 */
export interface UpdateTransactionsParams {
  /**
   * Whether this transactions should be flagged as \'new\' or not. Any newly imported transaction will have this flag initially set to true. How you use this field is up to your interpretation. For example, you might want to set it to false once a user has clicked on/seen the transaction.
   * @type {boolean}
   * @memberof UpdateTransactionsParams
   */
  isNew?: boolean;
  /**
   * You can set this field only to \'false\'. finAPI marks transactions as a potential duplicates  when its internal duplicate detection algorithm is signaling so. Transactions that are flagged as duplicates can be deleted by the user. To prevent the user from deleting original transactions, which might lead to incorrect balances, it is not possible to manually set this flag to \'true\'.
   * @type {boolean}
   * @memberof UpdateTransactionsParams
   */
  isPotentialDuplicate?: boolean;
  /**
   * Identifier of the new category to apply to the transaction. When updating the transaction\'s category, the category\'s fields \'id\', \'name\', \'parentId\', \'parentName\', and \'isCustom\' will all get updated. To clear the category for the transaction, the categoryId field must be passed with value 0.
   * @type {number}
   * @memberof UpdateTransactionsParams
   */
  categoryId?: number;
  /**
   * This field is only regarded when the field \'categoryId\' is set. It controls whether finAPI\'s categorization system should learn from the given categorization(s). If set to \'true\', then the user\'s categorization rules will be updated so that similar transactions will get categorized accordingly in future. If set to \'false\', then the service will simply change the category of the given transaction(s), without updating the user\'s categorization rules. The field defaults to \'true\' if not specified.
   * @type {boolean}
   * @memberof UpdateTransactionsParams
   */
  trainCategorization?: boolean;
  /**
   * Identifiers of labels to apply to the transaction. To clear transactions\' labels, pass an empty array of identifiers: \'[]\'
   * @type {Array<number>}
   * @memberof UpdateTransactionsParams
   */
  labelIds?: Array<number>;
}
/**
 * Container for a user\'s data
 * @export
 * @interface User
 */
export interface User {
  /**
   * User identifier
   * @type {string}
   * @memberof User
   */
  id: string;
  /**
   * User\'s password. Please note that some services may return a distorted password (always \'XXXXX\'). See the documentation of individual services to find out whether the password is returned as plain text or as \'XXXXX\'.
   * @type {string}
   * @memberof User
   */
  password: string;
  /**
   * User\'s email address
   * @type {string}
   * @memberof User
   */
  email?: string;
  /**
   * User\'s phone number
   * @type {string}
   * @memberof User
   */
  phone?: string;
  /**
   * Whether the user\'s bank connections will get updated in the course of finAPI\'s automatic batch update. Note that the automatic batch update will only update bank connections where all of the following applies:<br><br> - the PIN is stored in finAPI for the bank connection, and the related bank does not have volatile PINs (see the ‘pinsAreVolatile’ flag of the Bank Resource)<br> - the user has accepted the latest Terms and Conditions (this only applies to users whose mandator has PISP license or doesn\'t have a license at all)<br> - the user has allowed finAPI to use his old stored credentials (this only applies to users which had stored credentials before introducing a web form feature and whose mandator has PISP license or doesn\'t have a license at all)<br> - the previous update using the stored credentials did not fail due to the credentials being incorrect (or there was no previous update with the stored credentials)<br> - the bank that the bank connection relates to is included in the automatic batch update (please contact your Sys-Admin for details about the batch update configuration)<br> - at least one of the bank\'s supported data sources can be used by finAPI for your client (i.e.: if a bank supports only web scraping, but web scraping is disabled for your client, then bank connections of that bank will not get updated by the automatic batch update)<br><br>Also note that the automatic batch update must generally be enabled for your client in order for this field to have any effect.<br/><br/>WARNING: The automatic update will always download transactions and security positions for any account that it updates! This means that the user will no longer be able to download just the balances for his accounts once the automatic update has run (The \'skipPositionsDownload\' flag in the bankConnections/update service can no longer be set to true).
   * @type {boolean}
   * @memberof User
   */
  isAutoUpdateEnabled: boolean;
}
/**
 * User details
 * @export
 * @interface UserCreateParams
 */
export interface UserCreateParams {
  /**
   * User\'s identifier. Max length is 36 symbols. Only the following symbols are allowed: 0-9, A-Z, a-z, -, _, ., +, @. If not specified, then a unique random value will be generated.
   * @type {string}
   * @memberof UserCreateParams
   */
  id?: string;
  /**
   * User\'s password. Minimum length is 6, and maximum length is 128. If not specified, then a unique random value will be generated.
   * @type {string}
   * @memberof UserCreateParams
   */
  password?: string;
  /**
   * User\'s email address. Maximum length is 320.
   * @type {string}
   * @memberof UserCreateParams
   */
  email?: string;
  /**
   * User\'s phone number. Maximum length is 50.
   * @type {string}
   * @memberof UserCreateParams
   */
  phone?: string;
  /**
   * Whether the user\'s bank connections will get updated in the course of finAPI\'s automatic batch update. Note that the automatic batch update will only update bank connections where all of the following applies:<br><br> - the PIN is stored in finAPI for the bank connection<br> - the user has accepted the latest Terms and Conditions (this only applies to users whose mandator has PISP license or doesn\'t have a license at all)<br> - the user has allowed finAPI to use his old stored credentials (this only applies to users which had stored credentials before introducing a web form feature and whose mandator has PISP license or doesn\'t have a license at all)<br> - the previous update using the stored credentials did not fail due to the credentials being incorrect (or there was no previous update with the stored credentials)<br> - the bank that the bank connection relates to is included in the automatic batch update (please contact your Sys-Admin for details about the batch update configuration)<br><br>Also note that the automatic batch update must generally be enabled for your client in order for this field to have any effect.<br/><br/>WARNING: The automatic update will always download transactions and security positions for any account that it updates! This means that the user will no longer be able to download just the balances for his accounts once the automatic update has run (The \'skipPositionsDownload\' flag in the bankConnections/update service can no longer be set to true).<br/><br/>If not specified, then the automatic update will be disabled by default (false).
   * @type {boolean}
   * @memberof UserCreateParams
   */
  isAutoUpdateEnabled?: boolean;
}
/**
 * Container for list of identifiers of deleted users, and not deleted users (in ascending order)
 * @export
 * @interface UserIdentifiersList
 */
export interface UserIdentifiersList {
  /**
   * List of identifiers of deleted users (in ascending order)
   * @type {Array<string>}
   * @memberof UserIdentifiersList
   */
  deletedUsers: Array<string>;
  /**
   * List of identifiers of not deleted users (in ascending order)
   * @type {Array<string>}
   * @memberof UserIdentifiersList
   */
  nonDeletedUsers: Array<string>;
}
/**
 * User identifiers params
 * @export
 * @interface UserIdentifiersParams
 */
export interface UserIdentifiersParams {
  /**
   * List of user identifiers
   * @type {Array<string>}
   * @memberof UserIdentifiersParams
   */
  userIds: Array<string>;
}
/**
 * Container for user information
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
  /**
   * User\'s identifier
   * @type {string}
   * @memberof UserInfo
   */
  userId: string;
  /**
   * User\'s registration date, in the format \'YYYY-MM-DD\'
   * @type {string}
   * @memberof UserInfo
   */
  registrationDate: string;
  /**
   * User\'s deletion date, in the format \'YYYY-MM-DD\'. May be null if the user has not been deleted.
   * @type {string}
   * @memberof UserInfo
   */
  deletionDate?: string;
  /**
   * User\'s last active date, in the format \'YYYY-MM-DD\'. May be null if the user has not yet logged in.
   * @type {string}
   * @memberof UserInfo
   */
  lastActiveDate?: string;
  /**
   * Number of bank connections that currently exist for this user.
   * @type {number}
   * @memberof UserInfo
   */
  bankConnectionCount: number;
  /**
   * Latest date of when a bank connection was imported for this user, in the format \'YYYY-MM-DD\'. This field is null when there has never been a bank connection import.
   * @type {string}
   * @memberof UserInfo
   */
  latestBankConnectionImportDate?: string;
  /**
   * Latest date of when a bank connection was deleted for this user, in the format \'YYYY-MM-DD\'. This field is null when there has never been a bank connection deletion.
   * @type {string}
   * @memberof UserInfo
   */
  latestBankConnectionDeletionDate?: string;
  /**
   * Additional information about the user\'s data or activities, broken down in months. The list will by default contain an entry for each month starting with the month of when the user was registered, up to the current month. The date range may vary when you have limited it in the request. <br/><br/>Please note:<br/>&bull; this field is only set when \'includeMonthlyStats\' = true, otherwise it will be null.<br/>&bull; the list is always ordered from the latest month first, to the oldest month last.<br/>&bull; the list will never contain an entry for a month that was prior to the month of when the user was registered, or after the month of when the user was deleted, even when you have explicitly set a respective date range. This means that the list may be empty if you are requesting a date range where the user didn\'t exist yet, or didn\'t exist any longer.
   * @type {Array<MonthlyUserStats>}
   * @memberof UserInfo
   */
  monthlyStats?: Array<MonthlyUserStats>;
  /**
   * Whether the user is currently locked (for further information, see the \'maxUserLoginAttempts\' setting in your client\'s configuration). Note that deleted users will always have this field set to \'false\'.
   * @type {boolean}
   * @memberof UserInfo
   */
  isLocked?: boolean;
}
/**
 * User details
 * @export
 * @interface UserUpdateParams
 */
export interface UserUpdateParams {
  /**
   * User\'s new email address. Maximum length is 320. Pass an empty string (\"\") if you want to clear the current email address.
   * @type {string}
   * @memberof UserUpdateParams
   */
  email?: string;
  /**
   * User\'s new phone number. Maximum length is 50. Pass an empty string (\"\") if you want to clear the current phone number.
   * @type {string}
   * @memberof UserUpdateParams
   */
  phone?: string;
  /**
   * Whether the user\'s bank connections will get updated in the course of finAPI\'s automatic batch update. Note that the automatic batch update will only update bank connections where all of the following applies:<br><br> - the PIN is stored in finAPI for the bank connection<br> - the user has accepted the latest Terms and Conditions (this only applies to users whose mandator has PISP license or doesn\'t have a license at all)<br> - the user has allowed finAPI to use his old stored credentials (this only applies to users which had stored credentials before introducing a web form feature and whose mandator has PISP license or doesn\'t have a license at all)<br> - the previous update using the stored credentials did not fail due to the credentials being incorrect (or there was no previous update with the stored credentials)<br> - the bank that the bank connection relates to is included in the automatic batch update (please contact your Sys-Admin for details about the batch update configuration)<br><br>Also note that the automatic batch update must generally be enabled for your client in order for this field to have any effect.<br/><br/>WARNING: The automatic update will always download transactions and security positions for any account that it updates! This means that the user will no longer be able to download just the balances for his accounts once the automatic update has run (The \'skipPositionsDownload\' flag in the bankConnections/update service can no longer be set to true).
   * @type {boolean}
   * @memberof UserUpdateParams
   */
  isAutoUpdateEnabled?: boolean;
}
/**
 * User\'s verification status
 * @export
 * @interface VerificationStatusResource
 */
export interface VerificationStatusResource {
  /**
   * User\'s identifier
   * @type {string}
   * @memberof VerificationStatusResource
   */
  userId: string;
  /**
   * User\'s verification status
   * @type {boolean}
   * @memberof VerificationStatusResource
   */
  isUserVerified: boolean;
}
/**
 * Container for a web form\'s data
 * @export
 * @interface WebForm
 */
export interface WebForm {
  /**
   * Web form identifier, as returned in the 451 response of the REST service call that initiated the web form flow.
   * @type {number}
   * @memberof WebForm
   */
  id: number;
  /**
   * Token for the finAPI web form page, as contained in the 451 response of the REST service call that initiated the web form flow (in the \'Location\' header).
   * @type {string}
   * @memberof WebForm
   */
  token: string;
  /**
   * Status of a web form. Possible values are:<br/>&bull; NOT_YET_OPENED - the web form URL was not yet called;<br/>&bull; IN_PROGRESS - the web form has been opened but not yet submitted by the user;<br/>&bull; COMPLETED - the user has opened and submitted the web form;<br/>&bull; ABORTED - the user has opened but then aborted the web form, or the web form was aborted by the finAPI system because it has expired (this is the case when a web form is opened and then not submitted within 20 minutes)
   * @type {string}
   * @memberof WebForm
   */
  status: WebFormStatusEnum;
  /**
   * HTTP response code of the REST service call that initiated the web form flow. This field can be queried as soon as the status becomes COMPLETED or ABORTED. Note that it is still not guaranteed in this case that the field has a value, i.e. it might be null.
   * @type {number}
   * @memberof WebForm
   */
  serviceResponseCode?: number;
  /**
   * HTTP response body of the REST service call that initiated the web form flow. This field can be queried as soon as the status becomes COMPLETED or ABORTED. Note that it is still not guaranteed in this case that the field has a value, i.e. it might be null.
   * @type {string}
   * @memberof WebForm
   */
  serviceResponseBody?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum WebFormStatusEnum {
  NOTYETOPENED = "NOT_YET_OPENED",
  INPROGRESS = "IN_PROGRESS",
  COMPLETED = "COMPLETED",
  ABORTED = "ABORTED"
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * Delete a single bank account of the user that is authorized by the access_token, including its transactions and balance data. Must pass the account\'s identifier and the user\'s access_token.<br/><br/>Notes: <br/>- You cannot delete an account while the bank connection that it relates to is currently in the process of import, update, or transactions categorization. <br/>- When the last remaining account of a bank connection gets deleted, then the bank connection itself will get deleted as well! <br/>- All notification rules that are connected to the account will get adjusted so that they no longer have this account listed. Notification rules that are connected to just this account (and no other accounts) will get deleted altogether.
     * @summary Delete an account
     * @param {number} id Identifier of the account to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccount(id: number, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling deleteAccount."
        );
      }
      const localVarPath = `/api/v1/accounts/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete all accounts of the user that is authorized by the access_token, including all transactions and balance data. Must pass the user\'s access_token.<br/><br/>Notes: <br/>- Deleting all of the user\'s accounts also deletes all of his bank connections. <br/>- All notification rules that are connected to any specific accounts will get deleted as well. <br/>- If at least one of the user\'s bank connections in currently in the process of import, update, or transactions categorization, then this service will perform no action at all.
     * @summary Delete all accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllAccounts(options: any = {}): RequestArgs {
      const localVarPath = `/api/v1/accounts`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Change the name and/or the type and/or the \'isNew\' flag of a single bank account of the user that is authorized by the access_token. Must pass the account\'s identifier, the account\'s new name and/or type and/or \'isNew\' flag, and the user\'s access_token.
     * @summary Edit an account
     * @param {number} id Identifier of the account to edit
     * @param {AccountParams} [body] New account name and/or type and/or \&#39;isNew\&#39; flag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editAccount(
      id: number,
      body?: AccountParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling editAccount."
        );
      }
      const localVarPath = `/api/v1/accounts/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"AccountParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Execute a SEPA direct debit order that has been previously submitted by the use of the /requestSepaDirectDebit service.<br/><br/>Note: in case of using finAPI\'s web form flow, the web form is dealing with triggering this service itself.<br/><br/>Note that this service only works when your client has payments enabled (see client configuration).<br/><br/>DEPRECATED: This service will be removed at some point. Please refer to the \'Payments\' section of the API instead.
     * @summary Execute SEPA Direct Debit
     * @param {ExecuteSepaDirectDebitParams} body Parameters for the execution of a SEPA direct debit order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeSepaDirectDebit(
      body: ExecuteSepaDirectDebitParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling executeSepaDirectDebit."
        );
      }
      const localVarPath = `/api/v1/accounts/executeSepaDirectDebit`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"ExecuteSepaDirectDebitParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Execute a SEPA money transfer order that has been previously submitted by the use of the /requestSepaMoneyTransfer service.<br/><br/>Note: in case of using finAPI\'s web form flow, the web form is dealing with triggering this service itself.<br/><br/>Note that this service only works when your client has payments enabled (see client configuration).<br/><br/>DEPRECATED: This service will be removed at some point. Please refer to the \'Payments\' section of the API instead.
     * @summary Execute SEPA Money Transfer
     * @param {ExecuteSepaMoneyTransferParams} body Parameters for the execution of a SEPA money transfer order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeSepaMoneyTransfer(
      body: ExecuteSepaMoneyTransferParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling executeSepaMoneyTransfer."
        );
      }
      const localVarPath = `/api/v1/accounts/executeSepaMoneyTransfer`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"ExecuteSepaMoneyTransferParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a single bank account of the user that is authorized by the access_token. Must pass the account\'s identifier and the user\'s access_token.
     * @summary Get an account
     * @param {number} id Identifier of requested account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(id: number, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getAccount."
        );
      }
      const localVarPath = `/api/v1/accounts/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get bank accounts of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those bank accounts that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get and search all accounts
     * @param {Array<number>} [ids] A comma-separated list of account identifiers. If specified, then only accounts whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {string} [search] If specified, then only those accounts will be contained in the result whose \&#39;accountName\&#39;, \&#39;iban\&#39;, \&#39;accountNumber\&#39; or \&#39;subAccountNumber\&#39; contains the given search string (the matching works case-insensitive). If no accounts contain the search string in any of these fields, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the searched fields in order for an account to get included into the result.
     * @param {Array<number>} [accountTypeIds] A comma-separated list of account type ids. If specified, then only accounts that relate to the given types will be regarded. If not specified, then all accounts will be regarded. This field is deprecated and will be removed at some point, please refer to the accountTypes field instead.
     * @param {Array<string>} [accountTypes] A comma-separated list of account types. If specified, then only accounts that relate to the given types will be regarded. If not specified, then all accounts will be regarded.
     * @param {Array<number>} [bankConnectionIds] A comma-separated list of bank connection identifiers. If specified, then only accounts that relate to the given bank connections will be regarded. If not specified, then all accounts will be regarded.
     * @param {string} [minLastSuccessfulUpdate] Lower bound for a account\&#39;s last successful update date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only accounts whose \&#39;lastSuccessfulUpdate\&#39; is equal to or later than the given date will be regarded.
     * @param {string} [maxLastSuccessfulUpdate] Upper bound for a account\&#39;s last successful update date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only accounts whose \&#39;lastSuccessfulUpdate\&#39; is equal to or earlier than the given date will be regarded.
     * @param {number} [minBalance] If specified, then only accounts whose balance is equal to or greater than the given balance will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
     * @param {number} [maxBalance] If specified, then only accounts whose balance is equal to or less than the given balance will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchAllAccounts(
      ids?: Array<number>,
      search?: string,
      accountTypeIds?: Array<number>,
      accountTypes?: Array<string>,
      bankConnectionIds?: Array<number>,
      minLastSuccessfulUpdate?: string,
      maxLastSuccessfulUpdate?: string,
      minBalance?: number,
      maxBalance?: number,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/api/v1/accounts`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      if (ids) {
        localVarQueryParameter["ids"] = ids;
      }

      if (search !== undefined) {
        localVarQueryParameter["search"] = search;
      }

      if (accountTypeIds) {
        localVarQueryParameter["accountTypeIds"] = accountTypeIds;
      }

      if (accountTypes) {
        localVarQueryParameter["accountTypes"] = accountTypes;
      }

      if (bankConnectionIds) {
        localVarQueryParameter["bankConnectionIds"] = bankConnectionIds;
      }

      if (minLastSuccessfulUpdate !== undefined) {
        localVarQueryParameter[
          "minLastSuccessfulUpdate"
        ] = minLastSuccessfulUpdate;
      }

      if (maxLastSuccessfulUpdate !== undefined) {
        localVarQueryParameter[
          "maxLastSuccessfulUpdate"
        ] = maxLastSuccessfulUpdate;
      }

      if (minBalance !== undefined) {
        localVarQueryParameter["minBalance"] = minBalance;
      }

      if (maxBalance !== undefined) {
        localVarQueryParameter["maxBalance"] = maxBalance;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns the user\'s daily balances for a given period and a set of specified accounts (or all accounts, if none are specified). The daily balances are calculated by finAPI and are based on the current balances of the regarded accounts.
     * @summary Get daily balances
     * @param {Array<number>} [accountIds] A comma-separated list of (non-security) account identifiers. If no accounts are specified, all (non-security) accounts of the user are regarded.
     * @param {string} [startDate] A string in the format \&#39;YYYY-MM-DD\&#39;. Note that the requested date range [startDate..endDate] may not exceed 365 days. If startDate is not specified, it defaults to the endDate minus one month.
     * @param {string} [endDate] A string in the format \&#39;YYYY-MM-DD\&#39;. Note that the requested date range [startDate..endDate] may not exceed 365 days. If endDate is not specified, it defaults to today\&#39;s date.
     * @param {boolean} [withProjection] Whether finAPI should project the first and last actually existing balance of an account into the past and future. When passing \&#39;true\&#39;, then the result will always contain a daily balance for every day of the entire requested date range, even for days before the first actually existing balance, resp. after the last actually existing balance. Those days will have the same balance as the day of the first actual balance, resp. last actual balance, i.e. the first/last balance will be infinitely projected into the past/the future. When passing \&#39;false\&#39;, then the result will contain daily balances only from the day on where the first actual balance exists for any of the regarded accounts, and only up to the day where the last actual balance exists for any of the regarded accounts. Note that when in this case there are no actual balances within the requested date range, then an empty array will be returned. Default value for this parameter is \&#39;true\&#39;.
     * @param {number} [page] Result page that you want to retrieve.
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;date\&#39;, \&#39;balance\&#39;, \&#39;income\&#39; or \&#39;spending\&#39;. The default order for this service is \&#39;date,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: \&#39;/accounts/dailyBalances?order&#x3D;date,desc&amp;order&#x3D;balance,asc\&#39; will return daily balances ordered by \&#39;date\&#39; (descending), where items with the same \&#39;date\&#39; are ordered by \&#39;balance\&#39; (ascending). The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDailyBalances(
      accountIds?: Array<number>,
      startDate?: string,
      endDate?: string,
      withProjection?: boolean,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/api/v1/accounts/dailyBalances`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      if (accountIds) {
        localVarQueryParameter["accountIds"] = accountIds;
      }

      if (startDate !== undefined) {
        localVarQueryParameter["startDate"] = startDate;
      }

      if (endDate !== undefined) {
        localVarQueryParameter["endDate"] = endDate;
      }

      if (withProjection !== undefined) {
        localVarQueryParameter["withProjection"] = withProjection;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["perPage"] = perPage;
      }

      if (order) {
        localVarQueryParameter["order"] = order;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a list of multiple bank accounts of the user that is authorized by the access_token. Must pass the accounts\' identifiers and the user\'s access_token. Accounts whose identifiers do not exist or do not relate to the authorized user will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). WARNING: This service is deprecated and will be removed at some point. If you want to get multiple accounts, please instead use the service \'Get and search all accounts\' and pass a comma-separated list of identifiers as a parameter \'ids\'.
     * @summary Get multiple accounts
     * @param {Array<number>} ids Comma-separated list of identifiers of requested accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleAccounts(ids: Array<number>, options: any = {}): RequestArgs {
      // verify required parameter 'ids' is not null or undefined
      if (ids === null || ids === undefined) {
        throw new RequiredError(
          "ids",
          "Required parameter ids was null or undefined when calling getMultipleAccounts."
        );
      }
      const localVarPath = `/api/v1/accounts/{ids}`.replace(
        `{${"ids"}}`,
        encodeURIComponent(String(ids))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Submit a SEPA direct debit order for one or multiple direct debits. Returns an instruction from the bank server that can be displayed to the user (e.g. \"Enter TAN\"), typically in the language of the bank\'s country. The order remains valid for execution for only a couple of minutes (the exact validity period depends on the bank). For executing the order, use the /executeSepaDirectDebit service after calling this service. Note that when the order is not executed within the validity period, the bank might take note of that and - if happening too often - ultimately lock the user\'s online banking access. If there already exists a previously submitted but not yet executed SEPA order for this account (either another direct debit order, or a money transfer order), then that order will be discarded and replaced with the new order that is being created with this service call.<br/><br/>Notes:<br/>&bull; When using a two-step-procedure with flag \'implicitExecute\' = true, then this service will immediately execute the direct debit. The response will not contain any challenge message and you won\'t be required to make a subsequent call to /executeSepaDirectDebit.<br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a><br/><br/>Note that this service only works when your client has payments enabled (see client configuration).<br/><br/>DEPRECATED: This service will be removed at some point. Please refer to the \'Payments\' section of the API instead.
     * @summary Request SEPA Direct Debit
     * @param {RequestSepaDirectDebitParams} body Parameters for a SEPA direct debit request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestSepaDirectDebit(
      body: RequestSepaDirectDebitParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling requestSepaDirectDebit."
        );
      }
      const localVarPath = `/api/v1/accounts/requestSepaDirectDebit`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"RequestSepaDirectDebitParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Submit a SEPA money transfer order for either a single or a collective money transfer. Returns an instruction from the bank server that can be displayed to the user (e.g. \"Enter TAN\"), typically in the language of the bank\'s country. The order remains valid for execution for only a couple of minutes (the exact validity period depends on the bank). For executing the order, use the /executeSepaMoneyTransfer service after calling this service. Note that when the order is not executed within the validity period, the bank might take note of that and - if happening too often - ultimately lock the user\'s online banking access. If there already exists a previously submitted but not yet executed SEPA order for this account (either another money transfer order, or a direct debit order), then that order will be discarded and replaced with the new order that is being created with this service call.<br/><br/>Notes:<br/>&bull; Some banks may require a multi-step authentication, in which case the service will respond with HTTP code 510 and an error message containing a challenge for the user from the bank. You must display the challenge message to the user, and then retry the service call, passing the user\'s answer to the bank\'s challenge in the \'multiStepAuthentication.challengeResponse\' field.<br/>&bull; When using a two-step-procedure with flag \'implicitExecute\' = true, then this service will immediately execute the money transfer. The response will not contain any challenge message and you won\'t be required to make a subsequent call to /executeSepaMoneyTransfer.<br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a><br/><br/>Note that this service only works when your client has payments enabled (see client configuration).<br/><br/>DEPRECATED: This service will be removed at some point. Please refer to the \'Payments\' section of the API instead.
     * @summary Request SEPA Money Transfer
     * @param {RequestSepaMoneyTransferParams} body Parameters for a SEPA money transfer request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestSepaMoneyTransfer(
      body: RequestSepaMoneyTransferParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling requestSepaMoneyTransfer."
        );
      }
      const localVarPath = `/api/v1/accounts/requestSepaMoneyTransfer`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"RequestSepaMoneyTransferParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Delete a single bank account of the user that is authorized by the access_token, including its transactions and balance data. Must pass the account\'s identifier and the user\'s access_token.<br/><br/>Notes: <br/>- You cannot delete an account while the bank connection that it relates to is currently in the process of import, update, or transactions categorization. <br/>- When the last remaining account of a bank connection gets deleted, then the bank connection itself will get deleted as well! <br/>- All notification rules that are connected to the account will get adjusted so that they no longer have this account listed. Notification rules that are connected to just this account (and no other accounts) will get deleted altogether.
     * @summary Delete an account
     * @param {number} id Identifier of the account to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccount(
      id: number,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = AccountsApiAxiosParamCreator(
        configuration
      ).deleteAccount(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Delete all accounts of the user that is authorized by the access_token, including all transactions and balance data. Must pass the user\'s access_token.<br/><br/>Notes: <br/>- Deleting all of the user\'s accounts also deletes all of his bank connections. <br/>- All notification rules that are connected to any specific accounts will get deleted as well. <br/>- If at least one of the user\'s bank connections in currently in the process of import, update, or transactions categorization, then this service will perform no action at all.
     * @summary Delete all accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllAccounts(
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<IdentifierList> {
      const localVarAxiosArgs = AccountsApiAxiosParamCreator(
        configuration
      ).deleteAllAccounts(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Change the name and/or the type and/or the \'isNew\' flag of a single bank account of the user that is authorized by the access_token. Must pass the account\'s identifier, the account\'s new name and/or type and/or \'isNew\' flag, and the user\'s access_token.
     * @summary Edit an account
     * @param {number} id Identifier of the account to edit
     * @param {AccountParams} [body] New account name and/or type and/or \&#39;isNew\&#39; flag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editAccount(
      id: number,
      body?: AccountParams,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account> {
      const localVarAxiosArgs = AccountsApiAxiosParamCreator(
        configuration
      ).editAccount(id, body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Execute a SEPA direct debit order that has been previously submitted by the use of the /requestSepaDirectDebit service.<br/><br/>Note: in case of using finAPI\'s web form flow, the web form is dealing with triggering this service itself.<br/><br/>Note that this service only works when your client has payments enabled (see client configuration).<br/><br/>DEPRECATED: This service will be removed at some point. Please refer to the \'Payments\' section of the API instead.
     * @summary Execute SEPA Direct Debit
     * @param {ExecuteSepaDirectDebitParams} body Parameters for the execution of a SEPA direct debit order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeSepaDirectDebit(
      body: ExecuteSepaDirectDebitParams,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<PaymentExecutionResponse> {
      const localVarAxiosArgs = AccountsApiAxiosParamCreator(
        configuration
      ).executeSepaDirectDebit(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Execute a SEPA money transfer order that has been previously submitted by the use of the /requestSepaMoneyTransfer service.<br/><br/>Note: in case of using finAPI\'s web form flow, the web form is dealing with triggering this service itself.<br/><br/>Note that this service only works when your client has payments enabled (see client configuration).<br/><br/>DEPRECATED: This service will be removed at some point. Please refer to the \'Payments\' section of the API instead.
     * @summary Execute SEPA Money Transfer
     * @param {ExecuteSepaMoneyTransferParams} body Parameters for the execution of a SEPA money transfer order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeSepaMoneyTransfer(
      body: ExecuteSepaMoneyTransferParams,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<PaymentExecutionResponse> {
      const localVarAxiosArgs = AccountsApiAxiosParamCreator(
        configuration
      ).executeSepaMoneyTransfer(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get a single bank account of the user that is authorized by the access_token. Must pass the account\'s identifier and the user\'s access_token.
     * @summary Get an account
     * @param {number} id Identifier of requested account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(
      id: number,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account> {
      const localVarAxiosArgs = AccountsApiAxiosParamCreator(
        configuration
      ).getAccount(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get bank accounts of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those bank accounts that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get and search all accounts
     * @param {Array<number>} [ids] A comma-separated list of account identifiers. If specified, then only accounts whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {string} [search] If specified, then only those accounts will be contained in the result whose \&#39;accountName\&#39;, \&#39;iban\&#39;, \&#39;accountNumber\&#39; or \&#39;subAccountNumber\&#39; contains the given search string (the matching works case-insensitive). If no accounts contain the search string in any of these fields, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the searched fields in order for an account to get included into the result.
     * @param {Array<number>} [accountTypeIds] A comma-separated list of account type ids. If specified, then only accounts that relate to the given types will be regarded. If not specified, then all accounts will be regarded. This field is deprecated and will be removed at some point, please refer to the accountTypes field instead.
     * @param {Array<string>} [accountTypes] A comma-separated list of account types. If specified, then only accounts that relate to the given types will be regarded. If not specified, then all accounts will be regarded.
     * @param {Array<number>} [bankConnectionIds] A comma-separated list of bank connection identifiers. If specified, then only accounts that relate to the given bank connections will be regarded. If not specified, then all accounts will be regarded.
     * @param {string} [minLastSuccessfulUpdate] Lower bound for a account\&#39;s last successful update date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only accounts whose \&#39;lastSuccessfulUpdate\&#39; is equal to or later than the given date will be regarded.
     * @param {string} [maxLastSuccessfulUpdate] Upper bound for a account\&#39;s last successful update date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only accounts whose \&#39;lastSuccessfulUpdate\&#39; is equal to or earlier than the given date will be regarded.
     * @param {number} [minBalance] If specified, then only accounts whose balance is equal to or greater than the given balance will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
     * @param {number} [maxBalance] If specified, then only accounts whose balance is equal to or less than the given balance will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchAllAccounts(
      ids?: Array<number>,
      search?: string,
      accountTypeIds?: Array<number>,
      accountTypes?: Array<string>,
      bankConnectionIds?: Array<number>,
      minLastSuccessfulUpdate?: string,
      maxLastSuccessfulUpdate?: string,
      minBalance?: number,
      maxBalance?: number,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountList> {
      const localVarAxiosArgs = AccountsApiAxiosParamCreator(
        configuration
      ).getAndSearchAllAccounts(
        ids,
        search,
        accountTypeIds,
        accountTypes,
        bankConnectionIds,
        minLastSuccessfulUpdate,
        maxLastSuccessfulUpdate,
        minBalance,
        maxBalance,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Returns the user\'s daily balances for a given period and a set of specified accounts (or all accounts, if none are specified). The daily balances are calculated by finAPI and are based on the current balances of the regarded accounts.
     * @summary Get daily balances
     * @param {Array<number>} [accountIds] A comma-separated list of (non-security) account identifiers. If no accounts are specified, all (non-security) accounts of the user are regarded.
     * @param {string} [startDate] A string in the format \&#39;YYYY-MM-DD\&#39;. Note that the requested date range [startDate..endDate] may not exceed 365 days. If startDate is not specified, it defaults to the endDate minus one month.
     * @param {string} [endDate] A string in the format \&#39;YYYY-MM-DD\&#39;. Note that the requested date range [startDate..endDate] may not exceed 365 days. If endDate is not specified, it defaults to today\&#39;s date.
     * @param {boolean} [withProjection] Whether finAPI should project the first and last actually existing balance of an account into the past and future. When passing \&#39;true\&#39;, then the result will always contain a daily balance for every day of the entire requested date range, even for days before the first actually existing balance, resp. after the last actually existing balance. Those days will have the same balance as the day of the first actual balance, resp. last actual balance, i.e. the first/last balance will be infinitely projected into the past/the future. When passing \&#39;false\&#39;, then the result will contain daily balances only from the day on where the first actual balance exists for any of the regarded accounts, and only up to the day where the last actual balance exists for any of the regarded accounts. Note that when in this case there are no actual balances within the requested date range, then an empty array will be returned. Default value for this parameter is \&#39;true\&#39;.
     * @param {number} [page] Result page that you want to retrieve.
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;date\&#39;, \&#39;balance\&#39;, \&#39;income\&#39; or \&#39;spending\&#39;. The default order for this service is \&#39;date,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: \&#39;/accounts/dailyBalances?order&#x3D;date,desc&amp;order&#x3D;balance,asc\&#39; will return daily balances ordered by \&#39;date\&#39; (descending), where items with the same \&#39;date\&#39; are ordered by \&#39;balance\&#39; (ascending). The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDailyBalances(
      accountIds?: Array<number>,
      startDate?: string,
      endDate?: string,
      withProjection?: boolean,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<DailyBalanceList> {
      const localVarAxiosArgs = AccountsApiAxiosParamCreator(
        configuration
      ).getDailyBalances(
        accountIds,
        startDate,
        endDate,
        withProjection,
        page,
        perPage,
        order,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get a list of multiple bank accounts of the user that is authorized by the access_token. Must pass the accounts\' identifiers and the user\'s access_token. Accounts whose identifiers do not exist or do not relate to the authorized user will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). WARNING: This service is deprecated and will be removed at some point. If you want to get multiple accounts, please instead use the service \'Get and search all accounts\' and pass a comma-separated list of identifiers as a parameter \'ids\'.
     * @summary Get multiple accounts
     * @param {Array<number>} ids Comma-separated list of identifiers of requested accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleAccounts(
      ids: Array<number>,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountList> {
      const localVarAxiosArgs = AccountsApiAxiosParamCreator(
        configuration
      ).getMultipleAccounts(ids, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Submit a SEPA direct debit order for one or multiple direct debits. Returns an instruction from the bank server that can be displayed to the user (e.g. \"Enter TAN\"), typically in the language of the bank\'s country. The order remains valid for execution for only a couple of minutes (the exact validity period depends on the bank). For executing the order, use the /executeSepaDirectDebit service after calling this service. Note that when the order is not executed within the validity period, the bank might take note of that and - if happening too often - ultimately lock the user\'s online banking access. If there already exists a previously submitted but not yet executed SEPA order for this account (either another direct debit order, or a money transfer order), then that order will be discarded and replaced with the new order that is being created with this service call.<br/><br/>Notes:<br/>&bull; When using a two-step-procedure with flag \'implicitExecute\' = true, then this service will immediately execute the direct debit. The response will not contain any challenge message and you won\'t be required to make a subsequent call to /executeSepaDirectDebit.<br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a><br/><br/>Note that this service only works when your client has payments enabled (see client configuration).<br/><br/>DEPRECATED: This service will be removed at some point. Please refer to the \'Payments\' section of the API instead.
     * @summary Request SEPA Direct Debit
     * @param {RequestSepaDirectDebitParams} body Parameters for a SEPA direct debit request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestSepaDirectDebit(
      body: RequestSepaDirectDebitParams,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<DirectDebitOrderingResponse> {
      const localVarAxiosArgs = AccountsApiAxiosParamCreator(
        configuration
      ).requestSepaDirectDebit(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Submit a SEPA money transfer order for either a single or a collective money transfer. Returns an instruction from the bank server that can be displayed to the user (e.g. \"Enter TAN\"), typically in the language of the bank\'s country. The order remains valid for execution for only a couple of minutes (the exact validity period depends on the bank). For executing the order, use the /executeSepaMoneyTransfer service after calling this service. Note that when the order is not executed within the validity period, the bank might take note of that and - if happening too often - ultimately lock the user\'s online banking access. If there already exists a previously submitted but not yet executed SEPA order for this account (either another money transfer order, or a direct debit order), then that order will be discarded and replaced with the new order that is being created with this service call.<br/><br/>Notes:<br/>&bull; Some banks may require a multi-step authentication, in which case the service will respond with HTTP code 510 and an error message containing a challenge for the user from the bank. You must display the challenge message to the user, and then retry the service call, passing the user\'s answer to the bank\'s challenge in the \'multiStepAuthentication.challengeResponse\' field.<br/>&bull; When using a two-step-procedure with flag \'implicitExecute\' = true, then this service will immediately execute the money transfer. The response will not contain any challenge message and you won\'t be required to make a subsequent call to /executeSepaMoneyTransfer.<br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a><br/><br/>Note that this service only works when your client has payments enabled (see client configuration).<br/><br/>DEPRECATED: This service will be removed at some point. Please refer to the \'Payments\' section of the API instead.
     * @summary Request SEPA Money Transfer
     * @param {RequestSepaMoneyTransferParams} body Parameters for a SEPA money transfer request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestSepaMoneyTransfer(
      body: RequestSepaMoneyTransferParams,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<MoneyTransferOrderingResponse> {
      const localVarAxiosArgs = AccountsApiAxiosParamCreator(
        configuration
      ).requestSepaMoneyTransfer(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    }
  };
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Delete a single bank account of the user that is authorized by the access_token, including its transactions and balance data. Must pass the account\'s identifier and the user\'s access_token.<br/><br/>Notes: <br/>- You cannot delete an account while the bank connection that it relates to is currently in the process of import, update, or transactions categorization. <br/>- When the last remaining account of a bank connection gets deleted, then the bank connection itself will get deleted as well! <br/>- All notification rules that are connected to the account will get adjusted so that they no longer have this account listed. Notification rules that are connected to just this account (and no other accounts) will get deleted altogether.
     * @summary Delete an account
     * @param {number} id Identifier of the account to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccount(id: number, options?: any) {
      return AccountsApiFp(configuration).deleteAccount(id, options)(
        axios,
        basePath
      );
    },
    /**
     * Delete all accounts of the user that is authorized by the access_token, including all transactions and balance data. Must pass the user\'s access_token.<br/><br/>Notes: <br/>- Deleting all of the user\'s accounts also deletes all of his bank connections. <br/>- All notification rules that are connected to any specific accounts will get deleted as well. <br/>- If at least one of the user\'s bank connections in currently in the process of import, update, or transactions categorization, then this service will perform no action at all.
     * @summary Delete all accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllAccounts(options?: any) {
      return AccountsApiFp(configuration).deleteAllAccounts(options)(
        axios,
        basePath
      );
    },
    /**
     * Change the name and/or the type and/or the \'isNew\' flag of a single bank account of the user that is authorized by the access_token. Must pass the account\'s identifier, the account\'s new name and/or type and/or \'isNew\' flag, and the user\'s access_token.
     * @summary Edit an account
     * @param {number} id Identifier of the account to edit
     * @param {AccountParams} [body] New account name and/or type and/or \&#39;isNew\&#39; flag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editAccount(id: number, body?: AccountParams, options?: any) {
      return AccountsApiFp(configuration).editAccount(id, body, options)(
        axios,
        basePath
      );
    },
    /**
     * Execute a SEPA direct debit order that has been previously submitted by the use of the /requestSepaDirectDebit service.<br/><br/>Note: in case of using finAPI\'s web form flow, the web form is dealing with triggering this service itself.<br/><br/>Note that this service only works when your client has payments enabled (see client configuration).<br/><br/>DEPRECATED: This service will be removed at some point. Please refer to the \'Payments\' section of the API instead.
     * @summary Execute SEPA Direct Debit
     * @param {ExecuteSepaDirectDebitParams} body Parameters for the execution of a SEPA direct debit order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeSepaDirectDebit(body: ExecuteSepaDirectDebitParams, options?: any) {
      return AccountsApiFp(configuration).executeSepaDirectDebit(body, options)(
        axios,
        basePath
      );
    },
    /**
     * Execute a SEPA money transfer order that has been previously submitted by the use of the /requestSepaMoneyTransfer service.<br/><br/>Note: in case of using finAPI\'s web form flow, the web form is dealing with triggering this service itself.<br/><br/>Note that this service only works when your client has payments enabled (see client configuration).<br/><br/>DEPRECATED: This service will be removed at some point. Please refer to the \'Payments\' section of the API instead.
     * @summary Execute SEPA Money Transfer
     * @param {ExecuteSepaMoneyTransferParams} body Parameters for the execution of a SEPA money transfer order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executeSepaMoneyTransfer(
      body: ExecuteSepaMoneyTransferParams,
      options?: any
    ) {
      return AccountsApiFp(configuration).executeSepaMoneyTransfer(
        body,
        options
      )(axios, basePath);
    },
    /**
     * Get a single bank account of the user that is authorized by the access_token. Must pass the account\'s identifier and the user\'s access_token.
     * @summary Get an account
     * @param {number} id Identifier of requested account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccount(id: number, options?: any) {
      return AccountsApiFp(configuration).getAccount(id, options)(
        axios,
        basePath
      );
    },
    /**
     * Get bank accounts of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those bank accounts that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get and search all accounts
     * @param {Array<number>} [ids] A comma-separated list of account identifiers. If specified, then only accounts whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {string} [search] If specified, then only those accounts will be contained in the result whose \&#39;accountName\&#39;, \&#39;iban\&#39;, \&#39;accountNumber\&#39; or \&#39;subAccountNumber\&#39; contains the given search string (the matching works case-insensitive). If no accounts contain the search string in any of these fields, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the searched fields in order for an account to get included into the result.
     * @param {Array<number>} [accountTypeIds] A comma-separated list of account type ids. If specified, then only accounts that relate to the given types will be regarded. If not specified, then all accounts will be regarded. This field is deprecated and will be removed at some point, please refer to the accountTypes field instead.
     * @param {Array<string>} [accountTypes] A comma-separated list of account types. If specified, then only accounts that relate to the given types will be regarded. If not specified, then all accounts will be regarded.
     * @param {Array<number>} [bankConnectionIds] A comma-separated list of bank connection identifiers. If specified, then only accounts that relate to the given bank connections will be regarded. If not specified, then all accounts will be regarded.
     * @param {string} [minLastSuccessfulUpdate] Lower bound for a account\&#39;s last successful update date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only accounts whose \&#39;lastSuccessfulUpdate\&#39; is equal to or later than the given date will be regarded.
     * @param {string} [maxLastSuccessfulUpdate] Upper bound for a account\&#39;s last successful update date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only accounts whose \&#39;lastSuccessfulUpdate\&#39; is equal to or earlier than the given date will be regarded.
     * @param {number} [minBalance] If specified, then only accounts whose balance is equal to or greater than the given balance will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
     * @param {number} [maxBalance] If specified, then only accounts whose balance is equal to or less than the given balance will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchAllAccounts(
      ids?: Array<number>,
      search?: string,
      accountTypeIds?: Array<number>,
      accountTypes?: Array<string>,
      bankConnectionIds?: Array<number>,
      minLastSuccessfulUpdate?: string,
      maxLastSuccessfulUpdate?: string,
      minBalance?: number,
      maxBalance?: number,
      options?: any
    ) {
      return AccountsApiFp(configuration).getAndSearchAllAccounts(
        ids,
        search,
        accountTypeIds,
        accountTypes,
        bankConnectionIds,
        minLastSuccessfulUpdate,
        maxLastSuccessfulUpdate,
        minBalance,
        maxBalance,
        options
      )(axios, basePath);
    },
    /**
     * Returns the user\'s daily balances for a given period and a set of specified accounts (or all accounts, if none are specified). The daily balances are calculated by finAPI and are based on the current balances of the regarded accounts.
     * @summary Get daily balances
     * @param {Array<number>} [accountIds] A comma-separated list of (non-security) account identifiers. If no accounts are specified, all (non-security) accounts of the user are regarded.
     * @param {string} [startDate] A string in the format \&#39;YYYY-MM-DD\&#39;. Note that the requested date range [startDate..endDate] may not exceed 365 days. If startDate is not specified, it defaults to the endDate minus one month.
     * @param {string} [endDate] A string in the format \&#39;YYYY-MM-DD\&#39;. Note that the requested date range [startDate..endDate] may not exceed 365 days. If endDate is not specified, it defaults to today\&#39;s date.
     * @param {boolean} [withProjection] Whether finAPI should project the first and last actually existing balance of an account into the past and future. When passing \&#39;true\&#39;, then the result will always contain a daily balance for every day of the entire requested date range, even for days before the first actually existing balance, resp. after the last actually existing balance. Those days will have the same balance as the day of the first actual balance, resp. last actual balance, i.e. the first/last balance will be infinitely projected into the past/the future. When passing \&#39;false\&#39;, then the result will contain daily balances only from the day on where the first actual balance exists for any of the regarded accounts, and only up to the day where the last actual balance exists for any of the regarded accounts. Note that when in this case there are no actual balances within the requested date range, then an empty array will be returned. Default value for this parameter is \&#39;true\&#39;.
     * @param {number} [page] Result page that you want to retrieve.
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;date\&#39;, \&#39;balance\&#39;, \&#39;income\&#39; or \&#39;spending\&#39;. The default order for this service is \&#39;date,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: \&#39;/accounts/dailyBalances?order&#x3D;date,desc&amp;order&#x3D;balance,asc\&#39; will return daily balances ordered by \&#39;date\&#39; (descending), where items with the same \&#39;date\&#39; are ordered by \&#39;balance\&#39; (ascending). The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDailyBalances(
      accountIds?: Array<number>,
      startDate?: string,
      endDate?: string,
      withProjection?: boolean,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options?: any
    ) {
      return AccountsApiFp(configuration).getDailyBalances(
        accountIds,
        startDate,
        endDate,
        withProjection,
        page,
        perPage,
        order,
        options
      )(axios, basePath);
    },
    /**
     * Get a list of multiple bank accounts of the user that is authorized by the access_token. Must pass the accounts\' identifiers and the user\'s access_token. Accounts whose identifiers do not exist or do not relate to the authorized user will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). WARNING: This service is deprecated and will be removed at some point. If you want to get multiple accounts, please instead use the service \'Get and search all accounts\' and pass a comma-separated list of identifiers as a parameter \'ids\'.
     * @summary Get multiple accounts
     * @param {Array<number>} ids Comma-separated list of identifiers of requested accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleAccounts(ids: Array<number>, options?: any) {
      return AccountsApiFp(configuration).getMultipleAccounts(ids, options)(
        axios,
        basePath
      );
    },
    /**
     * Submit a SEPA direct debit order for one or multiple direct debits. Returns an instruction from the bank server that can be displayed to the user (e.g. \"Enter TAN\"), typically in the language of the bank\'s country. The order remains valid for execution for only a couple of minutes (the exact validity period depends on the bank). For executing the order, use the /executeSepaDirectDebit service after calling this service. Note that when the order is not executed within the validity period, the bank might take note of that and - if happening too often - ultimately lock the user\'s online banking access. If there already exists a previously submitted but not yet executed SEPA order for this account (either another direct debit order, or a money transfer order), then that order will be discarded and replaced with the new order that is being created with this service call.<br/><br/>Notes:<br/>&bull; When using a two-step-procedure with flag \'implicitExecute\' = true, then this service will immediately execute the direct debit. The response will not contain any challenge message and you won\'t be required to make a subsequent call to /executeSepaDirectDebit.<br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a><br/><br/>Note that this service only works when your client has payments enabled (see client configuration).<br/><br/>DEPRECATED: This service will be removed at some point. Please refer to the \'Payments\' section of the API instead.
     * @summary Request SEPA Direct Debit
     * @param {RequestSepaDirectDebitParams} body Parameters for a SEPA direct debit request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestSepaDirectDebit(body: RequestSepaDirectDebitParams, options?: any) {
      return AccountsApiFp(configuration).requestSepaDirectDebit(body, options)(
        axios,
        basePath
      );
    },
    /**
     * Submit a SEPA money transfer order for either a single or a collective money transfer. Returns an instruction from the bank server that can be displayed to the user (e.g. \"Enter TAN\"), typically in the language of the bank\'s country. The order remains valid for execution for only a couple of minutes (the exact validity period depends on the bank). For executing the order, use the /executeSepaMoneyTransfer service after calling this service. Note that when the order is not executed within the validity period, the bank might take note of that and - if happening too often - ultimately lock the user\'s online banking access. If there already exists a previously submitted but not yet executed SEPA order for this account (either another money transfer order, or a direct debit order), then that order will be discarded and replaced with the new order that is being created with this service call.<br/><br/>Notes:<br/>&bull; Some banks may require a multi-step authentication, in which case the service will respond with HTTP code 510 and an error message containing a challenge for the user from the bank. You must display the challenge message to the user, and then retry the service call, passing the user\'s answer to the bank\'s challenge in the \'multiStepAuthentication.challengeResponse\' field.<br/>&bull; When using a two-step-procedure with flag \'implicitExecute\' = true, then this service will immediately execute the money transfer. The response will not contain any challenge message and you won\'t be required to make a subsequent call to /executeSepaMoneyTransfer.<br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a><br/><br/>Note that this service only works when your client has payments enabled (see client configuration).<br/><br/>DEPRECATED: This service will be removed at some point. Please refer to the \'Payments\' section of the API instead.
     * @summary Request SEPA Money Transfer
     * @param {RequestSepaMoneyTransferParams} body Parameters for a SEPA money transfer request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestSepaMoneyTransfer(
      body: RequestSepaMoneyTransferParams,
      options?: any
    ) {
      return AccountsApiFp(configuration).requestSepaMoneyTransfer(
        body,
        options
      )(axios, basePath);
    }
  };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
  /**
   * Delete a single bank account of the user that is authorized by the access_token, including its transactions and balance data. Must pass the account\'s identifier and the user\'s access_token.<br/><br/>Notes: <br/>- You cannot delete an account while the bank connection that it relates to is currently in the process of import, update, or transactions categorization. <br/>- When the last remaining account of a bank connection gets deleted, then the bank connection itself will get deleted as well! <br/>- All notification rules that are connected to the account will get adjusted so that they no longer have this account listed. Notification rules that are connected to just this account (and no other accounts) will get deleted altogether.
   * @summary Delete an account
   * @param {number} id Identifier of the account to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public deleteAccount(id: number, options?: any) {
    return AccountsApiFp(this.configuration).deleteAccount(id, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Delete all accounts of the user that is authorized by the access_token, including all transactions and balance data. Must pass the user\'s access_token.<br/><br/>Notes: <br/>- Deleting all of the user\'s accounts also deletes all of his bank connections. <br/>- All notification rules that are connected to any specific accounts will get deleted as well. <br/>- If at least one of the user\'s bank connections in currently in the process of import, update, or transactions categorization, then this service will perform no action at all.
   * @summary Delete all accounts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public deleteAllAccounts(options?: any) {
    return AccountsApiFp(this.configuration).deleteAllAccounts(options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Change the name and/or the type and/or the \'isNew\' flag of a single bank account of the user that is authorized by the access_token. Must pass the account\'s identifier, the account\'s new name and/or type and/or \'isNew\' flag, and the user\'s access_token.
   * @summary Edit an account
   * @param {number} id Identifier of the account to edit
   * @param {AccountParams} [body] New account name and/or type and/or \&#39;isNew\&#39; flag
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public editAccount(id: number, body?: AccountParams, options?: any) {
    return AccountsApiFp(this.configuration).editAccount(id, body, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Execute a SEPA direct debit order that has been previously submitted by the use of the /requestSepaDirectDebit service.<br/><br/>Note: in case of using finAPI\'s web form flow, the web form is dealing with triggering this service itself.<br/><br/>Note that this service only works when your client has payments enabled (see client configuration).<br/><br/>DEPRECATED: This service will be removed at some point. Please refer to the \'Payments\' section of the API instead.
   * @summary Execute SEPA Direct Debit
   * @param {ExecuteSepaDirectDebitParams} body Parameters for the execution of a SEPA direct debit order
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public executeSepaDirectDebit(
    body: ExecuteSepaDirectDebitParams,
    options?: any
  ) {
    return AccountsApiFp(this.configuration).executeSepaDirectDebit(
      body,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Execute a SEPA money transfer order that has been previously submitted by the use of the /requestSepaMoneyTransfer service.<br/><br/>Note: in case of using finAPI\'s web form flow, the web form is dealing with triggering this service itself.<br/><br/>Note that this service only works when your client has payments enabled (see client configuration).<br/><br/>DEPRECATED: This service will be removed at some point. Please refer to the \'Payments\' section of the API instead.
   * @summary Execute SEPA Money Transfer
   * @param {ExecuteSepaMoneyTransferParams} body Parameters for the execution of a SEPA money transfer order
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public executeSepaMoneyTransfer(
    body: ExecuteSepaMoneyTransferParams,
    options?: any
  ) {
    return AccountsApiFp(this.configuration).executeSepaMoneyTransfer(
      body,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Get a single bank account of the user that is authorized by the access_token. Must pass the account\'s identifier and the user\'s access_token.
   * @summary Get an account
   * @param {number} id Identifier of requested account
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getAccount(id: number, options?: any) {
    return AccountsApiFp(this.configuration).getAccount(id, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Get bank accounts of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those bank accounts that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
   * @summary Get and search all accounts
   * @param {Array<number>} [ids] A comma-separated list of account identifiers. If specified, then only accounts whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
   * @param {string} [search] If specified, then only those accounts will be contained in the result whose \&#39;accountName\&#39;, \&#39;iban\&#39;, \&#39;accountNumber\&#39; or \&#39;subAccountNumber\&#39; contains the given search string (the matching works case-insensitive). If no accounts contain the search string in any of these fields, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the searched fields in order for an account to get included into the result.
   * @param {Array<number>} [accountTypeIds] A comma-separated list of account type ids. If specified, then only accounts that relate to the given types will be regarded. If not specified, then all accounts will be regarded. This field is deprecated and will be removed at some point, please refer to the accountTypes field instead.
   * @param {Array<string>} [accountTypes] A comma-separated list of account types. If specified, then only accounts that relate to the given types will be regarded. If not specified, then all accounts will be regarded.
   * @param {Array<number>} [bankConnectionIds] A comma-separated list of bank connection identifiers. If specified, then only accounts that relate to the given bank connections will be regarded. If not specified, then all accounts will be regarded.
   * @param {string} [minLastSuccessfulUpdate] Lower bound for a account\&#39;s last successful update date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only accounts whose \&#39;lastSuccessfulUpdate\&#39; is equal to or later than the given date will be regarded.
   * @param {string} [maxLastSuccessfulUpdate] Upper bound for a account\&#39;s last successful update date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only accounts whose \&#39;lastSuccessfulUpdate\&#39; is equal to or earlier than the given date will be regarded.
   * @param {number} [minBalance] If specified, then only accounts whose balance is equal to or greater than the given balance will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
   * @param {number} [maxBalance] If specified, then only accounts whose balance is equal to or less than the given balance will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getAndSearchAllAccounts(
    ids?: Array<number>,
    search?: string,
    accountTypeIds?: Array<number>,
    accountTypes?: Array<string>,
    bankConnectionIds?: Array<number>,
    minLastSuccessfulUpdate?: string,
    maxLastSuccessfulUpdate?: string,
    minBalance?: number,
    maxBalance?: number,
    options?: any
  ) {
    return AccountsApiFp(this.configuration).getAndSearchAllAccounts(
      ids,
      search,
      accountTypeIds,
      accountTypes,
      bankConnectionIds,
      minLastSuccessfulUpdate,
      maxLastSuccessfulUpdate,
      minBalance,
      maxBalance,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Returns the user\'s daily balances for a given period and a set of specified accounts (or all accounts, if none are specified). The daily balances are calculated by finAPI and are based on the current balances of the regarded accounts.
   * @summary Get daily balances
   * @param {Array<number>} [accountIds] A comma-separated list of (non-security) account identifiers. If no accounts are specified, all (non-security) accounts of the user are regarded.
   * @param {string} [startDate] A string in the format \&#39;YYYY-MM-DD\&#39;. Note that the requested date range [startDate..endDate] may not exceed 365 days. If startDate is not specified, it defaults to the endDate minus one month.
   * @param {string} [endDate] A string in the format \&#39;YYYY-MM-DD\&#39;. Note that the requested date range [startDate..endDate] may not exceed 365 days. If endDate is not specified, it defaults to today\&#39;s date.
   * @param {boolean} [withProjection] Whether finAPI should project the first and last actually existing balance of an account into the past and future. When passing \&#39;true\&#39;, then the result will always contain a daily balance for every day of the entire requested date range, even for days before the first actually existing balance, resp. after the last actually existing balance. Those days will have the same balance as the day of the first actual balance, resp. last actual balance, i.e. the first/last balance will be infinitely projected into the past/the future. When passing \&#39;false\&#39;, then the result will contain daily balances only from the day on where the first actual balance exists for any of the regarded accounts, and only up to the day where the last actual balance exists for any of the regarded accounts. Note that when in this case there are no actual balances within the requested date range, then an empty array will be returned. Default value for this parameter is \&#39;true\&#39;.
   * @param {number} [page] Result page that you want to retrieve.
   * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
   * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;date\&#39;, \&#39;balance\&#39;, \&#39;income\&#39; or \&#39;spending\&#39;. The default order for this service is \&#39;date,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: \&#39;/accounts/dailyBalances?order&#x3D;date,desc&amp;order&#x3D;balance,asc\&#39; will return daily balances ordered by \&#39;date\&#39; (descending), where items with the same \&#39;date\&#39; are ordered by \&#39;balance\&#39; (ascending). The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getDailyBalances(
    accountIds?: Array<number>,
    startDate?: string,
    endDate?: string,
    withProjection?: boolean,
    page?: number,
    perPage?: number,
    order?: Array<string>,
    options?: any
  ) {
    return AccountsApiFp(this.configuration).getDailyBalances(
      accountIds,
      startDate,
      endDate,
      withProjection,
      page,
      perPage,
      order,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Get a list of multiple bank accounts of the user that is authorized by the access_token. Must pass the accounts\' identifiers and the user\'s access_token. Accounts whose identifiers do not exist or do not relate to the authorized user will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). WARNING: This service is deprecated and will be removed at some point. If you want to get multiple accounts, please instead use the service \'Get and search all accounts\' and pass a comma-separated list of identifiers as a parameter \'ids\'.
   * @summary Get multiple accounts
   * @param {Array<number>} ids Comma-separated list of identifiers of requested accounts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public getMultipleAccounts(ids: Array<number>, options?: any) {
    return AccountsApiFp(this.configuration).getMultipleAccounts(ids, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Submit a SEPA direct debit order for one or multiple direct debits. Returns an instruction from the bank server that can be displayed to the user (e.g. \"Enter TAN\"), typically in the language of the bank\'s country. The order remains valid for execution for only a couple of minutes (the exact validity period depends on the bank). For executing the order, use the /executeSepaDirectDebit service after calling this service. Note that when the order is not executed within the validity period, the bank might take note of that and - if happening too often - ultimately lock the user\'s online banking access. If there already exists a previously submitted but not yet executed SEPA order for this account (either another direct debit order, or a money transfer order), then that order will be discarded and replaced with the new order that is being created with this service call.<br/><br/>Notes:<br/>&bull; When using a two-step-procedure with flag \'implicitExecute\' = true, then this service will immediately execute the direct debit. The response will not contain any challenge message and you won\'t be required to make a subsequent call to /executeSepaDirectDebit.<br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a><br/><br/>Note that this service only works when your client has payments enabled (see client configuration).<br/><br/>DEPRECATED: This service will be removed at some point. Please refer to the \'Payments\' section of the API instead.
   * @summary Request SEPA Direct Debit
   * @param {RequestSepaDirectDebitParams} body Parameters for a SEPA direct debit request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public requestSepaDirectDebit(
    body: RequestSepaDirectDebitParams,
    options?: any
  ) {
    return AccountsApiFp(this.configuration).requestSepaDirectDebit(
      body,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Submit a SEPA money transfer order for either a single or a collective money transfer. Returns an instruction from the bank server that can be displayed to the user (e.g. \"Enter TAN\"), typically in the language of the bank\'s country. The order remains valid for execution for only a couple of minutes (the exact validity period depends on the bank). For executing the order, use the /executeSepaMoneyTransfer service after calling this service. Note that when the order is not executed within the validity period, the bank might take note of that and - if happening too often - ultimately lock the user\'s online banking access. If there already exists a previously submitted but not yet executed SEPA order for this account (either another money transfer order, or a direct debit order), then that order will be discarded and replaced with the new order that is being created with this service call.<br/><br/>Notes:<br/>&bull; Some banks may require a multi-step authentication, in which case the service will respond with HTTP code 510 and an error message containing a challenge for the user from the bank. You must display the challenge message to the user, and then retry the service call, passing the user\'s answer to the bank\'s challenge in the \'multiStepAuthentication.challengeResponse\' field.<br/>&bull; When using a two-step-procedure with flag \'implicitExecute\' = true, then this service will immediately execute the money transfer. The response will not contain any challenge message and you won\'t be required to make a subsequent call to /executeSepaMoneyTransfer.<br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a><br/><br/>Note that this service only works when your client has payments enabled (see client configuration).<br/><br/>DEPRECATED: This service will be removed at some point. Please refer to the \'Payments\' section of the API instead.
   * @summary Request SEPA Money Transfer
   * @param {RequestSepaMoneyTransferParams} body Parameters for a SEPA money transfer request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountsApi
   */
  public requestSepaMoneyTransfer(
    body: RequestSepaMoneyTransferParams,
    options?: any
  ) {
    return AccountsApiFp(this.configuration).requestSepaMoneyTransfer(
      body,
      options
    )(this.axios, this.basePath);
  }
}

/**
 * AuthorizationApi - axios parameter creator
 * @export
 */
export const AuthorizationApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * finAPI implements the OAuth 2.0 Standard for authorizing applications and users within applications. OAuth uses the terminology of clients and users. A client represents an application that calls finAPI services. A service call might be in the context of a user of the client (e.g.: getting a user\'s bank connections), or outside any user context (e.g.: editing your client\'s configuration, or creating a new user for your client). In any case, every service call must be authorized by an access_token. This service can be used to get such an access_token, for either one of the client\'s users, or for the client itself. Also, this service can be used to refresh the access_token of a user that has previously requested an access_token.<br/><br/>To get a token, you must always pass a valid client identifier and client secret (=client credentials). You can get free client credentials for the sandbox <a href=\'http://www.finapi.io/jetzt-testen/\' target=\'_blank\'>here</a>. Alternatively, you can also contact us at <a href=\'mailto:support@finapi.io\'>support@finapi.io</a>.<br/><br/>The authorization process is similar for both a user within a client, and for the client itself: <br/>&bull; To authorize a client (i.e. application), use <code>grant_type=client_credentials</code><br/>&bull; To authorize a user, use <code>grant_type=password</code><br/><br/>If the given parameters are valid, the service will respond with the authorization data. <br/>Here is an example of a response when authorizing a user: <br/><pre>{    \"access_token\": \"yvMbx_TgwdYE0hgOVb8N4ZOvxOukqfjzYOGRZcJiCjQuRGkVIBfjjV3YG4zKTGiY2aPn2cQTGaQOT8uo5uo7_QOXts1s5UBSVuRHc6a8X30RrGBTyqV9h26SUHcZPNbZ\",    \"token_type\": \"bearer\",    \"refresh_token\": \"0b9KjiBVlZLz7a4HshSAIcFuscStiXT1VzT5mgNYwCQ_dWctTDsaIjedAhD1LpsOFJ7x6K8Emf8M3VOQkwNFR9FHijALYSQw2UeRwAC2MvrOKwfF1dHmOq5VEVYEaGf6\",    \"expires_in\": 3600,    \"scope\": \"all\" }</pre><br/><p>Use the returned access_token for other service calls by sending it in a \'Authorization\' header, with the word \'Bearer\' in front of the token. Like this:</p><pre>Authorization: Bearer yvMbx_TgwdYE0hgOVb8N4ZOvxOukqfjzYOGRZcJiCjQuRGkVIBfjjV3YG4zKTGiY2aPn2cQTGaQOT8uo5uo7_QOXts1s5UBSVuRHc6a8X30RrGBTyqV9h26SUHcZPNbZ</pre><p><b>WARNING</b>: Sending the access_token as a request parameter is deprecated and will probably be no longer supported in the next release of finAPI. Please always send the access_token in the request header, as shown above.</p><p>By default, the access tokens have an expiration time of one hour (however, you can change this via the service PATCH /clientConfiguration). If a token has expired, then using the token for a service call will result in a HTTP code 401. To restore access you can simply get a new token (as it is described above) or use <code>grant_type=refresh_token</code> (which works for user-related tokens only). In the latter case you just have to pass the previously received <code>refresh_token</code> for the user.</p><p>If the user that you want to authorize is not yet verified by the client (please see the \'isUserAutoVerificationEnabled\' flag in the Client Configuration), then the service will respond with HTTP code 403. If the user is locked (see \'maxUserLoginAttempts\' in the Client Configuration), the service will respond with HTTP code 423.</p><p>If the current role has no privileges to call a certain service (e.g. if a user tries to create a new user, or if a client tries to access user data outside of any user context), then the request will fail with the HTTP code 403.</p><p><b>IMPORTANT NOTES:</b><br/>&bull; Even though finAPI is not logging query parameters, it is still recommended to pass the parameters in the POST body instead of in the URL. Also, please set the Content-Type of your request to \'application/x-www-form-urlencoded\' when calling this service.<br/>&bull; You should use this service only when you actually need a new token. As long as a token exists and has not expired, the service will always return the same token for the same credentials. Calling this service repeatedly with the same credentials contradicts the idea behind the tokens in OAuth, and will have a negative impact on the performance of your application. So instead of retrieving the same tokens over and over with this service, you should cache the tokens and re-use them as long as they have not expired - or at least as long as you\'re using the same tokens repeatedly, e.g. for the time of an active user session in your application.</p>
     * @summary Get tokens
     * @param {'password' | 'client_credentials' | 'refresh_token'} grantType Determines the required type of authorization:password - authorize a user; client_credentials - authorize a client;refresh_token - refresh a user\&#39;s access_token.
     * @param {string} clientId Client identifier
     * @param {string} clientSecret Client secret
     * @param {string} [refreshToken] Refresh token. Required for grant_type&#x3D;refresh_token only.
     * @param {string} [username] User identifier. Required for grant_type&#x3D;password only.
     * @param {string} [password] User password. Required for grant_type&#x3D;password only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getToken(
      grantType: "password" | "client_credentials" | "refresh_token",
      clientId: string,
      clientSecret: string,
      refreshToken?: string,
      username?: string,
      password?: string,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'grantType' is not null or undefined
      if (grantType === null || grantType === undefined) {
        throw new RequiredError(
          "grantType",
          "Required parameter grantType was null or undefined when calling getToken."
        );
      }
      // verify required parameter 'clientId' is not null or undefined
      if (clientId === null || clientId === undefined) {
        throw new RequiredError(
          "clientId",
          "Required parameter clientId was null or undefined when calling getToken."
        );
      }
      // verify required parameter 'clientSecret' is not null or undefined
      if (clientSecret === null || clientSecret === undefined) {
        throw new RequiredError(
          "clientSecret",
          "Required parameter clientSecret was null or undefined when calling getToken."
        );
      }
      const localVarPath = `/oauth/token`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (grantType !== undefined) {
        localVarQueryParameter["grant_type"] = grantType;
      }

      if (clientId !== undefined) {
        localVarQueryParameter["client_id"] = clientId;
      }

      if (clientSecret !== undefined) {
        localVarQueryParameter["client_secret"] = clientSecret;
      }

      if (refreshToken !== undefined) {
        localVarQueryParameter["refresh_token"] = refreshToken;
      }

      if (username !== undefined) {
        localVarQueryParameter["username"] = username;
      }

      if (password !== undefined) {
        localVarQueryParameter["password"] = password;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * An additional endpoint for the OAuth 2.0 Standard, which allows clients to notify finAPI that a previously obtained refresh_token or access_token is no longer required. A successful request will invalidate the given token. The revocation of a particular token may also cause the revocation of related tokens and the underlying authorization grant. For token_type_hint=access_token finAPI will invalidate only the given access_token. For token_type_hint=refresh_token, finAPI will invalidate the refresh token and all access tokens based on the same authorization grant. If the token_type_hint is not defined, finAPI will revoke all access and refresh tokens (if applicable) that are based on the same authorization grant.<br/><br/>Note that the service responds with HTTP status code 200 both if the token has been revoked successfully, and if the client submitted an invalid token.<br/><br/>Note also that the client\'s access_token is required to authenticate the revocation.<br/><br/>Here is an example of how to revoke a user\'s refresh_token (and therefore also his access tokens):<pre>Authorization: Bearer {client_access_token} POST /oauth/revoke?token={refresh_token}&token_type_hint=refresh_token</pre>
     * @summary Revoke a token
     * @param {string} token The token that the client wants to get revoked
     * @param {'access_token' | 'refresh_token'} [tokenTypeHint] A hint about the type of the token submitted for revocation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeToken(
      token: string,
      tokenTypeHint?: "access_token" | "refresh_token",
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'token' is not null or undefined
      if (token === null || token === undefined) {
        throw new RequiredError(
          "token",
          "Required parameter token was null or undefined when calling revokeToken."
        );
      }
      const localVarPath = `/oauth/revoke`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      if (token !== undefined) {
        localVarQueryParameter["token"] = token;
      }

      if (tokenTypeHint !== undefined) {
        localVarQueryParameter["token_type_hint"] = tokenTypeHint;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * AuthorizationApi - functional programming interface
 * @export
 */
export const AuthorizationApiFp = function(configuration?: Configuration) {
  return {
    /**
     * finAPI implements the OAuth 2.0 Standard for authorizing applications and users within applications. OAuth uses the terminology of clients and users. A client represents an application that calls finAPI services. A service call might be in the context of a user of the client (e.g.: getting a user\'s bank connections), or outside any user context (e.g.: editing your client\'s configuration, or creating a new user for your client). In any case, every service call must be authorized by an access_token. This service can be used to get such an access_token, for either one of the client\'s users, or for the client itself. Also, this service can be used to refresh the access_token of a user that has previously requested an access_token.<br/><br/>To get a token, you must always pass a valid client identifier and client secret (=client credentials). You can get free client credentials for the sandbox <a href=\'http://www.finapi.io/jetzt-testen/\' target=\'_blank\'>here</a>. Alternatively, you can also contact us at <a href=\'mailto:support@finapi.io\'>support@finapi.io</a>.<br/><br/>The authorization process is similar for both a user within a client, and for the client itself: <br/>&bull; To authorize a client (i.e. application), use <code>grant_type=client_credentials</code><br/>&bull; To authorize a user, use <code>grant_type=password</code><br/><br/>If the given parameters are valid, the service will respond with the authorization data. <br/>Here is an example of a response when authorizing a user: <br/><pre>{    \"access_token\": \"yvMbx_TgwdYE0hgOVb8N4ZOvxOukqfjzYOGRZcJiCjQuRGkVIBfjjV3YG4zKTGiY2aPn2cQTGaQOT8uo5uo7_QOXts1s5UBSVuRHc6a8X30RrGBTyqV9h26SUHcZPNbZ\",    \"token_type\": \"bearer\",    \"refresh_token\": \"0b9KjiBVlZLz7a4HshSAIcFuscStiXT1VzT5mgNYwCQ_dWctTDsaIjedAhD1LpsOFJ7x6K8Emf8M3VOQkwNFR9FHijALYSQw2UeRwAC2MvrOKwfF1dHmOq5VEVYEaGf6\",    \"expires_in\": 3600,    \"scope\": \"all\" }</pre><br/><p>Use the returned access_token for other service calls by sending it in a \'Authorization\' header, with the word \'Bearer\' in front of the token. Like this:</p><pre>Authorization: Bearer yvMbx_TgwdYE0hgOVb8N4ZOvxOukqfjzYOGRZcJiCjQuRGkVIBfjjV3YG4zKTGiY2aPn2cQTGaQOT8uo5uo7_QOXts1s5UBSVuRHc6a8X30RrGBTyqV9h26SUHcZPNbZ</pre><p><b>WARNING</b>: Sending the access_token as a request parameter is deprecated and will probably be no longer supported in the next release of finAPI. Please always send the access_token in the request header, as shown above.</p><p>By default, the access tokens have an expiration time of one hour (however, you can change this via the service PATCH /clientConfiguration). If a token has expired, then using the token for a service call will result in a HTTP code 401. To restore access you can simply get a new token (as it is described above) or use <code>grant_type=refresh_token</code> (which works for user-related tokens only). In the latter case you just have to pass the previously received <code>refresh_token</code> for the user.</p><p>If the user that you want to authorize is not yet verified by the client (please see the \'isUserAutoVerificationEnabled\' flag in the Client Configuration), then the service will respond with HTTP code 403. If the user is locked (see \'maxUserLoginAttempts\' in the Client Configuration), the service will respond with HTTP code 423.</p><p>If the current role has no privileges to call a certain service (e.g. if a user tries to create a new user, or if a client tries to access user data outside of any user context), then the request will fail with the HTTP code 403.</p><p><b>IMPORTANT NOTES:</b><br/>&bull; Even though finAPI is not logging query parameters, it is still recommended to pass the parameters in the POST body instead of in the URL. Also, please set the Content-Type of your request to \'application/x-www-form-urlencoded\' when calling this service.<br/>&bull; You should use this service only when you actually need a new token. As long as a token exists and has not expired, the service will always return the same token for the same credentials. Calling this service repeatedly with the same credentials contradicts the idea behind the tokens in OAuth, and will have a negative impact on the performance of your application. So instead of retrieving the same tokens over and over with this service, you should cache the tokens and re-use them as long as they have not expired - or at least as long as you\'re using the same tokens repeatedly, e.g. for the time of an active user session in your application.</p>
     * @summary Get tokens
     * @param {'password' | 'client_credentials' | 'refresh_token'} grantType Determines the required type of authorization:password - authorize a user; client_credentials - authorize a client;refresh_token - refresh a user\&#39;s access_token.
     * @param {string} clientId Client identifier
     * @param {string} clientSecret Client secret
     * @param {string} [refreshToken] Refresh token. Required for grant_type&#x3D;refresh_token only.
     * @param {string} [username] User identifier. Required for grant_type&#x3D;password only.
     * @param {string} [password] User password. Required for grant_type&#x3D;password only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getToken(
      grantType: "password" | "client_credentials" | "refresh_token",
      clientId: string,
      clientSecret: string,
      refreshToken?: string,
      username?: string,
      password?: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken> {
      const localVarAxiosArgs = AuthorizationApiAxiosParamCreator(
        configuration
      ).getToken(
        grantType,
        clientId,
        clientSecret,
        refreshToken,
        username,
        password,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * An additional endpoint for the OAuth 2.0 Standard, which allows clients to notify finAPI that a previously obtained refresh_token or access_token is no longer required. A successful request will invalidate the given token. The revocation of a particular token may also cause the revocation of related tokens and the underlying authorization grant. For token_type_hint=access_token finAPI will invalidate only the given access_token. For token_type_hint=refresh_token, finAPI will invalidate the refresh token and all access tokens based on the same authorization grant. If the token_type_hint is not defined, finAPI will revoke all access and refresh tokens (if applicable) that are based on the same authorization grant.<br/><br/>Note that the service responds with HTTP status code 200 both if the token has been revoked successfully, and if the client submitted an invalid token.<br/><br/>Note also that the client\'s access_token is required to authenticate the revocation.<br/><br/>Here is an example of how to revoke a user\'s refresh_token (and therefore also his access tokens):<pre>Authorization: Bearer {client_access_token} POST /oauth/revoke?token={refresh_token}&token_type_hint=refresh_token</pre>
     * @summary Revoke a token
     * @param {string} token The token that the client wants to get revoked
     * @param {'access_token' | 'refresh_token'} [tokenTypeHint] A hint about the type of the token submitted for revocation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeToken(
      token: string,
      tokenTypeHint?: "access_token" | "refresh_token",
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = AuthorizationApiAxiosParamCreator(
        configuration
      ).revokeToken(token, tokenTypeHint, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    }
  };
};

/**
 * AuthorizationApi - factory interface
 * @export
 */
export const AuthorizationApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * finAPI implements the OAuth 2.0 Standard for authorizing applications and users within applications. OAuth uses the terminology of clients and users. A client represents an application that calls finAPI services. A service call might be in the context of a user of the client (e.g.: getting a user\'s bank connections), or outside any user context (e.g.: editing your client\'s configuration, or creating a new user for your client). In any case, every service call must be authorized by an access_token. This service can be used to get such an access_token, for either one of the client\'s users, or for the client itself. Also, this service can be used to refresh the access_token of a user that has previously requested an access_token.<br/><br/>To get a token, you must always pass a valid client identifier and client secret (=client credentials). You can get free client credentials for the sandbox <a href=\'http://www.finapi.io/jetzt-testen/\' target=\'_blank\'>here</a>. Alternatively, you can also contact us at <a href=\'mailto:support@finapi.io\'>support@finapi.io</a>.<br/><br/>The authorization process is similar for both a user within a client, and for the client itself: <br/>&bull; To authorize a client (i.e. application), use <code>grant_type=client_credentials</code><br/>&bull; To authorize a user, use <code>grant_type=password</code><br/><br/>If the given parameters are valid, the service will respond with the authorization data. <br/>Here is an example of a response when authorizing a user: <br/><pre>{    \"access_token\": \"yvMbx_TgwdYE0hgOVb8N4ZOvxOukqfjzYOGRZcJiCjQuRGkVIBfjjV3YG4zKTGiY2aPn2cQTGaQOT8uo5uo7_QOXts1s5UBSVuRHc6a8X30RrGBTyqV9h26SUHcZPNbZ\",    \"token_type\": \"bearer\",    \"refresh_token\": \"0b9KjiBVlZLz7a4HshSAIcFuscStiXT1VzT5mgNYwCQ_dWctTDsaIjedAhD1LpsOFJ7x6K8Emf8M3VOQkwNFR9FHijALYSQw2UeRwAC2MvrOKwfF1dHmOq5VEVYEaGf6\",    \"expires_in\": 3600,    \"scope\": \"all\" }</pre><br/><p>Use the returned access_token for other service calls by sending it in a \'Authorization\' header, with the word \'Bearer\' in front of the token. Like this:</p><pre>Authorization: Bearer yvMbx_TgwdYE0hgOVb8N4ZOvxOukqfjzYOGRZcJiCjQuRGkVIBfjjV3YG4zKTGiY2aPn2cQTGaQOT8uo5uo7_QOXts1s5UBSVuRHc6a8X30RrGBTyqV9h26SUHcZPNbZ</pre><p><b>WARNING</b>: Sending the access_token as a request parameter is deprecated and will probably be no longer supported in the next release of finAPI. Please always send the access_token in the request header, as shown above.</p><p>By default, the access tokens have an expiration time of one hour (however, you can change this via the service PATCH /clientConfiguration). If a token has expired, then using the token for a service call will result in a HTTP code 401. To restore access you can simply get a new token (as it is described above) or use <code>grant_type=refresh_token</code> (which works for user-related tokens only). In the latter case you just have to pass the previously received <code>refresh_token</code> for the user.</p><p>If the user that you want to authorize is not yet verified by the client (please see the \'isUserAutoVerificationEnabled\' flag in the Client Configuration), then the service will respond with HTTP code 403. If the user is locked (see \'maxUserLoginAttempts\' in the Client Configuration), the service will respond with HTTP code 423.</p><p>If the current role has no privileges to call a certain service (e.g. if a user tries to create a new user, or if a client tries to access user data outside of any user context), then the request will fail with the HTTP code 403.</p><p><b>IMPORTANT NOTES:</b><br/>&bull; Even though finAPI is not logging query parameters, it is still recommended to pass the parameters in the POST body instead of in the URL. Also, please set the Content-Type of your request to \'application/x-www-form-urlencoded\' when calling this service.<br/>&bull; You should use this service only when you actually need a new token. As long as a token exists and has not expired, the service will always return the same token for the same credentials. Calling this service repeatedly with the same credentials contradicts the idea behind the tokens in OAuth, and will have a negative impact on the performance of your application. So instead of retrieving the same tokens over and over with this service, you should cache the tokens and re-use them as long as they have not expired - or at least as long as you\'re using the same tokens repeatedly, e.g. for the time of an active user session in your application.</p>
     * @summary Get tokens
     * @param {'password' | 'client_credentials' | 'refresh_token'} grantType Determines the required type of authorization:password - authorize a user; client_credentials - authorize a client;refresh_token - refresh a user\&#39;s access_token.
     * @param {string} clientId Client identifier
     * @param {string} clientSecret Client secret
     * @param {string} [refreshToken] Refresh token. Required for grant_type&#x3D;refresh_token only.
     * @param {string} [username] User identifier. Required for grant_type&#x3D;password only.
     * @param {string} [password] User password. Required for grant_type&#x3D;password only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getToken(
      grantType: "password" | "client_credentials" | "refresh_token",
      clientId: string,
      clientSecret: string,
      refreshToken?: string,
      username?: string,
      password?: string,
      options?: any
    ) {
      return AuthorizationApiFp(configuration).getToken(
        grantType,
        clientId,
        clientSecret,
        refreshToken,
        username,
        password,
        options
      )(axios, basePath);
    },
    /**
     * An additional endpoint for the OAuth 2.0 Standard, which allows clients to notify finAPI that a previously obtained refresh_token or access_token is no longer required. A successful request will invalidate the given token. The revocation of a particular token may also cause the revocation of related tokens and the underlying authorization grant. For token_type_hint=access_token finAPI will invalidate only the given access_token. For token_type_hint=refresh_token, finAPI will invalidate the refresh token and all access tokens based on the same authorization grant. If the token_type_hint is not defined, finAPI will revoke all access and refresh tokens (if applicable) that are based on the same authorization grant.<br/><br/>Note that the service responds with HTTP status code 200 both if the token has been revoked successfully, and if the client submitted an invalid token.<br/><br/>Note also that the client\'s access_token is required to authenticate the revocation.<br/><br/>Here is an example of how to revoke a user\'s refresh_token (and therefore also his access tokens):<pre>Authorization: Bearer {client_access_token} POST /oauth/revoke?token={refresh_token}&token_type_hint=refresh_token</pre>
     * @summary Revoke a token
     * @param {string} token The token that the client wants to get revoked
     * @param {'access_token' | 'refresh_token'} [tokenTypeHint] A hint about the type of the token submitted for revocation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeToken(
      token: string,
      tokenTypeHint?: "access_token" | "refresh_token",
      options?: any
    ) {
      return AuthorizationApiFp(configuration).revokeToken(
        token,
        tokenTypeHint,
        options
      )(axios, basePath);
    }
  };
};

/**
 * AuthorizationApi - object-oriented interface
 * @export
 * @class AuthorizationApi
 * @extends {BaseAPI}
 */
export class AuthorizationApi extends BaseAPI {
  /**
   * finAPI implements the OAuth 2.0 Standard for authorizing applications and users within applications. OAuth uses the terminology of clients and users. A client represents an application that calls finAPI services. A service call might be in the context of a user of the client (e.g.: getting a user\'s bank connections), or outside any user context (e.g.: editing your client\'s configuration, or creating a new user for your client). In any case, every service call must be authorized by an access_token. This service can be used to get such an access_token, for either one of the client\'s users, or for the client itself. Also, this service can be used to refresh the access_token of a user that has previously requested an access_token.<br/><br/>To get a token, you must always pass a valid client identifier and client secret (=client credentials). You can get free client credentials for the sandbox <a href=\'http://www.finapi.io/jetzt-testen/\' target=\'_blank\'>here</a>. Alternatively, you can also contact us at <a href=\'mailto:support@finapi.io\'>support@finapi.io</a>.<br/><br/>The authorization process is similar for both a user within a client, and for the client itself: <br/>&bull; To authorize a client (i.e. application), use <code>grant_type=client_credentials</code><br/>&bull; To authorize a user, use <code>grant_type=password</code><br/><br/>If the given parameters are valid, the service will respond with the authorization data. <br/>Here is an example of a response when authorizing a user: <br/><pre>{    \"access_token\": \"yvMbx_TgwdYE0hgOVb8N4ZOvxOukqfjzYOGRZcJiCjQuRGkVIBfjjV3YG4zKTGiY2aPn2cQTGaQOT8uo5uo7_QOXts1s5UBSVuRHc6a8X30RrGBTyqV9h26SUHcZPNbZ\",    \"token_type\": \"bearer\",    \"refresh_token\": \"0b9KjiBVlZLz7a4HshSAIcFuscStiXT1VzT5mgNYwCQ_dWctTDsaIjedAhD1LpsOFJ7x6K8Emf8M3VOQkwNFR9FHijALYSQw2UeRwAC2MvrOKwfF1dHmOq5VEVYEaGf6\",    \"expires_in\": 3600,    \"scope\": \"all\" }</pre><br/><p>Use the returned access_token for other service calls by sending it in a \'Authorization\' header, with the word \'Bearer\' in front of the token. Like this:</p><pre>Authorization: Bearer yvMbx_TgwdYE0hgOVb8N4ZOvxOukqfjzYOGRZcJiCjQuRGkVIBfjjV3YG4zKTGiY2aPn2cQTGaQOT8uo5uo7_QOXts1s5UBSVuRHc6a8X30RrGBTyqV9h26SUHcZPNbZ</pre><p><b>WARNING</b>: Sending the access_token as a request parameter is deprecated and will probably be no longer supported in the next release of finAPI. Please always send the access_token in the request header, as shown above.</p><p>By default, the access tokens have an expiration time of one hour (however, you can change this via the service PATCH /clientConfiguration). If a token has expired, then using the token for a service call will result in a HTTP code 401. To restore access you can simply get a new token (as it is described above) or use <code>grant_type=refresh_token</code> (which works for user-related tokens only). In the latter case you just have to pass the previously received <code>refresh_token</code> for the user.</p><p>If the user that you want to authorize is not yet verified by the client (please see the \'isUserAutoVerificationEnabled\' flag in the Client Configuration), then the service will respond with HTTP code 403. If the user is locked (see \'maxUserLoginAttempts\' in the Client Configuration), the service will respond with HTTP code 423.</p><p>If the current role has no privileges to call a certain service (e.g. if a user tries to create a new user, or if a client tries to access user data outside of any user context), then the request will fail with the HTTP code 403.</p><p><b>IMPORTANT NOTES:</b><br/>&bull; Even though finAPI is not logging query parameters, it is still recommended to pass the parameters in the POST body instead of in the URL. Also, please set the Content-Type of your request to \'application/x-www-form-urlencoded\' when calling this service.<br/>&bull; You should use this service only when you actually need a new token. As long as a token exists and has not expired, the service will always return the same token for the same credentials. Calling this service repeatedly with the same credentials contradicts the idea behind the tokens in OAuth, and will have a negative impact on the performance of your application. So instead of retrieving the same tokens over and over with this service, you should cache the tokens and re-use them as long as they have not expired - or at least as long as you\'re using the same tokens repeatedly, e.g. for the time of an active user session in your application.</p>
   * @summary Get tokens
   * @param {'password' | 'client_credentials' | 'refresh_token'} grantType Determines the required type of authorization:password - authorize a user; client_credentials - authorize a client;refresh_token - refresh a user\&#39;s access_token.
   * @param {string} clientId Client identifier
   * @param {string} clientSecret Client secret
   * @param {string} [refreshToken] Refresh token. Required for grant_type&#x3D;refresh_token only.
   * @param {string} [username] User identifier. Required for grant_type&#x3D;password only.
   * @param {string} [password] User password. Required for grant_type&#x3D;password only.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthorizationApi
   */
  public getToken(
    grantType: "password" | "client_credentials" | "refresh_token",
    clientId: string,
    clientSecret: string,
    refreshToken?: string,
    username?: string,
    password?: string,
    options?: any
  ) {
    return AuthorizationApiFp(this.configuration).getToken(
      grantType,
      clientId,
      clientSecret,
      refreshToken,
      username,
      password,
      options
    )(this.axios, this.basePath);
  }

  /**
   * An additional endpoint for the OAuth 2.0 Standard, which allows clients to notify finAPI that a previously obtained refresh_token or access_token is no longer required. A successful request will invalidate the given token. The revocation of a particular token may also cause the revocation of related tokens and the underlying authorization grant. For token_type_hint=access_token finAPI will invalidate only the given access_token. For token_type_hint=refresh_token, finAPI will invalidate the refresh token and all access tokens based on the same authorization grant. If the token_type_hint is not defined, finAPI will revoke all access and refresh tokens (if applicable) that are based on the same authorization grant.<br/><br/>Note that the service responds with HTTP status code 200 both if the token has been revoked successfully, and if the client submitted an invalid token.<br/><br/>Note also that the client\'s access_token is required to authenticate the revocation.<br/><br/>Here is an example of how to revoke a user\'s refresh_token (and therefore also his access tokens):<pre>Authorization: Bearer {client_access_token} POST /oauth/revoke?token={refresh_token}&token_type_hint=refresh_token</pre>
   * @summary Revoke a token
   * @param {string} token The token that the client wants to get revoked
   * @param {'access_token' | 'refresh_token'} [tokenTypeHint] A hint about the type of the token submitted for revocation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthorizationApi
   */
  public revokeToken(
    token: string,
    tokenTypeHint?: "access_token" | "refresh_token",
    options?: any
  ) {
    return AuthorizationApiFp(this.configuration).revokeToken(
      token,
      tokenTypeHint,
      options
    )(this.axios, this.basePath);
  }
}

/**
 * BankConnectionsApi - axios parameter creator
 * @export
 */
export const BankConnectionsApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * Connects new interface to an existing bank connection for a specific user. Must pass the connection credentials and the user\'s access_token. All bank accounts will be downloaded and imported with their current balances, transactions and supported two-step-procedures (note that the amount of available transactions may vary between banks, e.g. some banks deliver all transactions from the past year, others only deliver the transactions from the past three months). The balance and transactions download process runs asynchronously, so this service may return before all balances and transactions have been imported. Also, all downloaded transactions will be categorized by a separate background process that runs asynchronously too. To check the status of the balance and transactions download process as well as the background categorization process, see the status flags that are returned by the GET /bankConnections/<id> service.<br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a>
     * @summary Connect a new interface
     * @param {ConnectInterfaceParams} body Connect interface parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    connectInterface(
      body: ConnectInterfaceParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling connectInterface."
        );
      }
      const localVarPath = `/api/v1/bankConnections/connectInterface`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"ConnectInterfaceParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete all bank connections of the user that is authorized by the access_token. Must pass the user\'s access_token.<br/><br/>Notes: <br/>- All notification rules that are connected to any specific bank connection will get deleted as well. <br/>- If at least one bank connection is busy (currently in the process of import, update, or transactions categorization), then this service will perform no action at all.
     * @summary Delete all bank connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllBankConnections(options: any = {}): RequestArgs {
      const localVarPath = `/api/v1/bankConnections`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete a single bank connection of the user that is authorized by the access_token, including all of its accounts and their transactions and balance data. Must pass the connection\'s identifier and the user\'s access_token.<br/><br/>Notes: <br/>- All notification rules that are connected to the bank connection will get adjusted so that they no longer have this connection listed. Notification rules that are connected to just this bank connection (and no other connection) will get deleted altogether. <br/>- A bank connection cannot get deleted while it is in the process of import, update, or transactions categorization.
     * @summary Delete a bank connection
     * @param {number} id Identifier of the bank connection to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBankConnection(id: number, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling deleteBankConnection."
        );
      }
      const localVarPath = `/api/v1/bankConnections/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Edit bank connection data. Must pass the connection\'s identifier and the user\'s access_token.<br/><br/>Note that a bank connection\'s credentials cannot be changed while it is in the process of import, update, or transactions categorization.<br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a>
     * @summary Edit a bank connection
     * @param {number} id Identifier of the bank connection to change the parameters for
     * @param {EditBankConnectionParams} body New bank connection parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editBankConnection(
      id: number,
      body: EditBankConnectionParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling editBankConnection."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling editBankConnection."
        );
      }
      const localVarPath = `/api/v1/bankConnections/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"EditBankConnectionParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get bank connections of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those bank connections that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get all bank connections
     * @param {Array<number>} [ids] A comma-separated list of bank connection identifiers. If specified, then only bank connections whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBankConnections(ids?: Array<number>, options: any = {}): RequestArgs {
      const localVarPath = `/api/v1/bankConnections`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      if (ids) {
        localVarQueryParameter["ids"] = ids;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a single bank connection of the user that is authorized by the access_token. Must pass the connection\'s identifier and the user\'s access_token.
     * @summary Get a bank connection
     * @param {number} id Identifier of requested bank connection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBankConnection(id: number, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getBankConnection."
        );
      }
      const localVarPath = `/api/v1/bankConnections/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a list of multiple bank connections of the user that is authorized by the access_token. Must pass the connections\' identifiers and the user\'s access_token. Connections whose identifiers do not exist or do not relate to the authorized user will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). WARNING: This service is deprecated and will be removed at some point. If you want to get multiple bank connections, please instead use the service \'Get all bank connections\' and pass a comma-separated list of identifiers as a parameter \'ids\'.
     * @summary Get multiple bank connections
     * @param {Array<number>} ids Comma-separated list of identifiers of requested bank connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleBankConnections(
      ids: Array<number>,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'ids' is not null or undefined
      if (ids === null || ids === undefined) {
        throw new RequiredError(
          "ids",
          "Required parameter ids was null or undefined when calling getMultipleBankConnections."
        );
      }
      const localVarPath = `/api/v1/bankConnections/{ids}`.replace(
        `{${"ids"}}`,
        encodeURIComponent(String(ids))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Imports a new bank connection for a specific user. Must pass the connection credentials and the user\'s access_token. All bank accounts will be downloaded and imported with their current balances, transactions and supported two-step-procedures (note that the amount of available transactions may vary between banks, e.g. some banks deliver all transactions from the past year, others only deliver the transactions from the past three months). The balance and transactions download process runs asynchronously, so this service may return before all balances and transactions have been imported. Also, all downloaded transactions will be categorized by a separate background process that runs asynchronously too. To check the status of the balance and transactions download process as well as the background categorization process, see the status flags that are returned by the GET /bankConnections/<id> service.<br/><br/>You can also import a \"demo connection\" which contains a single bank account with some pre-defined transactions. To import the demo connection, you need to pass the identifier of the \"finAPI Test Bank\". In case of demo connection import, any other fields besides the bank identifier can remain unset. The bankingUserId, bankingCustomerId, bankingPin, and storeSecrets fields will be stored if you pass them, however they will not be regarded when updating the demo connection (in other words: It doesn\'t matter what credentials you choose for the demo connection). Note however that if you want to import the demo connection multiple times for the same user, you must use a different bankingUserId and/or bankingCustomerId for each of the imports. Also note that the skipPositionsDownload flag is ignored for the demo bank connection, i.e. when importing the demo bank connection, you will always get the transactions for its account. You can enable multi-step authentication for the demo bank connection by setting the bank connection name to \"MSA\".<br/><br/>The XS2A interface could also be used to initiate a demo connection import.<br/>The finAPI demo XS2A allows you to download a test account by using the \'import\' or \'connectInterface\' services - in general, this XS2A demo account is the FINTS_SERVER demo account, as it has the same account number and origin of balances and transactions.<br/>Keep in mind, that calling an XS2A demo connection import will result as a newly created bank connection, when the \'connectInterface\' service attaches the XS2A demo account to an existing demo connection.<br/>Passing the login credentials is not obligated only for redirect banks, however the demo bank works without any given set of credentials for the XS2A interface. The old API credentials fields (bankingUserId, bankingCustomerId, bankingPin) are DEPRECATED and temporarily mapped on the new credentials data structure, allowing you to use them within the XS2A import. This is not recommended, as those fields are going to be removed at some point later.<br/>If you are looking to test the XS2A SCA (Strong Customer Authentication, or MSA (Multi-Step Authentication) in the finAPI context), you need to pass the bank connection name as \"MSA\" to trigger the SCA flow or as \'DECOUPLED-AUTH\' to simulate decoupled authentication. To get better understanding about the Multi-Step Authentication, please refer to the \'Error Messages\' section of the swagger documentation.<br/><br/><b>For a more in-depth understanding of the import process, please also read this article on our Dev Portal: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115000296607-Import-Update-of-Bank-Connections-Accounts\' target=\'_blank\'>Import & Update of Bank Connections / Accounts</a></b><br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a><br/><br/><b>Attention:</b> Due to changes on the bank\'s side we have been forced to limit the maxDaysForDownload field to 89 days to reduce the risk of strong customer authentication (SCA) requests. If you have implemented the SCA flow, please contact us, so that we can remove this limitation from your client.
     * @summary Import a new bank connection
     * @param {ImportBankConnectionParams} body Import bank connection parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    importBankConnection(
      body: ImportBankConnectionParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling importBankConnection."
        );
      }
      const localVarPath = `/api/v1/bankConnections/import`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"ImportBankConnectionParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Remove an interface from bank connection and from all associated accounts in the bank connection. Notes: <br/>- An interface cannot get deleted while it is in the process of import or update.
     * @summary Remove an interface
     * @param {RemoveInterfaceParams} body Remove interface parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeInterface(
      body: RemoveInterfaceParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling removeInterface."
        );
      }
      const localVarPath = `/api/v1/bankConnections/removeInterface`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"RemoveInterfaceParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Update an existing bank connection of the user that is authorized by the access_token. Downloads and imports the current account balances and new transactions. Must pass the connection\'s identifier and the user\'s access_token. For more information about the processes of authentication, data download and transactions categorization, see POST /bankConnections/import. Note that supported two-step-procedures are updated as well. It may unset the current default two-step-procedure of the given bank connection (but only if this procedure is not supported anymore by the bank). You can also update the \"demo connection\" (in this case, the fields \'bankingPin\', \'importNewAccounts\', and \'skipPositionsDownload\' will be ignored).<br/><br/>Note that you cannot trigger an update of a bank connection as long as there is still a previously triggered update running.<br/><br/><b>For a more in-depth understanding of the update process, please also read this article on our Dev Portal: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115000296607-Import-Update-of-Bank-Connections-Accounts\' target=\'_blank\'>Import & Update of Bank Connections / Accounts</a></b><br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a><br/><br/><b>Attention:</b> Due to changes on the bank\'s side we have been forced to limit the transaction download time frame to 89 days. Now any update of a bank connection will fetch the last three months of transactions per account. If the last successful update was more than 3 months ago, an adjusting entry (\'Zwischensaldo\' transaction) will be created.
     * @summary Update a bank connection
     * @param {UpdateBankConnectionParams} body Update bank connection parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateBankConnection(
      body: UpdateBankConnectionParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling updateBankConnection."
        );
      }
      const localVarPath = `/api/v1/bankConnections/update`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"UpdateBankConnectionParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * BankConnectionsApi - functional programming interface
 * @export
 */
export const BankConnectionsApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Connects new interface to an existing bank connection for a specific user. Must pass the connection credentials and the user\'s access_token. All bank accounts will be downloaded and imported with their current balances, transactions and supported two-step-procedures (note that the amount of available transactions may vary between banks, e.g. some banks deliver all transactions from the past year, others only deliver the transactions from the past three months). The balance and transactions download process runs asynchronously, so this service may return before all balances and transactions have been imported. Also, all downloaded transactions will be categorized by a separate background process that runs asynchronously too. To check the status of the balance and transactions download process as well as the background categorization process, see the status flags that are returned by the GET /bankConnections/<id> service.<br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a>
     * @summary Connect a new interface
     * @param {ConnectInterfaceParams} body Connect interface parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    connectInterface(
      body: ConnectInterfaceParams,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<BankConnection> {
      const localVarAxiosArgs = BankConnectionsApiAxiosParamCreator(
        configuration
      ).connectInterface(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Delete all bank connections of the user that is authorized by the access_token. Must pass the user\'s access_token.<br/><br/>Notes: <br/>- All notification rules that are connected to any specific bank connection will get deleted as well. <br/>- If at least one bank connection is busy (currently in the process of import, update, or transactions categorization), then this service will perform no action at all.
     * @summary Delete all bank connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllBankConnections(
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<IdentifierList> {
      const localVarAxiosArgs = BankConnectionsApiAxiosParamCreator(
        configuration
      ).deleteAllBankConnections(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Delete a single bank connection of the user that is authorized by the access_token, including all of its accounts and their transactions and balance data. Must pass the connection\'s identifier and the user\'s access_token.<br/><br/>Notes: <br/>- All notification rules that are connected to the bank connection will get adjusted so that they no longer have this connection listed. Notification rules that are connected to just this bank connection (and no other connection) will get deleted altogether. <br/>- A bank connection cannot get deleted while it is in the process of import, update, or transactions categorization.
     * @summary Delete a bank connection
     * @param {number} id Identifier of the bank connection to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBankConnection(
      id: number,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = BankConnectionsApiAxiosParamCreator(
        configuration
      ).deleteBankConnection(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Edit bank connection data. Must pass the connection\'s identifier and the user\'s access_token.<br/><br/>Note that a bank connection\'s credentials cannot be changed while it is in the process of import, update, or transactions categorization.<br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a>
     * @summary Edit a bank connection
     * @param {number} id Identifier of the bank connection to change the parameters for
     * @param {EditBankConnectionParams} body New bank connection parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editBankConnection(
      id: number,
      body: EditBankConnectionParams,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<BankConnection> {
      const localVarAxiosArgs = BankConnectionsApiAxiosParamCreator(
        configuration
      ).editBankConnection(id, body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get bank connections of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those bank connections that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get all bank connections
     * @param {Array<number>} [ids] A comma-separated list of bank connection identifiers. If specified, then only bank connections whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBankConnections(
      ids?: Array<number>,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<BankConnectionList> {
      const localVarAxiosArgs = BankConnectionsApiAxiosParamCreator(
        configuration
      ).getAllBankConnections(ids, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get a single bank connection of the user that is authorized by the access_token. Must pass the connection\'s identifier and the user\'s access_token.
     * @summary Get a bank connection
     * @param {number} id Identifier of requested bank connection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBankConnection(
      id: number,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<BankConnection> {
      const localVarAxiosArgs = BankConnectionsApiAxiosParamCreator(
        configuration
      ).getBankConnection(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get a list of multiple bank connections of the user that is authorized by the access_token. Must pass the connections\' identifiers and the user\'s access_token. Connections whose identifiers do not exist or do not relate to the authorized user will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). WARNING: This service is deprecated and will be removed at some point. If you want to get multiple bank connections, please instead use the service \'Get all bank connections\' and pass a comma-separated list of identifiers as a parameter \'ids\'.
     * @summary Get multiple bank connections
     * @param {Array<number>} ids Comma-separated list of identifiers of requested bank connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleBankConnections(
      ids: Array<number>,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<BankConnectionList> {
      const localVarAxiosArgs = BankConnectionsApiAxiosParamCreator(
        configuration
      ).getMultipleBankConnections(ids, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Imports a new bank connection for a specific user. Must pass the connection credentials and the user\'s access_token. All bank accounts will be downloaded and imported with their current balances, transactions and supported two-step-procedures (note that the amount of available transactions may vary between banks, e.g. some banks deliver all transactions from the past year, others only deliver the transactions from the past three months). The balance and transactions download process runs asynchronously, so this service may return before all balances and transactions have been imported. Also, all downloaded transactions will be categorized by a separate background process that runs asynchronously too. To check the status of the balance and transactions download process as well as the background categorization process, see the status flags that are returned by the GET /bankConnections/<id> service.<br/><br/>You can also import a \"demo connection\" which contains a single bank account with some pre-defined transactions. To import the demo connection, you need to pass the identifier of the \"finAPI Test Bank\". In case of demo connection import, any other fields besides the bank identifier can remain unset. The bankingUserId, bankingCustomerId, bankingPin, and storeSecrets fields will be stored if you pass them, however they will not be regarded when updating the demo connection (in other words: It doesn\'t matter what credentials you choose for the demo connection). Note however that if you want to import the demo connection multiple times for the same user, you must use a different bankingUserId and/or bankingCustomerId for each of the imports. Also note that the skipPositionsDownload flag is ignored for the demo bank connection, i.e. when importing the demo bank connection, you will always get the transactions for its account. You can enable multi-step authentication for the demo bank connection by setting the bank connection name to \"MSA\".<br/><br/>The XS2A interface could also be used to initiate a demo connection import.<br/>The finAPI demo XS2A allows you to download a test account by using the \'import\' or \'connectInterface\' services - in general, this XS2A demo account is the FINTS_SERVER demo account, as it has the same account number and origin of balances and transactions.<br/>Keep in mind, that calling an XS2A demo connection import will result as a newly created bank connection, when the \'connectInterface\' service attaches the XS2A demo account to an existing demo connection.<br/>Passing the login credentials is not obligated only for redirect banks, however the demo bank works without any given set of credentials for the XS2A interface. The old API credentials fields (bankingUserId, bankingCustomerId, bankingPin) are DEPRECATED and temporarily mapped on the new credentials data structure, allowing you to use them within the XS2A import. This is not recommended, as those fields are going to be removed at some point later.<br/>If you are looking to test the XS2A SCA (Strong Customer Authentication, or MSA (Multi-Step Authentication) in the finAPI context), you need to pass the bank connection name as \"MSA\" to trigger the SCA flow or as \'DECOUPLED-AUTH\' to simulate decoupled authentication. To get better understanding about the Multi-Step Authentication, please refer to the \'Error Messages\' section of the swagger documentation.<br/><br/><b>For a more in-depth understanding of the import process, please also read this article on our Dev Portal: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115000296607-Import-Update-of-Bank-Connections-Accounts\' target=\'_blank\'>Import & Update of Bank Connections / Accounts</a></b><br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a><br/><br/><b>Attention:</b> Due to changes on the bank\'s side we have been forced to limit the maxDaysForDownload field to 89 days to reduce the risk of strong customer authentication (SCA) requests. If you have implemented the SCA flow, please contact us, so that we can remove this limitation from your client.
     * @summary Import a new bank connection
     * @param {ImportBankConnectionParams} body Import bank connection parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    importBankConnection(
      body: ImportBankConnectionParams,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<BankConnection> {
      const localVarAxiosArgs = BankConnectionsApiAxiosParamCreator(
        configuration
      ).importBankConnection(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Remove an interface from bank connection and from all associated accounts in the bank connection. Notes: <br/>- An interface cannot get deleted while it is in the process of import or update.
     * @summary Remove an interface
     * @param {RemoveInterfaceParams} body Remove interface parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeInterface(
      body: RemoveInterfaceParams,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = BankConnectionsApiAxiosParamCreator(
        configuration
      ).removeInterface(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Update an existing bank connection of the user that is authorized by the access_token. Downloads and imports the current account balances and new transactions. Must pass the connection\'s identifier and the user\'s access_token. For more information about the processes of authentication, data download and transactions categorization, see POST /bankConnections/import. Note that supported two-step-procedures are updated as well. It may unset the current default two-step-procedure of the given bank connection (but only if this procedure is not supported anymore by the bank). You can also update the \"demo connection\" (in this case, the fields \'bankingPin\', \'importNewAccounts\', and \'skipPositionsDownload\' will be ignored).<br/><br/>Note that you cannot trigger an update of a bank connection as long as there is still a previously triggered update running.<br/><br/><b>For a more in-depth understanding of the update process, please also read this article on our Dev Portal: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115000296607-Import-Update-of-Bank-Connections-Accounts\' target=\'_blank\'>Import & Update of Bank Connections / Accounts</a></b><br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a><br/><br/><b>Attention:</b> Due to changes on the bank\'s side we have been forced to limit the transaction download time frame to 89 days. Now any update of a bank connection will fetch the last three months of transactions per account. If the last successful update was more than 3 months ago, an adjusting entry (\'Zwischensaldo\' transaction) will be created.
     * @summary Update a bank connection
     * @param {UpdateBankConnectionParams} body Update bank connection parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateBankConnection(
      body: UpdateBankConnectionParams,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<BankConnection> {
      const localVarAxiosArgs = BankConnectionsApiAxiosParamCreator(
        configuration
      ).updateBankConnection(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    }
  };
};

/**
 * BankConnectionsApi - factory interface
 * @export
 */
export const BankConnectionsApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Connects new interface to an existing bank connection for a specific user. Must pass the connection credentials and the user\'s access_token. All bank accounts will be downloaded and imported with their current balances, transactions and supported two-step-procedures (note that the amount of available transactions may vary between banks, e.g. some banks deliver all transactions from the past year, others only deliver the transactions from the past three months). The balance and transactions download process runs asynchronously, so this service may return before all balances and transactions have been imported. Also, all downloaded transactions will be categorized by a separate background process that runs asynchronously too. To check the status of the balance and transactions download process as well as the background categorization process, see the status flags that are returned by the GET /bankConnections/<id> service.<br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a>
     * @summary Connect a new interface
     * @param {ConnectInterfaceParams} body Connect interface parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    connectInterface(body: ConnectInterfaceParams, options?: any) {
      return BankConnectionsApiFp(configuration).connectInterface(
        body,
        options
      )(axios, basePath);
    },
    /**
     * Delete all bank connections of the user that is authorized by the access_token. Must pass the user\'s access_token.<br/><br/>Notes: <br/>- All notification rules that are connected to any specific bank connection will get deleted as well. <br/>- If at least one bank connection is busy (currently in the process of import, update, or transactions categorization), then this service will perform no action at all.
     * @summary Delete all bank connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllBankConnections(options?: any) {
      return BankConnectionsApiFp(configuration).deleteAllBankConnections(
        options
      )(axios, basePath);
    },
    /**
     * Delete a single bank connection of the user that is authorized by the access_token, including all of its accounts and their transactions and balance data. Must pass the connection\'s identifier and the user\'s access_token.<br/><br/>Notes: <br/>- All notification rules that are connected to the bank connection will get adjusted so that they no longer have this connection listed. Notification rules that are connected to just this bank connection (and no other connection) will get deleted altogether. <br/>- A bank connection cannot get deleted while it is in the process of import, update, or transactions categorization.
     * @summary Delete a bank connection
     * @param {number} id Identifier of the bank connection to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBankConnection(id: number, options?: any) {
      return BankConnectionsApiFp(configuration).deleteBankConnection(
        id,
        options
      )(axios, basePath);
    },
    /**
     * Edit bank connection data. Must pass the connection\'s identifier and the user\'s access_token.<br/><br/>Note that a bank connection\'s credentials cannot be changed while it is in the process of import, update, or transactions categorization.<br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a>
     * @summary Edit a bank connection
     * @param {number} id Identifier of the bank connection to change the parameters for
     * @param {EditBankConnectionParams} body New bank connection parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editBankConnection(
      id: number,
      body: EditBankConnectionParams,
      options?: any
    ) {
      return BankConnectionsApiFp(configuration).editBankConnection(
        id,
        body,
        options
      )(axios, basePath);
    },
    /**
     * Get bank connections of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those bank connections that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get all bank connections
     * @param {Array<number>} [ids] A comma-separated list of bank connection identifiers. If specified, then only bank connections whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBankConnections(ids?: Array<number>, options?: any) {
      return BankConnectionsApiFp(configuration).getAllBankConnections(
        ids,
        options
      )(axios, basePath);
    },
    /**
     * Get a single bank connection of the user that is authorized by the access_token. Must pass the connection\'s identifier and the user\'s access_token.
     * @summary Get a bank connection
     * @param {number} id Identifier of requested bank connection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBankConnection(id: number, options?: any) {
      return BankConnectionsApiFp(configuration).getBankConnection(id, options)(
        axios,
        basePath
      );
    },
    /**
     * Get a list of multiple bank connections of the user that is authorized by the access_token. Must pass the connections\' identifiers and the user\'s access_token. Connections whose identifiers do not exist or do not relate to the authorized user will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). WARNING: This service is deprecated and will be removed at some point. If you want to get multiple bank connections, please instead use the service \'Get all bank connections\' and pass a comma-separated list of identifiers as a parameter \'ids\'.
     * @summary Get multiple bank connections
     * @param {Array<number>} ids Comma-separated list of identifiers of requested bank connections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleBankConnections(ids: Array<number>, options?: any) {
      return BankConnectionsApiFp(configuration).getMultipleBankConnections(
        ids,
        options
      )(axios, basePath);
    },
    /**
     * Imports a new bank connection for a specific user. Must pass the connection credentials and the user\'s access_token. All bank accounts will be downloaded and imported with their current balances, transactions and supported two-step-procedures (note that the amount of available transactions may vary between banks, e.g. some banks deliver all transactions from the past year, others only deliver the transactions from the past three months). The balance and transactions download process runs asynchronously, so this service may return before all balances and transactions have been imported. Also, all downloaded transactions will be categorized by a separate background process that runs asynchronously too. To check the status of the balance and transactions download process as well as the background categorization process, see the status flags that are returned by the GET /bankConnections/<id> service.<br/><br/>You can also import a \"demo connection\" which contains a single bank account with some pre-defined transactions. To import the demo connection, you need to pass the identifier of the \"finAPI Test Bank\". In case of demo connection import, any other fields besides the bank identifier can remain unset. The bankingUserId, bankingCustomerId, bankingPin, and storeSecrets fields will be stored if you pass them, however they will not be regarded when updating the demo connection (in other words: It doesn\'t matter what credentials you choose for the demo connection). Note however that if you want to import the demo connection multiple times for the same user, you must use a different bankingUserId and/or bankingCustomerId for each of the imports. Also note that the skipPositionsDownload flag is ignored for the demo bank connection, i.e. when importing the demo bank connection, you will always get the transactions for its account. You can enable multi-step authentication for the demo bank connection by setting the bank connection name to \"MSA\".<br/><br/>The XS2A interface could also be used to initiate a demo connection import.<br/>The finAPI demo XS2A allows you to download a test account by using the \'import\' or \'connectInterface\' services - in general, this XS2A demo account is the FINTS_SERVER demo account, as it has the same account number and origin of balances and transactions.<br/>Keep in mind, that calling an XS2A demo connection import will result as a newly created bank connection, when the \'connectInterface\' service attaches the XS2A demo account to an existing demo connection.<br/>Passing the login credentials is not obligated only for redirect banks, however the demo bank works without any given set of credentials for the XS2A interface. The old API credentials fields (bankingUserId, bankingCustomerId, bankingPin) are DEPRECATED and temporarily mapped on the new credentials data structure, allowing you to use them within the XS2A import. This is not recommended, as those fields are going to be removed at some point later.<br/>If you are looking to test the XS2A SCA (Strong Customer Authentication, or MSA (Multi-Step Authentication) in the finAPI context), you need to pass the bank connection name as \"MSA\" to trigger the SCA flow or as \'DECOUPLED-AUTH\' to simulate decoupled authentication. To get better understanding about the Multi-Step Authentication, please refer to the \'Error Messages\' section of the swagger documentation.<br/><br/><b>For a more in-depth understanding of the import process, please also read this article on our Dev Portal: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115000296607-Import-Update-of-Bank-Connections-Accounts\' target=\'_blank\'>Import & Update of Bank Connections / Accounts</a></b><br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a><br/><br/><b>Attention:</b> Due to changes on the bank\'s side we have been forced to limit the maxDaysForDownload field to 89 days to reduce the risk of strong customer authentication (SCA) requests. If you have implemented the SCA flow, please contact us, so that we can remove this limitation from your client.
     * @summary Import a new bank connection
     * @param {ImportBankConnectionParams} body Import bank connection parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    importBankConnection(body: ImportBankConnectionParams, options?: any) {
      return BankConnectionsApiFp(configuration).importBankConnection(
        body,
        options
      )(axios, basePath);
    },
    /**
     * Remove an interface from bank connection and from all associated accounts in the bank connection. Notes: <br/>- An interface cannot get deleted while it is in the process of import or update.
     * @summary Remove an interface
     * @param {RemoveInterfaceParams} body Remove interface parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeInterface(body: RemoveInterfaceParams, options?: any) {
      return BankConnectionsApiFp(configuration).removeInterface(body, options)(
        axios,
        basePath
      );
    },
    /**
     * Update an existing bank connection of the user that is authorized by the access_token. Downloads and imports the current account balances and new transactions. Must pass the connection\'s identifier and the user\'s access_token. For more information about the processes of authentication, data download and transactions categorization, see POST /bankConnections/import. Note that supported two-step-procedures are updated as well. It may unset the current default two-step-procedure of the given bank connection (but only if this procedure is not supported anymore by the bank). You can also update the \"demo connection\" (in this case, the fields \'bankingPin\', \'importNewAccounts\', and \'skipPositionsDownload\' will be ignored).<br/><br/>Note that you cannot trigger an update of a bank connection as long as there is still a previously triggered update running.<br/><br/><b>For a more in-depth understanding of the update process, please also read this article on our Dev Portal: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115000296607-Import-Update-of-Bank-Connections-Accounts\' target=\'_blank\'>Import & Update of Bank Connections / Accounts</a></b><br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a><br/><br/><b>Attention:</b> Due to changes on the bank\'s side we have been forced to limit the transaction download time frame to 89 days. Now any update of a bank connection will fetch the last three months of transactions per account. If the last successful update was more than 3 months ago, an adjusting entry (\'Zwischensaldo\' transaction) will be created.
     * @summary Update a bank connection
     * @param {UpdateBankConnectionParams} body Update bank connection parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateBankConnection(body: UpdateBankConnectionParams, options?: any) {
      return BankConnectionsApiFp(configuration).updateBankConnection(
        body,
        options
      )(axios, basePath);
    }
  };
};

/**
 * BankConnectionsApi - object-oriented interface
 * @export
 * @class BankConnectionsApi
 * @extends {BaseAPI}
 */
export class BankConnectionsApi extends BaseAPI {
  /**
   * Connects new interface to an existing bank connection for a specific user. Must pass the connection credentials and the user\'s access_token. All bank accounts will be downloaded and imported with their current balances, transactions and supported two-step-procedures (note that the amount of available transactions may vary between banks, e.g. some banks deliver all transactions from the past year, others only deliver the transactions from the past three months). The balance and transactions download process runs asynchronously, so this service may return before all balances and transactions have been imported. Also, all downloaded transactions will be categorized by a separate background process that runs asynchronously too. To check the status of the balance and transactions download process as well as the background categorization process, see the status flags that are returned by the GET /bankConnections/<id> service.<br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a>
   * @summary Connect a new interface
   * @param {ConnectInterfaceParams} body Connect interface parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankConnectionsApi
   */
  public connectInterface(body: ConnectInterfaceParams, options?: any) {
    return BankConnectionsApiFp(this.configuration).connectInterface(
      body,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Delete all bank connections of the user that is authorized by the access_token. Must pass the user\'s access_token.<br/><br/>Notes: <br/>- All notification rules that are connected to any specific bank connection will get deleted as well. <br/>- If at least one bank connection is busy (currently in the process of import, update, or transactions categorization), then this service will perform no action at all.
   * @summary Delete all bank connections
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankConnectionsApi
   */
  public deleteAllBankConnections(options?: any) {
    return BankConnectionsApiFp(this.configuration).deleteAllBankConnections(
      options
    )(this.axios, this.basePath);
  }

  /**
   * Delete a single bank connection of the user that is authorized by the access_token, including all of its accounts and their transactions and balance data. Must pass the connection\'s identifier and the user\'s access_token.<br/><br/>Notes: <br/>- All notification rules that are connected to the bank connection will get adjusted so that they no longer have this connection listed. Notification rules that are connected to just this bank connection (and no other connection) will get deleted altogether. <br/>- A bank connection cannot get deleted while it is in the process of import, update, or transactions categorization.
   * @summary Delete a bank connection
   * @param {number} id Identifier of the bank connection to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankConnectionsApi
   */
  public deleteBankConnection(id: number, options?: any) {
    return BankConnectionsApiFp(this.configuration).deleteBankConnection(
      id,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Edit bank connection data. Must pass the connection\'s identifier and the user\'s access_token.<br/><br/>Note that a bank connection\'s credentials cannot be changed while it is in the process of import, update, or transactions categorization.<br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a>
   * @summary Edit a bank connection
   * @param {number} id Identifier of the bank connection to change the parameters for
   * @param {EditBankConnectionParams} body New bank connection parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankConnectionsApi
   */
  public editBankConnection(
    id: number,
    body: EditBankConnectionParams,
    options?: any
  ) {
    return BankConnectionsApiFp(this.configuration).editBankConnection(
      id,
      body,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Get bank connections of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those bank connections that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
   * @summary Get all bank connections
   * @param {Array<number>} [ids] A comma-separated list of bank connection identifiers. If specified, then only bank connections whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankConnectionsApi
   */
  public getAllBankConnections(ids?: Array<number>, options?: any) {
    return BankConnectionsApiFp(this.configuration).getAllBankConnections(
      ids,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Get a single bank connection of the user that is authorized by the access_token. Must pass the connection\'s identifier and the user\'s access_token.
   * @summary Get a bank connection
   * @param {number} id Identifier of requested bank connection
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankConnectionsApi
   */
  public getBankConnection(id: number, options?: any) {
    return BankConnectionsApiFp(this.configuration).getBankConnection(
      id,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Get a list of multiple bank connections of the user that is authorized by the access_token. Must pass the connections\' identifiers and the user\'s access_token. Connections whose identifiers do not exist or do not relate to the authorized user will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). WARNING: This service is deprecated and will be removed at some point. If you want to get multiple bank connections, please instead use the service \'Get all bank connections\' and pass a comma-separated list of identifiers as a parameter \'ids\'.
   * @summary Get multiple bank connections
   * @param {Array<number>} ids Comma-separated list of identifiers of requested bank connections
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankConnectionsApi
   */
  public getMultipleBankConnections(ids: Array<number>, options?: any) {
    return BankConnectionsApiFp(this.configuration).getMultipleBankConnections(
      ids,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Imports a new bank connection for a specific user. Must pass the connection credentials and the user\'s access_token. All bank accounts will be downloaded and imported with their current balances, transactions and supported two-step-procedures (note that the amount of available transactions may vary between banks, e.g. some banks deliver all transactions from the past year, others only deliver the transactions from the past three months). The balance and transactions download process runs asynchronously, so this service may return before all balances and transactions have been imported. Also, all downloaded transactions will be categorized by a separate background process that runs asynchronously too. To check the status of the balance and transactions download process as well as the background categorization process, see the status flags that are returned by the GET /bankConnections/<id> service.<br/><br/>You can also import a \"demo connection\" which contains a single bank account with some pre-defined transactions. To import the demo connection, you need to pass the identifier of the \"finAPI Test Bank\". In case of demo connection import, any other fields besides the bank identifier can remain unset. The bankingUserId, bankingCustomerId, bankingPin, and storeSecrets fields will be stored if you pass them, however they will not be regarded when updating the demo connection (in other words: It doesn\'t matter what credentials you choose for the demo connection). Note however that if you want to import the demo connection multiple times for the same user, you must use a different bankingUserId and/or bankingCustomerId for each of the imports. Also note that the skipPositionsDownload flag is ignored for the demo bank connection, i.e. when importing the demo bank connection, you will always get the transactions for its account. You can enable multi-step authentication for the demo bank connection by setting the bank connection name to \"MSA\".<br/><br/>The XS2A interface could also be used to initiate a demo connection import.<br/>The finAPI demo XS2A allows you to download a test account by using the \'import\' or \'connectInterface\' services - in general, this XS2A demo account is the FINTS_SERVER demo account, as it has the same account number and origin of balances and transactions.<br/>Keep in mind, that calling an XS2A demo connection import will result as a newly created bank connection, when the \'connectInterface\' service attaches the XS2A demo account to an existing demo connection.<br/>Passing the login credentials is not obligated only for redirect banks, however the demo bank works without any given set of credentials for the XS2A interface. The old API credentials fields (bankingUserId, bankingCustomerId, bankingPin) are DEPRECATED and temporarily mapped on the new credentials data structure, allowing you to use them within the XS2A import. This is not recommended, as those fields are going to be removed at some point later.<br/>If you are looking to test the XS2A SCA (Strong Customer Authentication, or MSA (Multi-Step Authentication) in the finAPI context), you need to pass the bank connection name as \"MSA\" to trigger the SCA flow or as \'DECOUPLED-AUTH\' to simulate decoupled authentication. To get better understanding about the Multi-Step Authentication, please refer to the \'Error Messages\' section of the swagger documentation.<br/><br/><b>For a more in-depth understanding of the import process, please also read this article on our Dev Portal: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115000296607-Import-Update-of-Bank-Connections-Accounts\' target=\'_blank\'>Import & Update of Bank Connections / Accounts</a></b><br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a><br/><br/><b>Attention:</b> Due to changes on the bank\'s side we have been forced to limit the maxDaysForDownload field to 89 days to reduce the risk of strong customer authentication (SCA) requests. If you have implemented the SCA flow, please contact us, so that we can remove this limitation from your client.
   * @summary Import a new bank connection
   * @param {ImportBankConnectionParams} body Import bank connection parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankConnectionsApi
   */
  public importBankConnection(body: ImportBankConnectionParams, options?: any) {
    return BankConnectionsApiFp(this.configuration).importBankConnection(
      body,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Remove an interface from bank connection and from all associated accounts in the bank connection. Notes: <br/>- An interface cannot get deleted while it is in the process of import or update.
   * @summary Remove an interface
   * @param {RemoveInterfaceParams} body Remove interface parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankConnectionsApi
   */
  public removeInterface(body: RemoveInterfaceParams, options?: any) {
    return BankConnectionsApiFp(this.configuration).removeInterface(
      body,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Update an existing bank connection of the user that is authorized by the access_token. Downloads and imports the current account balances and new transactions. Must pass the connection\'s identifier and the user\'s access_token. For more information about the processes of authentication, data download and transactions categorization, see POST /bankConnections/import. Note that supported two-step-procedures are updated as well. It may unset the current default two-step-procedure of the given bank connection (but only if this procedure is not supported anymore by the bank). You can also update the \"demo connection\" (in this case, the fields \'bankingPin\', \'importNewAccounts\', and \'skipPositionsDownload\' will be ignored).<br/><br/>Note that you cannot trigger an update of a bank connection as long as there is still a previously triggered update running.<br/><br/><b>For a more in-depth understanding of the update process, please also read this article on our Dev Portal: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115000296607-Import-Update-of-Bank-Connections-Accounts\' target=\'_blank\'>Import & Update of Bank Connections / Accounts</a></b><br/><br/>NOTE: Depending on your license, this service may respond with HTTP code 451, containing an error message with a identifier of web form in it. In addition to that the response will also have included a \'Location\' header, which contains the URL to the web form. In this case, you must forward your user to finAPI\'s web form. For a detailed explanation of the Web Form Flow, please refer to this article: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/360002596391\' target=\'_blank\'>finAPI\'s Web Form Flow</a><br/><br/><b>Attention:</b> Due to changes on the bank\'s side we have been forced to limit the transaction download time frame to 89 days. Now any update of a bank connection will fetch the last three months of transactions per account. If the last successful update was more than 3 months ago, an adjusting entry (\'Zwischensaldo\' transaction) will be created.
   * @summary Update a bank connection
   * @param {UpdateBankConnectionParams} body Update bank connection parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankConnectionsApi
   */
  public updateBankConnection(body: UpdateBankConnectionParams, options?: any) {
    return BankConnectionsApiFp(this.configuration).updateBankConnection(
      body,
      options
    )(this.axios, this.basePath);
  }
}

/**
 * BanksApi - axios parameter creator
 * @export
 */
export const BanksApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * Get and search banks from finAPI\'s database of banks. Must pass the authorized user\'s access_token, or your client\'s access_token. You can set optional search criteria to get only those banks that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get and search all banks
     * @param {Array<number>} [ids] A comma-separated list of bank identifiers. If specified, then only banks whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {string} [search] If specified, then only those banks will be contained in the result whose \&#39;name\&#39;, \&#39;blz\&#39;, \&#39;bic\&#39; or \&#39;city\&#39; contains the given search string (the matching works case-insensitive). If no banks contain the search string in any of the regarded fields, then the result will be an empty list. Note that you may also pass an IBAN in this field, in which case finAPI will try to find the related bank in its database and regard only this bank for the search. Also note: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must apply to a bank in order for it to get included into the result.
     * @param {boolean} [isSupported] If specified, then only supported (in case of \&#39;true\&#39; value) or unsupported (in case of \&#39;false\&#39; value) banks will be regarded.  NOTE: This field is deprecated and will be removed at some point. Please refer to field \&#39;supportedInterfaces\&#39; instead.
     * @param {boolean} [pinsAreVolatile] If specified, then only those banks will be regarded that have the given value (true or false) for their \&#39;pinsAreVolatile\&#39; field.  NOTE: This field is deprecated and will be removed at some point.
     * @param {Array<string>} [supportedDataSources] Comma-separated list of data sources. Possible values: WEB_SCRAPER,FINTS_SERVER. If this parameter is specified, then only those banks will be regarded in the search that support ALL of the given data sources. Note that this does NOT imply that those data sources must be the only data sources that are supported by a bank.  NOTE: This field is deprecated and will be removed at some point. Please refer to field \&#39;supportedInterfaces\&#39; instead.
     * @param {Array<string>} [supportedInterfaces] Comma-separated list of bank interfaces. Possible values: FINTS_SERVER,WEB_SCRAPER,XS2A. If this parameter is specified, then all the banks that support at least one of the given interfaces will be returned. Note that this does NOT imply that those interfaces must be the only ones that are supported by a bank.
     * @param {Array<string>} [location] Comma-separated list of two-letter country codes (ISO 3166 ALPHA-2). If set, then only those banks will be regarded in the search that are located in the specified countries. Notes: Banks which do not have a location set (i.e. international institutes) will ALWAYS be regarded in the search, independent of what you specify for this field. When you pass a country code that doesn\&#39;t exist in the ISO 3166 ALPHA-2 standard, then the service will respond with 400 BAD_REQUEST.
     * @param {Array<number>} [tppAuthenticationGroupIds] A comma-separated list of TPP authentication group identifiers. If specified, then only banks who have at least one interface belonging to one of the given groups will be regarded. The maximum number of identifiers is 1000.
     * @param {boolean} [isTestBank] If specified, then only those banks will be regarded that have the given value (true or false) for their \&#39;isTestBank\&#39; field.
     * @param {number} [page] Result page that you want to retrieve.
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;id\&#39;, \&#39;name\&#39;, \&#39;blz\&#39;, \&#39;bic\&#39; or \&#39;popularity\&#39;. The default order for all services is \&#39;id,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: \&#39;/banks?order&#x3D;name,desc&amp;order&#x3D;id,asc\&#39; will return banks ordered by \&#39;name\&#39; (descending), where banks with the same \&#39;name\&#39; are ordered by \&#39;id\&#39; (ascending). The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchAllBanks(
      ids?: Array<number>,
      search?: string,
      isSupported?: boolean,
      pinsAreVolatile?: boolean,
      supportedDataSources?: Array<string>,
      supportedInterfaces?: Array<string>,
      location?: Array<string>,
      tppAuthenticationGroupIds?: Array<number>,
      isTestBank?: boolean,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/api/v1/banks`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      if (ids) {
        localVarQueryParameter["ids"] = ids;
      }

      if (search !== undefined) {
        localVarQueryParameter["search"] = search;
      }

      if (isSupported !== undefined) {
        localVarQueryParameter["isSupported"] = isSupported;
      }

      if (pinsAreVolatile !== undefined) {
        localVarQueryParameter["pinsAreVolatile"] = pinsAreVolatile;
      }

      if (supportedDataSources) {
        localVarQueryParameter["supportedDataSources"] = supportedDataSources;
      }

      if (supportedInterfaces) {
        localVarQueryParameter["supportedInterfaces"] = supportedInterfaces;
      }

      if (location) {
        localVarQueryParameter["location"] = location;
      }

      if (tppAuthenticationGroupIds) {
        localVarQueryParameter[
          "tppAuthenticationGroupIds"
        ] = tppAuthenticationGroupIds;
      }

      if (isTestBank !== undefined) {
        localVarQueryParameter["isTestBank"] = isTestBank;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["perPage"] = perPage;
      }

      if (order) {
        localVarQueryParameter["order"] = order;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a single bank from finAPI\'s database of banks. You have to pass the bank\'s identifier, and either the authorized user\'s access_token, or your client\'s access token.
     * @summary Get a bank
     * @param {number} id Identifier of requested bank
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBank(id: number, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getBank."
        );
      }
      const localVarPath = `/api/v1/banks/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a list of multiple banks from finAPI\'s database of banks. You have to pass a list of bank identifiers, and either the authorized user\'s access_token, or your client\'s access token. Note that banks whose identifiers do not exist will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list).<br/><br/><b>WARNING</b>: This service is deprecated and will be removed at some point. If you want to get multiple banks, please instead use the service \'Get and search all banks\' and pass a comma-separated list of identifiers with the parameter \'ids\'.
     * @summary Get multiple banks
     * @param {Array<number>} ids Comma-separated list of identifiers of requested banks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleBanks(ids: Array<number>, options: any = {}): RequestArgs {
      // verify required parameter 'ids' is not null or undefined
      if (ids === null || ids === undefined) {
        throw new RequiredError(
          "ids",
          "Required parameter ids was null or undefined when calling getMultipleBanks."
        );
      }
      const localVarPath = `/api/v1/banks/{ids}`.replace(
        `{${"ids"}}`,
        encodeURIComponent(String(ids))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * BanksApi - functional programming interface
 * @export
 */
export const BanksApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Get and search banks from finAPI\'s database of banks. Must pass the authorized user\'s access_token, or your client\'s access_token. You can set optional search criteria to get only those banks that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get and search all banks
     * @param {Array<number>} [ids] A comma-separated list of bank identifiers. If specified, then only banks whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {string} [search] If specified, then only those banks will be contained in the result whose \&#39;name\&#39;, \&#39;blz\&#39;, \&#39;bic\&#39; or \&#39;city\&#39; contains the given search string (the matching works case-insensitive). If no banks contain the search string in any of the regarded fields, then the result will be an empty list. Note that you may also pass an IBAN in this field, in which case finAPI will try to find the related bank in its database and regard only this bank for the search. Also note: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must apply to a bank in order for it to get included into the result.
     * @param {boolean} [isSupported] If specified, then only supported (in case of \&#39;true\&#39; value) or unsupported (in case of \&#39;false\&#39; value) banks will be regarded.  NOTE: This field is deprecated and will be removed at some point. Please refer to field \&#39;supportedInterfaces\&#39; instead.
     * @param {boolean} [pinsAreVolatile] If specified, then only those banks will be regarded that have the given value (true or false) for their \&#39;pinsAreVolatile\&#39; field.  NOTE: This field is deprecated and will be removed at some point.
     * @param {Array<string>} [supportedDataSources] Comma-separated list of data sources. Possible values: WEB_SCRAPER,FINTS_SERVER. If this parameter is specified, then only those banks will be regarded in the search that support ALL of the given data sources. Note that this does NOT imply that those data sources must be the only data sources that are supported by a bank.  NOTE: This field is deprecated and will be removed at some point. Please refer to field \&#39;supportedInterfaces\&#39; instead.
     * @param {Array<string>} [supportedInterfaces] Comma-separated list of bank interfaces. Possible values: FINTS_SERVER,WEB_SCRAPER,XS2A. If this parameter is specified, then all the banks that support at least one of the given interfaces will be returned. Note that this does NOT imply that those interfaces must be the only ones that are supported by a bank.
     * @param {Array<string>} [location] Comma-separated list of two-letter country codes (ISO 3166 ALPHA-2). If set, then only those banks will be regarded in the search that are located in the specified countries. Notes: Banks which do not have a location set (i.e. international institutes) will ALWAYS be regarded in the search, independent of what you specify for this field. When you pass a country code that doesn\&#39;t exist in the ISO 3166 ALPHA-2 standard, then the service will respond with 400 BAD_REQUEST.
     * @param {Array<number>} [tppAuthenticationGroupIds] A comma-separated list of TPP authentication group identifiers. If specified, then only banks who have at least one interface belonging to one of the given groups will be regarded. The maximum number of identifiers is 1000.
     * @param {boolean} [isTestBank] If specified, then only those banks will be regarded that have the given value (true or false) for their \&#39;isTestBank\&#39; field.
     * @param {number} [page] Result page that you want to retrieve.
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;id\&#39;, \&#39;name\&#39;, \&#39;blz\&#39;, \&#39;bic\&#39; or \&#39;popularity\&#39;. The default order for all services is \&#39;id,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: \&#39;/banks?order&#x3D;name,desc&amp;order&#x3D;id,asc\&#39; will return banks ordered by \&#39;name\&#39; (descending), where banks with the same \&#39;name\&#39; are ordered by \&#39;id\&#39; (ascending). The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchAllBanks(
      ids?: Array<number>,
      search?: string,
      isSupported?: boolean,
      pinsAreVolatile?: boolean,
      supportedDataSources?: Array<string>,
      supportedInterfaces?: Array<string>,
      location?: Array<string>,
      tppAuthenticationGroupIds?: Array<number>,
      isTestBank?: boolean,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<PageableBankList> {
      const localVarAxiosArgs = BanksApiAxiosParamCreator(
        configuration
      ).getAndSearchAllBanks(
        ids,
        search,
        isSupported,
        pinsAreVolatile,
        supportedDataSources,
        supportedInterfaces,
        location,
        tppAuthenticationGroupIds,
        isTestBank,
        page,
        perPage,
        order,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get a single bank from finAPI\'s database of banks. You have to pass the bank\'s identifier, and either the authorized user\'s access_token, or your client\'s access token.
     * @summary Get a bank
     * @param {number} id Identifier of requested bank
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBank(
      id: number,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bank> {
      const localVarAxiosArgs = BanksApiAxiosParamCreator(
        configuration
      ).getBank(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get a list of multiple banks from finAPI\'s database of banks. You have to pass a list of bank identifiers, and either the authorized user\'s access_token, or your client\'s access token. Note that banks whose identifiers do not exist will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list).<br/><br/><b>WARNING</b>: This service is deprecated and will be removed at some point. If you want to get multiple banks, please instead use the service \'Get and search all banks\' and pass a comma-separated list of identifiers with the parameter \'ids\'.
     * @summary Get multiple banks
     * @param {Array<number>} ids Comma-separated list of identifiers of requested banks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleBanks(
      ids: Array<number>,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankList> {
      const localVarAxiosArgs = BanksApiAxiosParamCreator(
        configuration
      ).getMultipleBanks(ids, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    }
  };
};

/**
 * BanksApi - factory interface
 * @export
 */
export const BanksApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Get and search banks from finAPI\'s database of banks. Must pass the authorized user\'s access_token, or your client\'s access_token. You can set optional search criteria to get only those banks that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get and search all banks
     * @param {Array<number>} [ids] A comma-separated list of bank identifiers. If specified, then only banks whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {string} [search] If specified, then only those banks will be contained in the result whose \&#39;name\&#39;, \&#39;blz\&#39;, \&#39;bic\&#39; or \&#39;city\&#39; contains the given search string (the matching works case-insensitive). If no banks contain the search string in any of the regarded fields, then the result will be an empty list. Note that you may also pass an IBAN in this field, in which case finAPI will try to find the related bank in its database and regard only this bank for the search. Also note: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must apply to a bank in order for it to get included into the result.
     * @param {boolean} [isSupported] If specified, then only supported (in case of \&#39;true\&#39; value) or unsupported (in case of \&#39;false\&#39; value) banks will be regarded.  NOTE: This field is deprecated and will be removed at some point. Please refer to field \&#39;supportedInterfaces\&#39; instead.
     * @param {boolean} [pinsAreVolatile] If specified, then only those banks will be regarded that have the given value (true or false) for their \&#39;pinsAreVolatile\&#39; field.  NOTE: This field is deprecated and will be removed at some point.
     * @param {Array<string>} [supportedDataSources] Comma-separated list of data sources. Possible values: WEB_SCRAPER,FINTS_SERVER. If this parameter is specified, then only those banks will be regarded in the search that support ALL of the given data sources. Note that this does NOT imply that those data sources must be the only data sources that are supported by a bank.  NOTE: This field is deprecated and will be removed at some point. Please refer to field \&#39;supportedInterfaces\&#39; instead.
     * @param {Array<string>} [supportedInterfaces] Comma-separated list of bank interfaces. Possible values: FINTS_SERVER,WEB_SCRAPER,XS2A. If this parameter is specified, then all the banks that support at least one of the given interfaces will be returned. Note that this does NOT imply that those interfaces must be the only ones that are supported by a bank.
     * @param {Array<string>} [location] Comma-separated list of two-letter country codes (ISO 3166 ALPHA-2). If set, then only those banks will be regarded in the search that are located in the specified countries. Notes: Banks which do not have a location set (i.e. international institutes) will ALWAYS be regarded in the search, independent of what you specify for this field. When you pass a country code that doesn\&#39;t exist in the ISO 3166 ALPHA-2 standard, then the service will respond with 400 BAD_REQUEST.
     * @param {Array<number>} [tppAuthenticationGroupIds] A comma-separated list of TPP authentication group identifiers. If specified, then only banks who have at least one interface belonging to one of the given groups will be regarded. The maximum number of identifiers is 1000.
     * @param {boolean} [isTestBank] If specified, then only those banks will be regarded that have the given value (true or false) for their \&#39;isTestBank\&#39; field.
     * @param {number} [page] Result page that you want to retrieve.
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;id\&#39;, \&#39;name\&#39;, \&#39;blz\&#39;, \&#39;bic\&#39; or \&#39;popularity\&#39;. The default order for all services is \&#39;id,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: \&#39;/banks?order&#x3D;name,desc&amp;order&#x3D;id,asc\&#39; will return banks ordered by \&#39;name\&#39; (descending), where banks with the same \&#39;name\&#39; are ordered by \&#39;id\&#39; (ascending). The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchAllBanks(
      ids?: Array<number>,
      search?: string,
      isSupported?: boolean,
      pinsAreVolatile?: boolean,
      supportedDataSources?: Array<string>,
      supportedInterfaces?: Array<string>,
      location?: Array<string>,
      tppAuthenticationGroupIds?: Array<number>,
      isTestBank?: boolean,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options?: any
    ) {
      return BanksApiFp(configuration).getAndSearchAllBanks(
        ids,
        search,
        isSupported,
        pinsAreVolatile,
        supportedDataSources,
        supportedInterfaces,
        location,
        tppAuthenticationGroupIds,
        isTestBank,
        page,
        perPage,
        order,
        options
      )(axios, basePath);
    },
    /**
     * Get a single bank from finAPI\'s database of banks. You have to pass the bank\'s identifier, and either the authorized user\'s access_token, or your client\'s access token.
     * @summary Get a bank
     * @param {number} id Identifier of requested bank
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBank(id: number, options?: any) {
      return BanksApiFp(configuration).getBank(id, options)(axios, basePath);
    },
    /**
     * Get a list of multiple banks from finAPI\'s database of banks. You have to pass a list of bank identifiers, and either the authorized user\'s access_token, or your client\'s access token. Note that banks whose identifiers do not exist will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list).<br/><br/><b>WARNING</b>: This service is deprecated and will be removed at some point. If you want to get multiple banks, please instead use the service \'Get and search all banks\' and pass a comma-separated list of identifiers with the parameter \'ids\'.
     * @summary Get multiple banks
     * @param {Array<number>} ids Comma-separated list of identifiers of requested banks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleBanks(ids: Array<number>, options?: any) {
      return BanksApiFp(configuration).getMultipleBanks(ids, options)(
        axios,
        basePath
      );
    }
  };
};

/**
 * BanksApi - object-oriented interface
 * @export
 * @class BanksApi
 * @extends {BaseAPI}
 */
export class BanksApi extends BaseAPI {
  /**
   * Get and search banks from finAPI\'s database of banks. Must pass the authorized user\'s access_token, or your client\'s access_token. You can set optional search criteria to get only those banks that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
   * @summary Get and search all banks
   * @param {Array<number>} [ids] A comma-separated list of bank identifiers. If specified, then only banks whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
   * @param {string} [search] If specified, then only those banks will be contained in the result whose \&#39;name\&#39;, \&#39;blz\&#39;, \&#39;bic\&#39; or \&#39;city\&#39; contains the given search string (the matching works case-insensitive). If no banks contain the search string in any of the regarded fields, then the result will be an empty list. Note that you may also pass an IBAN in this field, in which case finAPI will try to find the related bank in its database and regard only this bank for the search. Also note: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must apply to a bank in order for it to get included into the result.
   * @param {boolean} [isSupported] If specified, then only supported (in case of \&#39;true\&#39; value) or unsupported (in case of \&#39;false\&#39; value) banks will be regarded.  NOTE: This field is deprecated and will be removed at some point. Please refer to field \&#39;supportedInterfaces\&#39; instead.
   * @param {boolean} [pinsAreVolatile] If specified, then only those banks will be regarded that have the given value (true or false) for their \&#39;pinsAreVolatile\&#39; field.  NOTE: This field is deprecated and will be removed at some point.
   * @param {Array<string>} [supportedDataSources] Comma-separated list of data sources. Possible values: WEB_SCRAPER,FINTS_SERVER. If this parameter is specified, then only those banks will be regarded in the search that support ALL of the given data sources. Note that this does NOT imply that those data sources must be the only data sources that are supported by a bank.  NOTE: This field is deprecated and will be removed at some point. Please refer to field \&#39;supportedInterfaces\&#39; instead.
   * @param {Array<string>} [supportedInterfaces] Comma-separated list of bank interfaces. Possible values: FINTS_SERVER,WEB_SCRAPER,XS2A. If this parameter is specified, then all the banks that support at least one of the given interfaces will be returned. Note that this does NOT imply that those interfaces must be the only ones that are supported by a bank.
   * @param {Array<string>} [location] Comma-separated list of two-letter country codes (ISO 3166 ALPHA-2). If set, then only those banks will be regarded in the search that are located in the specified countries. Notes: Banks which do not have a location set (i.e. international institutes) will ALWAYS be regarded in the search, independent of what you specify for this field. When you pass a country code that doesn\&#39;t exist in the ISO 3166 ALPHA-2 standard, then the service will respond with 400 BAD_REQUEST.
   * @param {Array<number>} [tppAuthenticationGroupIds] A comma-separated list of TPP authentication group identifiers. If specified, then only banks who have at least one interface belonging to one of the given groups will be regarded. The maximum number of identifiers is 1000.
   * @param {boolean} [isTestBank] If specified, then only those banks will be regarded that have the given value (true or false) for their \&#39;isTestBank\&#39; field.
   * @param {number} [page] Result page that you want to retrieve.
   * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
   * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;id\&#39;, \&#39;name\&#39;, \&#39;blz\&#39;, \&#39;bic\&#39; or \&#39;popularity\&#39;. The default order for all services is \&#39;id,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: \&#39;/banks?order&#x3D;name,desc&amp;order&#x3D;id,asc\&#39; will return banks ordered by \&#39;name\&#39; (descending), where banks with the same \&#39;name\&#39; are ordered by \&#39;id\&#39; (ascending). The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BanksApi
   */
  public getAndSearchAllBanks(
    ids?: Array<number>,
    search?: string,
    isSupported?: boolean,
    pinsAreVolatile?: boolean,
    supportedDataSources?: Array<string>,
    supportedInterfaces?: Array<string>,
    location?: Array<string>,
    tppAuthenticationGroupIds?: Array<number>,
    isTestBank?: boolean,
    page?: number,
    perPage?: number,
    order?: Array<string>,
    options?: any
  ) {
    return BanksApiFp(this.configuration).getAndSearchAllBanks(
      ids,
      search,
      isSupported,
      pinsAreVolatile,
      supportedDataSources,
      supportedInterfaces,
      location,
      tppAuthenticationGroupIds,
      isTestBank,
      page,
      perPage,
      order,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Get a single bank from finAPI\'s database of banks. You have to pass the bank\'s identifier, and either the authorized user\'s access_token, or your client\'s access token.
   * @summary Get a bank
   * @param {number} id Identifier of requested bank
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BanksApi
   */
  public getBank(id: number, options?: any) {
    return BanksApiFp(this.configuration).getBank(id, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Get a list of multiple banks from finAPI\'s database of banks. You have to pass a list of bank identifiers, and either the authorized user\'s access_token, or your client\'s access token. Note that banks whose identifiers do not exist will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list).<br/><br/><b>WARNING</b>: This service is deprecated and will be removed at some point. If you want to get multiple banks, please instead use the service \'Get and search all banks\' and pass a comma-separated list of identifiers with the parameter \'ids\'.
   * @summary Get multiple banks
   * @param {Array<number>} ids Comma-separated list of identifiers of requested banks
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BanksApi
   */
  public getMultipleBanks(ids: Array<number>, options?: any) {
    return BanksApiFp(this.configuration).getMultipleBanks(ids, options)(
      this.axios,
      this.basePath
    );
  }
}

/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * Create a new custom transaction category for the authorized user, that can then be assigned to transactions via PATCH /transactions, and that will also be regarded in finAPI\'s automatic transactions categorization process. Must pass the user\'s access_token.
     * @summary Create a new category
     * @param {CategoryParams} [body] Parameters of the new category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCategory(body?: CategoryParams, options: any = {}): RequestArgs {
      const localVarPath = `/api/v1/categories`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"CategoryParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete all custom categories of the user that is authorized by the access_token. Must pass the user\'s access_token. Note that this deletes both parent categories as well as any related sub-categories.
     * @summary Delete all categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllCategories(options: any = {}): RequestArgs {
      const localVarPath = `/api/v1/categories`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete a single category of the user that is authorized by the access_token. Must pass the user\'s access_token. Note that you can only delete user-custom categories (category\'s where the \'isCustom\' flag is true). Also note that when deleting a parent category, all its sub-categories will be deleted as well.
     * @summary Delete a category
     * @param {number} id Category identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCategory(id: number, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling deleteCategory."
        );
      }
      const localVarPath = `/api/v1/categories/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Change the name of a custom transaction category belonging to the authorized user. Must pass the user\'s access_token.
     * @summary Edit a category
     * @param {number} id Identifier of the category to edit
     * @param {EditCategoryParams} [body] New category name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editCategory(
      id: number,
      body?: EditCategoryParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling editCategory."
        );
      }
      const localVarPath = `/api/v1/categories/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"EditCategoryParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a list of all global finAPI categories as well as all custom categories of the authorized user. Must pass the user\'s access_token. You can set optional search criteria to get only those categories that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get and search all categories
     * @param {Array<number>} [ids] A comma-separated list of category identifiers. If specified, then only categories whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {string} [search] If specified, then only those categories will be contained in the result whose \&#39;name\&#39; contains the given search string (the matching works case-insensitive). If no categories contain the search string in their name, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the name in order for a category to get included into the result.
     * @param {boolean} [isCustom] If specified, then the result will contain only categories that are either finAPI global (in case of value \&#39;false\&#39;), or only categories that have been created by the authorized user (in case of value \&#39;true\&#39;).
     * @param {number} [page] Result page that you want to retrieve.
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;id\&#39;, \&#39;name\&#39; and \&#39;isCustom\&#39;. The default order is \&#39;id,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: \&#39;/categories?order&#x3D;isCustom,desc&amp;order&#x3D;name\&#39; will return all custom categories followed by all default categories. Both groups are ordered ascending by name. The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchAllCategories(
      ids?: Array<number>,
      search?: string,
      isCustom?: boolean,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/api/v1/categories`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      if (ids) {
        localVarQueryParameter["ids"] = ids;
      }

      if (search !== undefined) {
        localVarQueryParameter["search"] = search;
      }

      if (isCustom !== undefined) {
        localVarQueryParameter["isCustom"] = isCustom;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["perPage"] = perPage;
      }

      if (order) {
        localVarQueryParameter["order"] = order;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get the cash flow(s) (= total income, spending, and balance) for one or several categories. You can specify various criteria such as the time period to calculate the cash flows for, or what categories to do the calculations for. Note that the cash flow for a category may include the cash flows for all of its sub-categories, or not include it, depending on the \'includeSubCashFlows\' setting. Must pass the user\'s access_token.
     * @summary Get cash flows
     * @param {string} [search] If specified, then only transactions that contain the search term in their purpose or counterpart fields will be contained in the result. Note that the search is case insensitive.
     * @param {string} [counterpart] The counterpart is the person or institution that received your payment, or that you made the payment to. If this parameter is specified, then only transactions that contain the given term in one (or more) of their counterpart fields (\&#39;counterpartName\&#39;, \&#39;counterpartAccountNumber\&#39;, \&#39;counterpartIban\&#39;, \&#39;counterpartBic\&#39; or \&#39;counterpartBlz\&#39;) will be contained in the result. Note that the search is case insensitive.
     * @param {string} [purpose] If specified, then only those transactions will be contained in the result whose purpose field contains the given search string. Note that the search is case insensitive.NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the purpose in order for a transaction to get included into the result.
     * @param {Array<number>} [accountIds] A comma-separated list of account identifiers. If specified, then only transactions that relate to the given accounts will be regarded. If not specified, then all accounts will be regarded.
     * @param {string} [minBankBookingDate] Lower bound for a transaction\&#39;s booking date as returned by the bank (&#x3D; original booking date), in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;bankBookingDate\&#39; is equal to or later than the given date will be regarded.
     * @param {string} [maxBankBookingDate] Upper bound for a transaction\&#39;s booking date as returned by the bank (&#x3D; original booking date), in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;bankBookingDate\&#39; is equal to or earlier than the given date will be regarded.
     * @param {string} [minFinapiBookingDate] Lower bound for a transaction\&#39;s booking date as set by finAPI, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). For details about the meaning of the finAPI booking date, please see the field\&#39;s documentation in the service\&#39;s response.
     * @param {string} [maxFinapiBookingDate] Upper bound for a transaction\&#39;s booking date as set by finAPI, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). For details about the meaning of the finAPI booking date, please see the field\&#39;s documentation in the service\&#39;s response.
     * @param {number} [minAmount] If specified, then only transactions whose amount is equal to or greater than the given amount will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
     * @param {number} [maxAmount] If specified, then only transactions whose amount is equal to or less than the given amount will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
     * @param {'all' | 'income' | 'spending'} [direction] If specified, then only transactions with the given direction(s) will be regarded. Use \&#39;income\&#39; for regarding only received payments (amount &gt;&#x3D; 0), \&#39;spending\&#39; for regarding only outgoing payments (amount &lt; 0), or \&#39;all\&#39; to regard both directions. If not specified, the direction defaults to \&#39;all\&#39;.
     * @param {Array<number>} [labelIds] A comma-separated list of label identifiers. If specified, then only transactions that have been marked with at least one of the given labels will be contained in the result.
     * @param {Array<number>} [categoryIds] If specified, then the result will contain only those cash flows that relate to the given categories. Note that the cash flow for a category may include/exclude the cash flows of its sub-categories, depending on the \&#39;includeSubCashFlows\&#39; setting. To include the cash flow of not categorized transactions, pass the value \&#39;0\&#39; as categoryId. Note: When this parameter is NOT set, then the result will contain a cash flow for all categories that have transactions associated to them (this includes the \&#39;null\&#39;-category for the cash flow of not categorized transactions), more precisely: transactions that fulfill the filter criteria. Categories that have no associated transactions according to the filter criteria will not appear in the result. However, when you specify this parameter, then all specified categories will have a cash flow entry in the result, even if there are no associated transactions for the category (the cash flow will have income, spending and balance all set to zero).
     * @param {boolean} [isNew] If specified, then only transactions that have their \&#39;isNew\&#39; flag set to true/false will be regarded for the cash flow calculations.
     * @param {string} [minImportDate] Lower bound for a transaction\&#39;s import date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;importDate\&#39; is equal to or later than the given date will be regarded.
     * @param {string} [maxImportDate] Upper bound for a transaction\&#39;s import date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;importDate\&#39; is equal to or earlier than the given date will be regarded.
     * @param {boolean} [includeSubCashFlows] If it is true, then the income, spending, balance and count of transactions of a main category results from all transactions that have either this (main) category or any of its subcategories assigned (of course all transactions depends from the other filtering settings); If it is false, then the income, spending, balance and count of transactions of a main category only results from the transactions that have exactly this (main) category assigned. Default value for this parameter is \&#39;true\&#39;.
     * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;income\&#39;, \&#39;spending\&#39;, \&#39;balance\&#39;, \&#39;category.id\&#39; or \&#39;category.name\&#39;. The default order for this service is \&#39;category.id,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: \&#39;/cashFlows?order&#x3D;income,desc&amp;order&#x3D;spending,asc&amp;balance,desc\&#39; will return as first result the category with the highest income. If two categories have the same income, it returns the category with the highest spending first (because spending is a negative value) and so on. The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCashFlows(
      search?: string,
      counterpart?: string,
      purpose?: string,
      accountIds?: Array<number>,
      minBankBookingDate?: string,
      maxBankBookingDate?: string,
      minFinapiBookingDate?: string,
      maxFinapiBookingDate?: string,
      minAmount?: number,
      maxAmount?: number,
      direction?: "all" | "income" | "spending",
      labelIds?: Array<number>,
      categoryIds?: Array<number>,
      isNew?: boolean,
      minImportDate?: string,
      maxImportDate?: string,
      includeSubCashFlows?: boolean,
      order?: Array<string>,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/api/v1/categories/cashFlows`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      if (search !== undefined) {
        localVarQueryParameter["search"] = search;
      }

      if (counterpart !== undefined) {
        localVarQueryParameter["counterpart"] = counterpart;
      }

      if (purpose !== undefined) {
        localVarQueryParameter["purpose"] = purpose;
      }

      if (accountIds) {
        localVarQueryParameter["accountIds"] = accountIds;
      }

      if (minBankBookingDate !== undefined) {
        localVarQueryParameter["minBankBookingDate"] = minBankBookingDate;
      }

      if (maxBankBookingDate !== undefined) {
        localVarQueryParameter["maxBankBookingDate"] = maxBankBookingDate;
      }

      if (minFinapiBookingDate !== undefined) {
        localVarQueryParameter["minFinapiBookingDate"] = minFinapiBookingDate;
      }

      if (maxFinapiBookingDate !== undefined) {
        localVarQueryParameter["maxFinapiBookingDate"] = maxFinapiBookingDate;
      }

      if (minAmount !== undefined) {
        localVarQueryParameter["minAmount"] = minAmount;
      }

      if (maxAmount !== undefined) {
        localVarQueryParameter["maxAmount"] = maxAmount;
      }

      if (direction !== undefined) {
        localVarQueryParameter["direction"] = direction;
      }

      if (labelIds) {
        localVarQueryParameter["labelIds"] = labelIds;
      }

      if (categoryIds) {
        localVarQueryParameter["categoryIds"] = categoryIds;
      }

      if (isNew !== undefined) {
        localVarQueryParameter["isNew"] = isNew;
      }

      if (minImportDate !== undefined) {
        localVarQueryParameter["minImportDate"] = minImportDate;
      }

      if (maxImportDate !== undefined) {
        localVarQueryParameter["maxImportDate"] = maxImportDate;
      }

      if (includeSubCashFlows !== undefined) {
        localVarQueryParameter["includeSubCashFlows"] = includeSubCashFlows;
      }

      if (order) {
        localVarQueryParameter["order"] = order;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a single category that is either a global finAPI category or a custom category of the authorized user. Must pass the category\'s identifier and the user\'s access_token.
     * @summary Get a category
     * @param {number} id Category identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCategory(id: number, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getCategory."
        );
      }
      const localVarPath = `/api/v1/categories/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a list of multiple categories that are either a global finAPI category or a custom category of the authorized user. Must pass the categories\' identifiers and the user\'s access_token. Categories whose identifiers do not exist or that relate to a different user not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). WARNING: This service is deprecated and will be removed at some point. If you want to get multiple categories, please instead use the service \'Get and search all categories\' and pass a comma-separated list of identifiers as a parameter \'ids\'.
     * @summary Get multiple categories
     * @param {Array<number>} ids Comma-separated list of identifiers of requested categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleCategories(ids: Array<number>, options: any = {}): RequestArgs {
      // verify required parameter 'ids' is not null or undefined
      if (ids === null || ids === undefined) {
        throw new RequiredError(
          "ids",
          "Required parameter ids was null or undefined when calling getMultipleCategories."
        );
      }
      const localVarPath = `/api/v1/categories/{ids}`.replace(
        `{${"ids"}}`,
        encodeURIComponent(String(ids))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * This service allows you to create user-specific categorization rules (for the user that is authorized by the access_token). Pass a categorization sample (=set of transaction data and a target category), and finAPI will train the user\'s categorization rules so that similar transactions will be categorized accordingly in future. Basically, this service behaves the same as when assigning categories to existing transactions via the \'Edit a transaction\' service, with the difference that you can directly pass transaction data to this service, without the need of having any transactions actually imported in finAPI. Must pass the user\'s access_token.
     * @summary Train categorization
     * @param {TrainCategorizationData} [body] Categorization sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trainCategorization(
      body?: TrainCategorizationData,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/api/v1/categories/trainCategorization`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"TrainCategorizationData" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Create a new custom transaction category for the authorized user, that can then be assigned to transactions via PATCH /transactions, and that will also be regarded in finAPI\'s automatic transactions categorization process. Must pass the user\'s access_token.
     * @summary Create a new category
     * @param {CategoryParams} [body] Parameters of the new category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCategory(
      body?: CategoryParams,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category> {
      const localVarAxiosArgs = CategoriesApiAxiosParamCreator(
        configuration
      ).createCategory(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Delete all custom categories of the user that is authorized by the access_token. Must pass the user\'s access_token. Note that this deletes both parent categories as well as any related sub-categories.
     * @summary Delete all categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllCategories(
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<IdentifierList> {
      const localVarAxiosArgs = CategoriesApiAxiosParamCreator(
        configuration
      ).deleteAllCategories(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Delete a single category of the user that is authorized by the access_token. Must pass the user\'s access_token. Note that you can only delete user-custom categories (category\'s where the \'isCustom\' flag is true). Also note that when deleting a parent category, all its sub-categories will be deleted as well.
     * @summary Delete a category
     * @param {number} id Category identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCategory(
      id: number,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = CategoriesApiAxiosParamCreator(
        configuration
      ).deleteCategory(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Change the name of a custom transaction category belonging to the authorized user. Must pass the user\'s access_token.
     * @summary Edit a category
     * @param {number} id Identifier of the category to edit
     * @param {EditCategoryParams} [body] New category name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editCategory(
      id: number,
      body?: EditCategoryParams,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category> {
      const localVarAxiosArgs = CategoriesApiAxiosParamCreator(
        configuration
      ).editCategory(id, body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get a list of all global finAPI categories as well as all custom categories of the authorized user. Must pass the user\'s access_token. You can set optional search criteria to get only those categories that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get and search all categories
     * @param {Array<number>} [ids] A comma-separated list of category identifiers. If specified, then only categories whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {string} [search] If specified, then only those categories will be contained in the result whose \&#39;name\&#39; contains the given search string (the matching works case-insensitive). If no categories contain the search string in their name, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the name in order for a category to get included into the result.
     * @param {boolean} [isCustom] If specified, then the result will contain only categories that are either finAPI global (in case of value \&#39;false\&#39;), or only categories that have been created by the authorized user (in case of value \&#39;true\&#39;).
     * @param {number} [page] Result page that you want to retrieve.
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;id\&#39;, \&#39;name\&#39; and \&#39;isCustom\&#39;. The default order is \&#39;id,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: \&#39;/categories?order&#x3D;isCustom,desc&amp;order&#x3D;name\&#39; will return all custom categories followed by all default categories. Both groups are ordered ascending by name. The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchAllCategories(
      ids?: Array<number>,
      search?: string,
      isCustom?: boolean,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<PageableCategoryList> {
      const localVarAxiosArgs = CategoriesApiAxiosParamCreator(
        configuration
      ).getAndSearchAllCategories(
        ids,
        search,
        isCustom,
        page,
        perPage,
        order,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get the cash flow(s) (= total income, spending, and balance) for one or several categories. You can specify various criteria such as the time period to calculate the cash flows for, or what categories to do the calculations for. Note that the cash flow for a category may include the cash flows for all of its sub-categories, or not include it, depending on the \'includeSubCashFlows\' setting. Must pass the user\'s access_token.
     * @summary Get cash flows
     * @param {string} [search] If specified, then only transactions that contain the search term in their purpose or counterpart fields will be contained in the result. Note that the search is case insensitive.
     * @param {string} [counterpart] The counterpart is the person or institution that received your payment, or that you made the payment to. If this parameter is specified, then only transactions that contain the given term in one (or more) of their counterpart fields (\&#39;counterpartName\&#39;, \&#39;counterpartAccountNumber\&#39;, \&#39;counterpartIban\&#39;, \&#39;counterpartBic\&#39; or \&#39;counterpartBlz\&#39;) will be contained in the result. Note that the search is case insensitive.
     * @param {string} [purpose] If specified, then only those transactions will be contained in the result whose purpose field contains the given search string. Note that the search is case insensitive.NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the purpose in order for a transaction to get included into the result.
     * @param {Array<number>} [accountIds] A comma-separated list of account identifiers. If specified, then only transactions that relate to the given accounts will be regarded. If not specified, then all accounts will be regarded.
     * @param {string} [minBankBookingDate] Lower bound for a transaction\&#39;s booking date as returned by the bank (&#x3D; original booking date), in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;bankBookingDate\&#39; is equal to or later than the given date will be regarded.
     * @param {string} [maxBankBookingDate] Upper bound for a transaction\&#39;s booking date as returned by the bank (&#x3D; original booking date), in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;bankBookingDate\&#39; is equal to or earlier than the given date will be regarded.
     * @param {string} [minFinapiBookingDate] Lower bound for a transaction\&#39;s booking date as set by finAPI, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). For details about the meaning of the finAPI booking date, please see the field\&#39;s documentation in the service\&#39;s response.
     * @param {string} [maxFinapiBookingDate] Upper bound for a transaction\&#39;s booking date as set by finAPI, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). For details about the meaning of the finAPI booking date, please see the field\&#39;s documentation in the service\&#39;s response.
     * @param {number} [minAmount] If specified, then only transactions whose amount is equal to or greater than the given amount will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
     * @param {number} [maxAmount] If specified, then only transactions whose amount is equal to or less than the given amount will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
     * @param {'all' | 'income' | 'spending'} [direction] If specified, then only transactions with the given direction(s) will be regarded. Use \&#39;income\&#39; for regarding only received payments (amount &gt;&#x3D; 0), \&#39;spending\&#39; for regarding only outgoing payments (amount &lt; 0), or \&#39;all\&#39; to regard both directions. If not specified, the direction defaults to \&#39;all\&#39;.
     * @param {Array<number>} [labelIds] A comma-separated list of label identifiers. If specified, then only transactions that have been marked with at least one of the given labels will be contained in the result.
     * @param {Array<number>} [categoryIds] If specified, then the result will contain only those cash flows that relate to the given categories. Note that the cash flow for a category may include/exclude the cash flows of its sub-categories, depending on the \&#39;includeSubCashFlows\&#39; setting. To include the cash flow of not categorized transactions, pass the value \&#39;0\&#39; as categoryId. Note: When this parameter is NOT set, then the result will contain a cash flow for all categories that have transactions associated to them (this includes the \&#39;null\&#39;-category for the cash flow of not categorized transactions), more precisely: transactions that fulfill the filter criteria. Categories that have no associated transactions according to the filter criteria will not appear in the result. However, when you specify this parameter, then all specified categories will have a cash flow entry in the result, even if there are no associated transactions for the category (the cash flow will have income, spending and balance all set to zero).
     * @param {boolean} [isNew] If specified, then only transactions that have their \&#39;isNew\&#39; flag set to true/false will be regarded for the cash flow calculations.
     * @param {string} [minImportDate] Lower bound for a transaction\&#39;s import date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;importDate\&#39; is equal to or later than the given date will be regarded.
     * @param {string} [maxImportDate] Upper bound for a transaction\&#39;s import date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;importDate\&#39; is equal to or earlier than the given date will be regarded.
     * @param {boolean} [includeSubCashFlows] If it is true, then the income, spending, balance and count of transactions of a main category results from all transactions that have either this (main) category or any of its subcategories assigned (of course all transactions depends from the other filtering settings); If it is false, then the income, spending, balance and count of transactions of a main category only results from the transactions that have exactly this (main) category assigned. Default value for this parameter is \&#39;true\&#39;.
     * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;income\&#39;, \&#39;spending\&#39;, \&#39;balance\&#39;, \&#39;category.id\&#39; or \&#39;category.name\&#39;. The default order for this service is \&#39;category.id,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: \&#39;/cashFlows?order&#x3D;income,desc&amp;order&#x3D;spending,asc&amp;balance,desc\&#39; will return as first result the category with the highest income. If two categories have the same income, it returns the category with the highest spending first (because spending is a negative value) and so on. The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCashFlows(
      search?: string,
      counterpart?: string,
      purpose?: string,
      accountIds?: Array<number>,
      minBankBookingDate?: string,
      maxBankBookingDate?: string,
      minFinapiBookingDate?: string,
      maxFinapiBookingDate?: string,
      minAmount?: number,
      maxAmount?: number,
      direction?: "all" | "income" | "spending",
      labelIds?: Array<number>,
      categoryIds?: Array<number>,
      isNew?: boolean,
      minImportDate?: string,
      maxImportDate?: string,
      includeSubCashFlows?: boolean,
      order?: Array<string>,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<CashFlowList> {
      const localVarAxiosArgs = CategoriesApiAxiosParamCreator(
        configuration
      ).getCashFlows(
        search,
        counterpart,
        purpose,
        accountIds,
        minBankBookingDate,
        maxBankBookingDate,
        minFinapiBookingDate,
        maxFinapiBookingDate,
        minAmount,
        maxAmount,
        direction,
        labelIds,
        categoryIds,
        isNew,
        minImportDate,
        maxImportDate,
        includeSubCashFlows,
        order,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get a single category that is either a global finAPI category or a custom category of the authorized user. Must pass the category\'s identifier and the user\'s access_token.
     * @summary Get a category
     * @param {number} id Category identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCategory(
      id: number,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category> {
      const localVarAxiosArgs = CategoriesApiAxiosParamCreator(
        configuration
      ).getCategory(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get a list of multiple categories that are either a global finAPI category or a custom category of the authorized user. Must pass the categories\' identifiers and the user\'s access_token. Categories whose identifiers do not exist or that relate to a different user not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). WARNING: This service is deprecated and will be removed at some point. If you want to get multiple categories, please instead use the service \'Get and search all categories\' and pass a comma-separated list of identifiers as a parameter \'ids\'.
     * @summary Get multiple categories
     * @param {Array<number>} ids Comma-separated list of identifiers of requested categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleCategories(
      ids: Array<number>,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<CategoryList> {
      const localVarAxiosArgs = CategoriesApiAxiosParamCreator(
        configuration
      ).getMultipleCategories(ids, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This service allows you to create user-specific categorization rules (for the user that is authorized by the access_token). Pass a categorization sample (=set of transaction data and a target category), and finAPI will train the user\'s categorization rules so that similar transactions will be categorized accordingly in future. Basically, this service behaves the same as when assigning categories to existing transactions via the \'Edit a transaction\' service, with the difference that you can directly pass transaction data to this service, without the need of having any transactions actually imported in finAPI. Must pass the user\'s access_token.
     * @summary Train categorization
     * @param {TrainCategorizationData} [body] Categorization sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trainCategorization(
      body?: TrainCategorizationData,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = CategoriesApiAxiosParamCreator(
        configuration
      ).trainCategorization(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    }
  };
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Create a new custom transaction category for the authorized user, that can then be assigned to transactions via PATCH /transactions, and that will also be regarded in finAPI\'s automatic transactions categorization process. Must pass the user\'s access_token.
     * @summary Create a new category
     * @param {CategoryParams} [body] Parameters of the new category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCategory(body?: CategoryParams, options?: any) {
      return CategoriesApiFp(configuration).createCategory(body, options)(
        axios,
        basePath
      );
    },
    /**
     * Delete all custom categories of the user that is authorized by the access_token. Must pass the user\'s access_token. Note that this deletes both parent categories as well as any related sub-categories.
     * @summary Delete all categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllCategories(options?: any) {
      return CategoriesApiFp(configuration).deleteAllCategories(options)(
        axios,
        basePath
      );
    },
    /**
     * Delete a single category of the user that is authorized by the access_token. Must pass the user\'s access_token. Note that you can only delete user-custom categories (category\'s where the \'isCustom\' flag is true). Also note that when deleting a parent category, all its sub-categories will be deleted as well.
     * @summary Delete a category
     * @param {number} id Category identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCategory(id: number, options?: any) {
      return CategoriesApiFp(configuration).deleteCategory(id, options)(
        axios,
        basePath
      );
    },
    /**
     * Change the name of a custom transaction category belonging to the authorized user. Must pass the user\'s access_token.
     * @summary Edit a category
     * @param {number} id Identifier of the category to edit
     * @param {EditCategoryParams} [body] New category name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editCategory(id: number, body?: EditCategoryParams, options?: any) {
      return CategoriesApiFp(configuration).editCategory(id, body, options)(
        axios,
        basePath
      );
    },
    /**
     * Get a list of all global finAPI categories as well as all custom categories of the authorized user. Must pass the user\'s access_token. You can set optional search criteria to get only those categories that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get and search all categories
     * @param {Array<number>} [ids] A comma-separated list of category identifiers. If specified, then only categories whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {string} [search] If specified, then only those categories will be contained in the result whose \&#39;name\&#39; contains the given search string (the matching works case-insensitive). If no categories contain the search string in their name, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the name in order for a category to get included into the result.
     * @param {boolean} [isCustom] If specified, then the result will contain only categories that are either finAPI global (in case of value \&#39;false\&#39;), or only categories that have been created by the authorized user (in case of value \&#39;true\&#39;).
     * @param {number} [page] Result page that you want to retrieve.
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;id\&#39;, \&#39;name\&#39; and \&#39;isCustom\&#39;. The default order is \&#39;id,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: \&#39;/categories?order&#x3D;isCustom,desc&amp;order&#x3D;name\&#39; will return all custom categories followed by all default categories. Both groups are ordered ascending by name. The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchAllCategories(
      ids?: Array<number>,
      search?: string,
      isCustom?: boolean,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options?: any
    ) {
      return CategoriesApiFp(configuration).getAndSearchAllCategories(
        ids,
        search,
        isCustom,
        page,
        perPage,
        order,
        options
      )(axios, basePath);
    },
    /**
     * Get the cash flow(s) (= total income, spending, and balance) for one or several categories. You can specify various criteria such as the time period to calculate the cash flows for, or what categories to do the calculations for. Note that the cash flow for a category may include the cash flows for all of its sub-categories, or not include it, depending on the \'includeSubCashFlows\' setting. Must pass the user\'s access_token.
     * @summary Get cash flows
     * @param {string} [search] If specified, then only transactions that contain the search term in their purpose or counterpart fields will be contained in the result. Note that the search is case insensitive.
     * @param {string} [counterpart] The counterpart is the person or institution that received your payment, or that you made the payment to. If this parameter is specified, then only transactions that contain the given term in one (or more) of their counterpart fields (\&#39;counterpartName\&#39;, \&#39;counterpartAccountNumber\&#39;, \&#39;counterpartIban\&#39;, \&#39;counterpartBic\&#39; or \&#39;counterpartBlz\&#39;) will be contained in the result. Note that the search is case insensitive.
     * @param {string} [purpose] If specified, then only those transactions will be contained in the result whose purpose field contains the given search string. Note that the search is case insensitive.NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the purpose in order for a transaction to get included into the result.
     * @param {Array<number>} [accountIds] A comma-separated list of account identifiers. If specified, then only transactions that relate to the given accounts will be regarded. If not specified, then all accounts will be regarded.
     * @param {string} [minBankBookingDate] Lower bound for a transaction\&#39;s booking date as returned by the bank (&#x3D; original booking date), in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;bankBookingDate\&#39; is equal to or later than the given date will be regarded.
     * @param {string} [maxBankBookingDate] Upper bound for a transaction\&#39;s booking date as returned by the bank (&#x3D; original booking date), in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;bankBookingDate\&#39; is equal to or earlier than the given date will be regarded.
     * @param {string} [minFinapiBookingDate] Lower bound for a transaction\&#39;s booking date as set by finAPI, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). For details about the meaning of the finAPI booking date, please see the field\&#39;s documentation in the service\&#39;s response.
     * @param {string} [maxFinapiBookingDate] Upper bound for a transaction\&#39;s booking date as set by finAPI, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). For details about the meaning of the finAPI booking date, please see the field\&#39;s documentation in the service\&#39;s response.
     * @param {number} [minAmount] If specified, then only transactions whose amount is equal to or greater than the given amount will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
     * @param {number} [maxAmount] If specified, then only transactions whose amount is equal to or less than the given amount will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
     * @param {'all' | 'income' | 'spending'} [direction] If specified, then only transactions with the given direction(s) will be regarded. Use \&#39;income\&#39; for regarding only received payments (amount &gt;&#x3D; 0), \&#39;spending\&#39; for regarding only outgoing payments (amount &lt; 0), or \&#39;all\&#39; to regard both directions. If not specified, the direction defaults to \&#39;all\&#39;.
     * @param {Array<number>} [labelIds] A comma-separated list of label identifiers. If specified, then only transactions that have been marked with at least one of the given labels will be contained in the result.
     * @param {Array<number>} [categoryIds] If specified, then the result will contain only those cash flows that relate to the given categories. Note that the cash flow for a category may include/exclude the cash flows of its sub-categories, depending on the \&#39;includeSubCashFlows\&#39; setting. To include the cash flow of not categorized transactions, pass the value \&#39;0\&#39; as categoryId. Note: When this parameter is NOT set, then the result will contain a cash flow for all categories that have transactions associated to them (this includes the \&#39;null\&#39;-category for the cash flow of not categorized transactions), more precisely: transactions that fulfill the filter criteria. Categories that have no associated transactions according to the filter criteria will not appear in the result. However, when you specify this parameter, then all specified categories will have a cash flow entry in the result, even if there are no associated transactions for the category (the cash flow will have income, spending and balance all set to zero).
     * @param {boolean} [isNew] If specified, then only transactions that have their \&#39;isNew\&#39; flag set to true/false will be regarded for the cash flow calculations.
     * @param {string} [minImportDate] Lower bound for a transaction\&#39;s import date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;importDate\&#39; is equal to or later than the given date will be regarded.
     * @param {string} [maxImportDate] Upper bound for a transaction\&#39;s import date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;importDate\&#39; is equal to or earlier than the given date will be regarded.
     * @param {boolean} [includeSubCashFlows] If it is true, then the income, spending, balance and count of transactions of a main category results from all transactions that have either this (main) category or any of its subcategories assigned (of course all transactions depends from the other filtering settings); If it is false, then the income, spending, balance and count of transactions of a main category only results from the transactions that have exactly this (main) category assigned. Default value for this parameter is \&#39;true\&#39;.
     * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;income\&#39;, \&#39;spending\&#39;, \&#39;balance\&#39;, \&#39;category.id\&#39; or \&#39;category.name\&#39;. The default order for this service is \&#39;category.id,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: \&#39;/cashFlows?order&#x3D;income,desc&amp;order&#x3D;spending,asc&amp;balance,desc\&#39; will return as first result the category with the highest income. If two categories have the same income, it returns the category with the highest spending first (because spending is a negative value) and so on. The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCashFlows(
      search?: string,
      counterpart?: string,
      purpose?: string,
      accountIds?: Array<number>,
      minBankBookingDate?: string,
      maxBankBookingDate?: string,
      minFinapiBookingDate?: string,
      maxFinapiBookingDate?: string,
      minAmount?: number,
      maxAmount?: number,
      direction?: "all" | "income" | "spending",
      labelIds?: Array<number>,
      categoryIds?: Array<number>,
      isNew?: boolean,
      minImportDate?: string,
      maxImportDate?: string,
      includeSubCashFlows?: boolean,
      order?: Array<string>,
      options?: any
    ) {
      return CategoriesApiFp(configuration).getCashFlows(
        search,
        counterpart,
        purpose,
        accountIds,
        minBankBookingDate,
        maxBankBookingDate,
        minFinapiBookingDate,
        maxFinapiBookingDate,
        minAmount,
        maxAmount,
        direction,
        labelIds,
        categoryIds,
        isNew,
        minImportDate,
        maxImportDate,
        includeSubCashFlows,
        order,
        options
      )(axios, basePath);
    },
    /**
     * Get a single category that is either a global finAPI category or a custom category of the authorized user. Must pass the category\'s identifier and the user\'s access_token.
     * @summary Get a category
     * @param {number} id Category identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCategory(id: number, options?: any) {
      return CategoriesApiFp(configuration).getCategory(id, options)(
        axios,
        basePath
      );
    },
    /**
     * Get a list of multiple categories that are either a global finAPI category or a custom category of the authorized user. Must pass the categories\' identifiers and the user\'s access_token. Categories whose identifiers do not exist or that relate to a different user not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). WARNING: This service is deprecated and will be removed at some point. If you want to get multiple categories, please instead use the service \'Get and search all categories\' and pass a comma-separated list of identifiers as a parameter \'ids\'.
     * @summary Get multiple categories
     * @param {Array<number>} ids Comma-separated list of identifiers of requested categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleCategories(ids: Array<number>, options?: any) {
      return CategoriesApiFp(configuration).getMultipleCategories(ids, options)(
        axios,
        basePath
      );
    },
    /**
     * This service allows you to create user-specific categorization rules (for the user that is authorized by the access_token). Pass a categorization sample (=set of transaction data and a target category), and finAPI will train the user\'s categorization rules so that similar transactions will be categorized accordingly in future. Basically, this service behaves the same as when assigning categories to existing transactions via the \'Edit a transaction\' service, with the difference that you can directly pass transaction data to this service, without the need of having any transactions actually imported in finAPI. Must pass the user\'s access_token.
     * @summary Train categorization
     * @param {TrainCategorizationData} [body] Categorization sample
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trainCategorization(body?: TrainCategorizationData, options?: any) {
      return CategoriesApiFp(configuration).trainCategorization(body, options)(
        axios,
        basePath
      );
    }
  };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
  /**
   * Create a new custom transaction category for the authorized user, that can then be assigned to transactions via PATCH /transactions, and that will also be regarded in finAPI\'s automatic transactions categorization process. Must pass the user\'s access_token.
   * @summary Create a new category
   * @param {CategoryParams} [body] Parameters of the new category
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoriesApi
   */
  public createCategory(body?: CategoryParams, options?: any) {
    return CategoriesApiFp(this.configuration).createCategory(body, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Delete all custom categories of the user that is authorized by the access_token. Must pass the user\'s access_token. Note that this deletes both parent categories as well as any related sub-categories.
   * @summary Delete all categories
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoriesApi
   */
  public deleteAllCategories(options?: any) {
    return CategoriesApiFp(this.configuration).deleteAllCategories(options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Delete a single category of the user that is authorized by the access_token. Must pass the user\'s access_token. Note that you can only delete user-custom categories (category\'s where the \'isCustom\' flag is true). Also note that when deleting a parent category, all its sub-categories will be deleted as well.
   * @summary Delete a category
   * @param {number} id Category identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoriesApi
   */
  public deleteCategory(id: number, options?: any) {
    return CategoriesApiFp(this.configuration).deleteCategory(id, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Change the name of a custom transaction category belonging to the authorized user. Must pass the user\'s access_token.
   * @summary Edit a category
   * @param {number} id Identifier of the category to edit
   * @param {EditCategoryParams} [body] New category name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoriesApi
   */
  public editCategory(id: number, body?: EditCategoryParams, options?: any) {
    return CategoriesApiFp(this.configuration).editCategory(id, body, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Get a list of all global finAPI categories as well as all custom categories of the authorized user. Must pass the user\'s access_token. You can set optional search criteria to get only those categories that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
   * @summary Get and search all categories
   * @param {Array<number>} [ids] A comma-separated list of category identifiers. If specified, then only categories whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
   * @param {string} [search] If specified, then only those categories will be contained in the result whose \&#39;name\&#39; contains the given search string (the matching works case-insensitive). If no categories contain the search string in their name, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the name in order for a category to get included into the result.
   * @param {boolean} [isCustom] If specified, then the result will contain only categories that are either finAPI global (in case of value \&#39;false\&#39;), or only categories that have been created by the authorized user (in case of value \&#39;true\&#39;).
   * @param {number} [page] Result page that you want to retrieve.
   * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
   * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;id\&#39;, \&#39;name\&#39; and \&#39;isCustom\&#39;. The default order is \&#39;id,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: \&#39;/categories?order&#x3D;isCustom,desc&amp;order&#x3D;name\&#39; will return all custom categories followed by all default categories. Both groups are ordered ascending by name. The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoriesApi
   */
  public getAndSearchAllCategories(
    ids?: Array<number>,
    search?: string,
    isCustom?: boolean,
    page?: number,
    perPage?: number,
    order?: Array<string>,
    options?: any
  ) {
    return CategoriesApiFp(this.configuration).getAndSearchAllCategories(
      ids,
      search,
      isCustom,
      page,
      perPage,
      order,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Get the cash flow(s) (= total income, spending, and balance) for one or several categories. You can specify various criteria such as the time period to calculate the cash flows for, or what categories to do the calculations for. Note that the cash flow for a category may include the cash flows for all of its sub-categories, or not include it, depending on the \'includeSubCashFlows\' setting. Must pass the user\'s access_token.
   * @summary Get cash flows
   * @param {string} [search] If specified, then only transactions that contain the search term in their purpose or counterpart fields will be contained in the result. Note that the search is case insensitive.
   * @param {string} [counterpart] The counterpart is the person or institution that received your payment, or that you made the payment to. If this parameter is specified, then only transactions that contain the given term in one (or more) of their counterpart fields (\&#39;counterpartName\&#39;, \&#39;counterpartAccountNumber\&#39;, \&#39;counterpartIban\&#39;, \&#39;counterpartBic\&#39; or \&#39;counterpartBlz\&#39;) will be contained in the result. Note that the search is case insensitive.
   * @param {string} [purpose] If specified, then only those transactions will be contained in the result whose purpose field contains the given search string. Note that the search is case insensitive.NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the purpose in order for a transaction to get included into the result.
   * @param {Array<number>} [accountIds] A comma-separated list of account identifiers. If specified, then only transactions that relate to the given accounts will be regarded. If not specified, then all accounts will be regarded.
   * @param {string} [minBankBookingDate] Lower bound for a transaction\&#39;s booking date as returned by the bank (&#x3D; original booking date), in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;bankBookingDate\&#39; is equal to or later than the given date will be regarded.
   * @param {string} [maxBankBookingDate] Upper bound for a transaction\&#39;s booking date as returned by the bank (&#x3D; original booking date), in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;bankBookingDate\&#39; is equal to or earlier than the given date will be regarded.
   * @param {string} [minFinapiBookingDate] Lower bound for a transaction\&#39;s booking date as set by finAPI, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). For details about the meaning of the finAPI booking date, please see the field\&#39;s documentation in the service\&#39;s response.
   * @param {string} [maxFinapiBookingDate] Upper bound for a transaction\&#39;s booking date as set by finAPI, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). For details about the meaning of the finAPI booking date, please see the field\&#39;s documentation in the service\&#39;s response.
   * @param {number} [minAmount] If specified, then only transactions whose amount is equal to or greater than the given amount will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
   * @param {number} [maxAmount] If specified, then only transactions whose amount is equal to or less than the given amount will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
   * @param {'all' | 'income' | 'spending'} [direction] If specified, then only transactions with the given direction(s) will be regarded. Use \&#39;income\&#39; for regarding only received payments (amount &gt;&#x3D; 0), \&#39;spending\&#39; for regarding only outgoing payments (amount &lt; 0), or \&#39;all\&#39; to regard both directions. If not specified, the direction defaults to \&#39;all\&#39;.
   * @param {Array<number>} [labelIds] A comma-separated list of label identifiers. If specified, then only transactions that have been marked with at least one of the given labels will be contained in the result.
   * @param {Array<number>} [categoryIds] If specified, then the result will contain only those cash flows that relate to the given categories. Note that the cash flow for a category may include/exclude the cash flows of its sub-categories, depending on the \&#39;includeSubCashFlows\&#39; setting. To include the cash flow of not categorized transactions, pass the value \&#39;0\&#39; as categoryId. Note: When this parameter is NOT set, then the result will contain a cash flow for all categories that have transactions associated to them (this includes the \&#39;null\&#39;-category for the cash flow of not categorized transactions), more precisely: transactions that fulfill the filter criteria. Categories that have no associated transactions according to the filter criteria will not appear in the result. However, when you specify this parameter, then all specified categories will have a cash flow entry in the result, even if there are no associated transactions for the category (the cash flow will have income, spending and balance all set to zero).
   * @param {boolean} [isNew] If specified, then only transactions that have their \&#39;isNew\&#39; flag set to true/false will be regarded for the cash flow calculations.
   * @param {string} [minImportDate] Lower bound for a transaction\&#39;s import date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;importDate\&#39; is equal to or later than the given date will be regarded.
   * @param {string} [maxImportDate] Upper bound for a transaction\&#39;s import date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;importDate\&#39; is equal to or earlier than the given date will be regarded.
   * @param {boolean} [includeSubCashFlows] If it is true, then the income, spending, balance and count of transactions of a main category results from all transactions that have either this (main) category or any of its subcategories assigned (of course all transactions depends from the other filtering settings); If it is false, then the income, spending, balance and count of transactions of a main category only results from the transactions that have exactly this (main) category assigned. Default value for this parameter is \&#39;true\&#39;.
   * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;income\&#39;, \&#39;spending\&#39;, \&#39;balance\&#39;, \&#39;category.id\&#39; or \&#39;category.name\&#39;. The default order for this service is \&#39;category.id,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: \&#39;/cashFlows?order&#x3D;income,desc&amp;order&#x3D;spending,asc&amp;balance,desc\&#39; will return as first result the category with the highest income. If two categories have the same income, it returns the category with the highest spending first (because spending is a negative value) and so on. The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoriesApi
   */
  public getCashFlows(
    search?: string,
    counterpart?: string,
    purpose?: string,
    accountIds?: Array<number>,
    minBankBookingDate?: string,
    maxBankBookingDate?: string,
    minFinapiBookingDate?: string,
    maxFinapiBookingDate?: string,
    minAmount?: number,
    maxAmount?: number,
    direction?: "all" | "income" | "spending",
    labelIds?: Array<number>,
    categoryIds?: Array<number>,
    isNew?: boolean,
    minImportDate?: string,
    maxImportDate?: string,
    includeSubCashFlows?: boolean,
    order?: Array<string>,
    options?: any
  ) {
    return CategoriesApiFp(this.configuration).getCashFlows(
      search,
      counterpart,
      purpose,
      accountIds,
      minBankBookingDate,
      maxBankBookingDate,
      minFinapiBookingDate,
      maxFinapiBookingDate,
      minAmount,
      maxAmount,
      direction,
      labelIds,
      categoryIds,
      isNew,
      minImportDate,
      maxImportDate,
      includeSubCashFlows,
      order,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Get a single category that is either a global finAPI category or a custom category of the authorized user. Must pass the category\'s identifier and the user\'s access_token.
   * @summary Get a category
   * @param {number} id Category identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoriesApi
   */
  public getCategory(id: number, options?: any) {
    return CategoriesApiFp(this.configuration).getCategory(id, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Get a list of multiple categories that are either a global finAPI category or a custom category of the authorized user. Must pass the categories\' identifiers and the user\'s access_token. Categories whose identifiers do not exist or that relate to a different user not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). WARNING: This service is deprecated and will be removed at some point. If you want to get multiple categories, please instead use the service \'Get and search all categories\' and pass a comma-separated list of identifiers as a parameter \'ids\'.
   * @summary Get multiple categories
   * @param {Array<number>} ids Comma-separated list of identifiers of requested categories
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoriesApi
   */
  public getMultipleCategories(ids: Array<number>, options?: any) {
    return CategoriesApiFp(this.configuration).getMultipleCategories(
      ids,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This service allows you to create user-specific categorization rules (for the user that is authorized by the access_token). Pass a categorization sample (=set of transaction data and a target category), and finAPI will train the user\'s categorization rules so that similar transactions will be categorized accordingly in future. Basically, this service behaves the same as when assigning categories to existing transactions via the \'Edit a transaction\' service, with the difference that you can directly pass transaction data to this service, without the need of having any transactions actually imported in finAPI. Must pass the user\'s access_token.
   * @summary Train categorization
   * @param {TrainCategorizationData} [body] Categorization sample
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CategoriesApi
   */
  public trainCategorization(body?: TrainCategorizationData, options?: any) {
    return CategoriesApiFp(this.configuration).trainCategorization(
      body,
      options
    )(this.axios, this.basePath);
  }
}

/**
 * ClientConfigurationApi - axios parameter creator
 * @export
 */
export const ClientConfigurationApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * Edit your client\'s configuration. Must pass your global (i.e. client) access_token.<br/><br/> <b>NOTE</b>: When token validity periods are changed, this only applies to newly requested tokens, and does not change the expiration time of already existing tokens.
     * @summary Edit client configuration
     * @param {ClientConfigurationParams} [body] Client configuration parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editClientConfiguration(
      body?: ClientConfigurationParams,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/api/v1/clientConfiguration`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"ClientConfigurationParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get your client\'s configuration. Must pass your global (i.e. client) access_token.
     * @summary Get client configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClientConfiguration(options: any = {}): RequestArgs {
      const localVarPath = `/api/v1/clientConfiguration`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * ClientConfigurationApi - functional programming interface
 * @export
 */
export const ClientConfigurationApiFp = function(
  configuration?: Configuration
) {
  return {
    /**
     * Edit your client\'s configuration. Must pass your global (i.e. client) access_token.<br/><br/> <b>NOTE</b>: When token validity periods are changed, this only applies to newly requested tokens, and does not change the expiration time of already existing tokens.
     * @summary Edit client configuration
     * @param {ClientConfigurationParams} [body] Client configuration parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editClientConfiguration(
      body?: ClientConfigurationParams,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<ClientConfiguration> {
      const localVarAxiosArgs = ClientConfigurationApiAxiosParamCreator(
        configuration
      ).editClientConfiguration(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get your client\'s configuration. Must pass your global (i.e. client) access_token.
     * @summary Get client configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClientConfiguration(
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<ClientConfiguration> {
      const localVarAxiosArgs = ClientConfigurationApiAxiosParamCreator(
        configuration
      ).getClientConfiguration(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    }
  };
};

/**
 * ClientConfigurationApi - factory interface
 * @export
 */
export const ClientConfigurationApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Edit your client\'s configuration. Must pass your global (i.e. client) access_token.<br/><br/> <b>NOTE</b>: When token validity periods are changed, this only applies to newly requested tokens, and does not change the expiration time of already existing tokens.
     * @summary Edit client configuration
     * @param {ClientConfigurationParams} [body] Client configuration parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editClientConfiguration(body?: ClientConfigurationParams, options?: any) {
      return ClientConfigurationApiFp(configuration).editClientConfiguration(
        body,
        options
      )(axios, basePath);
    },
    /**
     * Get your client\'s configuration. Must pass your global (i.e. client) access_token.
     * @summary Get client configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClientConfiguration(options?: any) {
      return ClientConfigurationApiFp(configuration).getClientConfiguration(
        options
      )(axios, basePath);
    }
  };
};

/**
 * ClientConfigurationApi - object-oriented interface
 * @export
 * @class ClientConfigurationApi
 * @extends {BaseAPI}
 */
export class ClientConfigurationApi extends BaseAPI {
  /**
   * Edit your client\'s configuration. Must pass your global (i.e. client) access_token.<br/><br/> <b>NOTE</b>: When token validity periods are changed, this only applies to newly requested tokens, and does not change the expiration time of already existing tokens.
   * @summary Edit client configuration
   * @param {ClientConfigurationParams} [body] Client configuration parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientConfigurationApi
   */
  public editClientConfiguration(
    body?: ClientConfigurationParams,
    options?: any
  ) {
    return ClientConfigurationApiFp(this.configuration).editClientConfiguration(
      body,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Get your client\'s configuration. Must pass your global (i.e. client) access_token.
   * @summary Get client configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ClientConfigurationApi
   */
  public getClientConfiguration(options?: any) {
    return ClientConfigurationApiFp(this.configuration).getClientConfiguration(
      options
    )(this.axios, this.basePath);
  }
}

/**
 * LabelsApi - axios parameter creator
 * @export
 */
export const LabelsApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * Create a new label for a specific user. Must pass the new label\'s name and the user\'s access_token.<br/><br/>Users can create labels to flag transactions (see method PATCH /transactions), with the goal of collecting and getting an overview of all transactions of a certain \'type\'. In this sense, labels are similar to transaction categories. However, labels are supposed to depict more of an implicit meaning of a transaction. For instance, a user might want to assign a flag to a transaction that reminds him that he can offset it against tax. At the same time, the category of the transactions might be something like \'insurance\', which is a more \'fact-based\', or \'objective\' way of typing the transaction. Despite this semantic difference between categories and labels, there is also the difference that a transaction can be assigned multiple labels at the same time (while in contrast it can have just a single category).
     * @summary Create a new label
     * @param {LabelParams} body Label\&#39;s name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLabel(body: LabelParams, options: any = {}): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling createLabel."
        );
      }
      const localVarPath = `/api/v1/labels`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"LabelParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete all labels of the user that is authorized by the access_token. Must pass the user\'s access_token.
     * @summary Delete all labels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllLabels(options: any = {}): RequestArgs {
      const localVarPath = `/api/v1/labels`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete a single label of the user that is authorized by the access_token. Must pass the label\'s identifier and the user\'s access_token.
     * @summary Delete a label
     * @param {number} id Identifier of the label to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLabel(id: number, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling deleteLabel."
        );
      }
      const localVarPath = `/api/v1/labels/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Change the name of a label of the user that is authorized by the access_token. Must pass the label\'s identifier, the label\'s new name and the user\'s access_token.
     * @summary Edit a label
     * @param {number} id Label\&#39;s identifier
     * @param {LabelParams} body Label\&#39;s new name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editLabel(id: number, body: LabelParams, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling editLabel."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling editLabel."
        );
      }
      const localVarPath = `/api/v1/labels/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"LabelParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get labels of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those labels that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get and search all labels
     * @param {Array<number>} [ids] A comma-separated list of label identifiers. If specified, then only labels whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {string} [search] If specified, then only those labels will be contained in the result whose \&#39;name\&#39; contains the given search string (the matching works case-insensitive). If no labels contain the search string in their name, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the name in order for a label to get included into the result.
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;id\&#39; or \&#39;name\&#39;. The default order for all services is \&#39;id,asc\&#39;. Since both fields (id and name) are unique, ordering by multiple fields is pointless. The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchAllLabels(
      ids?: Array<number>,
      search?: string,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/api/v1/labels`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      if (ids) {
        localVarQueryParameter["ids"] = ids;
      }

      if (search !== undefined) {
        localVarQueryParameter["search"] = search;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["perPage"] = perPage;
      }

      if (order) {
        localVarQueryParameter["order"] = order;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a single label of the user that is authorized by the access_token. Must pass the label\'s identifier and the user\'s access_token.
     * @summary Get a label
     * @param {number} id Identifier of requested label
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLabel(id: number, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getLabel."
        );
      }
      const localVarPath = `/api/v1/labels/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a list of multiple labels of the user that is authorized by the access_token.Must pass the labels\' identifiers and the user\'s access_token. Identifiers that do not exist or do not relate to the authorized user will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). WARNING: This service is deprecated and will be removed at some point. If you want to get multiple labels, please instead use the service \'Get all labels\' and pass a comma-separated list of identifiers as a parameter \'ids\'.
     * @summary Get multiple labels
     * @param {Array<number>} ids Comma-separated list of identifiers of requested labels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleLabels(ids: Array<number>, options: any = {}): RequestArgs {
      // verify required parameter 'ids' is not null or undefined
      if (ids === null || ids === undefined) {
        throw new RequiredError(
          "ids",
          "Required parameter ids was null or undefined when calling getMultipleLabels."
        );
      }
      const localVarPath = `/api/v1/labels/{ids}`.replace(
        `{${"ids"}}`,
        encodeURIComponent(String(ids))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * LabelsApi - functional programming interface
 * @export
 */
export const LabelsApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Create a new label for a specific user. Must pass the new label\'s name and the user\'s access_token.<br/><br/>Users can create labels to flag transactions (see method PATCH /transactions), with the goal of collecting and getting an overview of all transactions of a certain \'type\'. In this sense, labels are similar to transaction categories. However, labels are supposed to depict more of an implicit meaning of a transaction. For instance, a user might want to assign a flag to a transaction that reminds him that he can offset it against tax. At the same time, the category of the transactions might be something like \'insurance\', which is a more \'fact-based\', or \'objective\' way of typing the transaction. Despite this semantic difference between categories and labels, there is also the difference that a transaction can be assigned multiple labels at the same time (while in contrast it can have just a single category).
     * @summary Create a new label
     * @param {LabelParams} body Label\&#39;s name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLabel(
      body: LabelParams,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label> {
      const localVarAxiosArgs = LabelsApiAxiosParamCreator(
        configuration
      ).createLabel(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Delete all labels of the user that is authorized by the access_token. Must pass the user\'s access_token.
     * @summary Delete all labels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllLabels(
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<IdentifierList> {
      const localVarAxiosArgs = LabelsApiAxiosParamCreator(
        configuration
      ).deleteAllLabels(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Delete a single label of the user that is authorized by the access_token. Must pass the label\'s identifier and the user\'s access_token.
     * @summary Delete a label
     * @param {number} id Identifier of the label to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLabel(
      id: number,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = LabelsApiAxiosParamCreator(
        configuration
      ).deleteLabel(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Change the name of a label of the user that is authorized by the access_token. Must pass the label\'s identifier, the label\'s new name and the user\'s access_token.
     * @summary Edit a label
     * @param {number} id Label\&#39;s identifier
     * @param {LabelParams} body Label\&#39;s new name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editLabel(
      id: number,
      body: LabelParams,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label> {
      const localVarAxiosArgs = LabelsApiAxiosParamCreator(
        configuration
      ).editLabel(id, body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get labels of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those labels that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get and search all labels
     * @param {Array<number>} [ids] A comma-separated list of label identifiers. If specified, then only labels whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {string} [search] If specified, then only those labels will be contained in the result whose \&#39;name\&#39; contains the given search string (the matching works case-insensitive). If no labels contain the search string in their name, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the name in order for a label to get included into the result.
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;id\&#39; or \&#39;name\&#39;. The default order for all services is \&#39;id,asc\&#39;. Since both fields (id and name) are unique, ordering by multiple fields is pointless. The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchAllLabels(
      ids?: Array<number>,
      search?: string,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<PageableLabelList> {
      const localVarAxiosArgs = LabelsApiAxiosParamCreator(
        configuration
      ).getAndSearchAllLabels(ids, search, page, perPage, order, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get a single label of the user that is authorized by the access_token. Must pass the label\'s identifier and the user\'s access_token.
     * @summary Get a label
     * @param {number} id Identifier of requested label
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLabel(
      id: number,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label> {
      const localVarAxiosArgs = LabelsApiAxiosParamCreator(
        configuration
      ).getLabel(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get a list of multiple labels of the user that is authorized by the access_token.Must pass the labels\' identifiers and the user\'s access_token. Identifiers that do not exist or do not relate to the authorized user will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). WARNING: This service is deprecated and will be removed at some point. If you want to get multiple labels, please instead use the service \'Get all labels\' and pass a comma-separated list of identifiers as a parameter \'ids\'.
     * @summary Get multiple labels
     * @param {Array<number>} ids Comma-separated list of identifiers of requested labels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleLabels(
      ids: Array<number>,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<LabelList> {
      const localVarAxiosArgs = LabelsApiAxiosParamCreator(
        configuration
      ).getMultipleLabels(ids, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    }
  };
};

/**
 * LabelsApi - factory interface
 * @export
 */
export const LabelsApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Create a new label for a specific user. Must pass the new label\'s name and the user\'s access_token.<br/><br/>Users can create labels to flag transactions (see method PATCH /transactions), with the goal of collecting and getting an overview of all transactions of a certain \'type\'. In this sense, labels are similar to transaction categories. However, labels are supposed to depict more of an implicit meaning of a transaction. For instance, a user might want to assign a flag to a transaction that reminds him that he can offset it against tax. At the same time, the category of the transactions might be something like \'insurance\', which is a more \'fact-based\', or \'objective\' way of typing the transaction. Despite this semantic difference between categories and labels, there is also the difference that a transaction can be assigned multiple labels at the same time (while in contrast it can have just a single category).
     * @summary Create a new label
     * @param {LabelParams} body Label\&#39;s name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLabel(body: LabelParams, options?: any) {
      return LabelsApiFp(configuration).createLabel(body, options)(
        axios,
        basePath
      );
    },
    /**
     * Delete all labels of the user that is authorized by the access_token. Must pass the user\'s access_token.
     * @summary Delete all labels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllLabels(options?: any) {
      return LabelsApiFp(configuration).deleteAllLabels(options)(
        axios,
        basePath
      );
    },
    /**
     * Delete a single label of the user that is authorized by the access_token. Must pass the label\'s identifier and the user\'s access_token.
     * @summary Delete a label
     * @param {number} id Identifier of the label to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLabel(id: number, options?: any) {
      return LabelsApiFp(configuration).deleteLabel(id, options)(
        axios,
        basePath
      );
    },
    /**
     * Change the name of a label of the user that is authorized by the access_token. Must pass the label\'s identifier, the label\'s new name and the user\'s access_token.
     * @summary Edit a label
     * @param {number} id Label\&#39;s identifier
     * @param {LabelParams} body Label\&#39;s new name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editLabel(id: number, body: LabelParams, options?: any) {
      return LabelsApiFp(configuration).editLabel(id, body, options)(
        axios,
        basePath
      );
    },
    /**
     * Get labels of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those labels that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get and search all labels
     * @param {Array<number>} [ids] A comma-separated list of label identifiers. If specified, then only labels whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {string} [search] If specified, then only those labels will be contained in the result whose \&#39;name\&#39; contains the given search string (the matching works case-insensitive). If no labels contain the search string in their name, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the name in order for a label to get included into the result.
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;id\&#39; or \&#39;name\&#39;. The default order for all services is \&#39;id,asc\&#39;. Since both fields (id and name) are unique, ordering by multiple fields is pointless. The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchAllLabels(
      ids?: Array<number>,
      search?: string,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options?: any
    ) {
      return LabelsApiFp(configuration).getAndSearchAllLabels(
        ids,
        search,
        page,
        perPage,
        order,
        options
      )(axios, basePath);
    },
    /**
     * Get a single label of the user that is authorized by the access_token. Must pass the label\'s identifier and the user\'s access_token.
     * @summary Get a label
     * @param {number} id Identifier of requested label
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLabel(id: number, options?: any) {
      return LabelsApiFp(configuration).getLabel(id, options)(axios, basePath);
    },
    /**
     * Get a list of multiple labels of the user that is authorized by the access_token.Must pass the labels\' identifiers and the user\'s access_token. Identifiers that do not exist or do not relate to the authorized user will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). WARNING: This service is deprecated and will be removed at some point. If you want to get multiple labels, please instead use the service \'Get all labels\' and pass a comma-separated list of identifiers as a parameter \'ids\'.
     * @summary Get multiple labels
     * @param {Array<number>} ids Comma-separated list of identifiers of requested labels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleLabels(ids: Array<number>, options?: any) {
      return LabelsApiFp(configuration).getMultipleLabels(ids, options)(
        axios,
        basePath
      );
    }
  };
};

/**
 * LabelsApi - object-oriented interface
 * @export
 * @class LabelsApi
 * @extends {BaseAPI}
 */
export class LabelsApi extends BaseAPI {
  /**
   * Create a new label for a specific user. Must pass the new label\'s name and the user\'s access_token.<br/><br/>Users can create labels to flag transactions (see method PATCH /transactions), with the goal of collecting and getting an overview of all transactions of a certain \'type\'. In this sense, labels are similar to transaction categories. However, labels are supposed to depict more of an implicit meaning of a transaction. For instance, a user might want to assign a flag to a transaction that reminds him that he can offset it against tax. At the same time, the category of the transactions might be something like \'insurance\', which is a more \'fact-based\', or \'objective\' way of typing the transaction. Despite this semantic difference between categories and labels, there is also the difference that a transaction can be assigned multiple labels at the same time (while in contrast it can have just a single category).
   * @summary Create a new label
   * @param {LabelParams} body Label\&#39;s name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabelsApi
   */
  public createLabel(body: LabelParams, options?: any) {
    return LabelsApiFp(this.configuration).createLabel(body, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Delete all labels of the user that is authorized by the access_token. Must pass the user\'s access_token.
   * @summary Delete all labels
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabelsApi
   */
  public deleteAllLabels(options?: any) {
    return LabelsApiFp(this.configuration).deleteAllLabels(options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Delete a single label of the user that is authorized by the access_token. Must pass the label\'s identifier and the user\'s access_token.
   * @summary Delete a label
   * @param {number} id Identifier of the label to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabelsApi
   */
  public deleteLabel(id: number, options?: any) {
    return LabelsApiFp(this.configuration).deleteLabel(id, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Change the name of a label of the user that is authorized by the access_token. Must pass the label\'s identifier, the label\'s new name and the user\'s access_token.
   * @summary Edit a label
   * @param {number} id Label\&#39;s identifier
   * @param {LabelParams} body Label\&#39;s new name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabelsApi
   */
  public editLabel(id: number, body: LabelParams, options?: any) {
    return LabelsApiFp(this.configuration).editLabel(id, body, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Get labels of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those labels that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
   * @summary Get and search all labels
   * @param {Array<number>} [ids] A comma-separated list of label identifiers. If specified, then only labels whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
   * @param {string} [search] If specified, then only those labels will be contained in the result whose \&#39;name\&#39; contains the given search string (the matching works case-insensitive). If no labels contain the search string in their name, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the name in order for a label to get included into the result.
   * @param {number} [page] Result page that you want to retrieve
   * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
   * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;id\&#39; or \&#39;name\&#39;. The default order for all services is \&#39;id,asc\&#39;. Since both fields (id and name) are unique, ordering by multiple fields is pointless. The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabelsApi
   */
  public getAndSearchAllLabels(
    ids?: Array<number>,
    search?: string,
    page?: number,
    perPage?: number,
    order?: Array<string>,
    options?: any
  ) {
    return LabelsApiFp(this.configuration).getAndSearchAllLabels(
      ids,
      search,
      page,
      perPage,
      order,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Get a single label of the user that is authorized by the access_token. Must pass the label\'s identifier and the user\'s access_token.
   * @summary Get a label
   * @param {number} id Identifier of requested label
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabelsApi
   */
  public getLabel(id: number, options?: any) {
    return LabelsApiFp(this.configuration).getLabel(id, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Get a list of multiple labels of the user that is authorized by the access_token.Must pass the labels\' identifiers and the user\'s access_token. Identifiers that do not exist or do not relate to the authorized user will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). WARNING: This service is deprecated and will be removed at some point. If you want to get multiple labels, please instead use the service \'Get all labels\' and pass a comma-separated list of identifiers as a parameter \'ids\'.
   * @summary Get multiple labels
   * @param {Array<number>} ids Comma-separated list of identifiers of requested labels
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabelsApi
   */
  public getMultipleLabels(ids: Array<number>, options?: any) {
    return LabelsApiFp(this.configuration).getMultipleLabels(ids, options)(
      this.axios,
      this.basePath
    );
  }
}

/**
 * MandatorAdministrationApi - axios parameter creator
 * @export
 */
export const MandatorAdministrationApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * Change the client_secret for any of your clients, including the mandator admin client. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\'>mandator admin client</a>\'s access_token. <br/><br/>NOTES:<br/>&bull; When you change a client\'s secret, then all of its existing access tokens will be revoked. User access tokens are not affected.<br/>&bull; finAPI is storing client secrets with a one-way encryption. A lost client secret can NOT be recovered.
     * @summary Change client credentials
     * @param {ChangeClientCredentialsParams} body Parameters for changing client credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeClientCredentials(
      body: ChangeClientCredentialsParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling changeClientCredentials."
        );
      }
      const localVarPath = `/api/v1/mandatorAdmin/changeClientCredentials`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"ChangeClientCredentialsParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * This service can be used to define IBAN rules for finAPI\'s transaction categorization system. The transaction categorization is run automatically whenever new transactions are imported, as well as when you call the services \'Check categorization\' or \'Trigger categorization\'. <br/><br/>An IBAN rule maps an IBAN to a certain category. finAPI\'s categorization system will pick the category as a candidate for any transaction whose counterpart\'s account matches the IBAN. It is not guaranteed though that this candidate will actually be applied, as there could be other categorization rules that have higher priority or that are an even better match for the transaction.<br/><br/>Note that the rules that you define here will be applied to all of your users. They have higher priority than finAPI\'s default categorization rules, but lower priority than user-specific rules (User-specific rules are created implicitly whenever a category is manually assigned to a transaction via the PATCH /transactions services). IBAN rules have a higher priority than keyword rules (see the \'Create keyword rules\' service).
     * @summary Create IBAN rules
     * @param {IbanRulesParams} body IBAN rule definitions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createIbanRules(body: IbanRulesParams, options: any = {}): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling createIbanRules."
        );
      }
      const localVarPath = `/api/v1/mandatorAdmin/ibanRules`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"IbanRulesParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * This service can be used to define keyword rules for finAPI\'s transaction categorization system. The transaction categorization is run automatically whenever new transactions are imported, as well as when you call the services \'Check categorization\' or \'Trigger categorization\'. <br/><br/>A keyword rule maps a set of keywords to a certain category. finAPI\'s categorization system will pick the category as a candidate for any transaction that contains at least one of the defined keywords in its purpose or counterpart information. It is not guaranteed though that this candidate will actually be applied, as there could be other categorization rules that have higher priority or that are an even better match for the transaction. If there are multiple keyword rules that match a transaction, finAPI will pick the one with the highest count of matched keywords.<br/><br/>Note that the rules that you define here will be applied to all of your users. They have higher priority than finAPI\'s default categorization rules, but lower priority than user-specific rules (User-specific rules are created implicitly whenever a category is manually assigned to a transaction via the PATCH /transactions services). Keyword rules have a lower priority than IBAN rules (see the \'Create IBAN rules\' service).
     * @summary Create keyword rules
     * @param {KeywordRulesParams} body Keyword rule definitions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createKeywordRules(
      body: KeywordRulesParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling createKeywordRules."
        );
      }
      const localVarPath = `/api/v1/mandatorAdmin/keywordRules`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"KeywordRulesParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete one or multiple IBAN rules that you have previously created via the \'Create IBAN rules\' service.
     * @summary Delete IBAN rules
     * @param {IdentifiersParams} body List of IBAN rules identifiers.The maximum number of identifiers is 100.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteIbanRules(body: IdentifiersParams, options: any = {}): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling deleteIbanRules."
        );
      }
      const localVarPath = `/api/v1/mandatorAdmin/ibanRules/delete`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"IdentifiersParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete one or multiple keyword rules that you have previously created via the \'Create keyword rules\' service.
     * @summary Delete keyword rules
     * @param {IdentifiersParams} body List of keyword rule identifiers.The maximum number of identifiers is 100.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteKeywordRules(
      body: IdentifiersParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling deleteKeywordRules."
        );
      }
      const localVarPath = `/api/v1/mandatorAdmin/keywordRules/delete`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"IdentifiersParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete one or several users, which are specified by a given list of identifiers. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token. <br/><br/><b>NOTE</b>: finAPI may fail to delete one (or several, or all) of the specified users. A user cannot get deleted when his data is currently locked by an internal process (for instance, update of a bank connection or transactions categorization). The response contains the identifiers of all users that could not get deleted, and all users that could get deleted, separated in two lists. The mandator admin client can retry the request at a later time for the users who could not get deleted.<br/> Note that non-existing user identifiers will be ignored entirely, meaning that those identifiers will not appear in the response at all.
     * @summary Delete users
     * @param {UserIdentifiersParams} body List of user identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUsers(body: UserIdentifiersParams, options: any = {}): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling deleteUsers."
        );
      }
      const localVarPath = `/api/v1/mandatorAdmin/deleteUsers`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"UserIdentifiersParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all IBAN-based categorization rules that you have defined for your users via the \'Create IBAN rules\' service.
     * @summary Get IBAN rules
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIbanRuleList(
      page?: number,
      perPage?: number,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/api/v1/mandatorAdmin/ibanRules`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["perPage"] = perPage;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all keyword-based categorization rules that you have defined for your users via the \'Create keyword rules\' service.
     * @summary Get keyword rules
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKeywordRuleList(
      page?: number,
      perPage?: number,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/api/v1/mandatorAdmin/keywordRules`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["perPage"] = perPage;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * <p>Get a list of the users of the mandator that is authorized by the access_token. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token. You can set optional search criteria to get only those users that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.</p><p>Note that the original user id is no longer available in finAPI once a user has been deleted. Because of this, the userId of deleted users will be a distorted version of the original userId. For example, if the deleted user\'s id was originally \'user\', then this service will return \'uXXr\' as the userId.</p>
     * @summary Get user list
     * @param {string} [minRegistrationDate] Lower bound for a user\&#39;s registration date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;registrationDate\&#39; is equal to or later than the given date will be regarded.
     * @param {string} [maxRegistrationDate] Upper bound for a user\&#39;s registration date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;registrationDate\&#39; is equal to or earlier than the given date will be regarded.
     * @param {string} [minDeletionDate] Lower bound for a user\&#39;s deletion date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;deletionDate\&#39; is not null, and is equal to or later than the given date will be regarded.
     * @param {string} [maxDeletionDate] Upper bound for a user\&#39;s deletion date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;deletionDate\&#39; is null, or is equal to or earlier than the given date will be regarded.
     * @param {string} [minLastActiveDate] Lower bound for a user\&#39;s last active date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;lastActiveDate\&#39; is not null, and is equal to or later than the given date will be regarded.
     * @param {string} [maxLastActiveDate] Upper bound for a user\&#39;s last active date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;lastActiveDate\&#39; is null, or is equal to or earlier than the given date will be regarded.
     * @param {boolean} [includeMonthlyStats] Whether to include the \&#39;monthlyStats\&#39; for the returned users. If not specified, then the field defaults to \&#39;false\&#39;.
     * @param {string} [monthlyStatsStartDate] Minimum bound for the monthly stats (&#x3D;oldest month that should be included). Must be passed in the format \&#39;YYYY-MM\&#39;. If not specified, then the monthly stats will go back up to the first month in which the user existed (date of the user\&#39;s registration). Note that this field is only regarded if \&#39;includeMonthlyStats\&#39; &#x3D; true.
     * @param {string} [monthlyStatsEndDate] Maximum bound for the monthly stats (&#x3D;latest month that should be included). Must be passed in the format \&#39;YYYY-MM\&#39;. If not specified, then the monthly stats will go up to either the current month (for active users), or up to the month of deletion (for deleted users). Note that this field is only regarded if  \&#39;includeMonthlyStats\&#39; &#x3D; true.
     * @param {number} [minBankConnectionCountInMonthlyStats] A value of X means that the service will return only those users which had at least X bank connections imported at any time within the returned monthly stats set. This field is only regarded when \&#39;includeMonthlyStats\&#39; is set to \&#39;true\&#39;. The default value for this field is 0.
     * @param {string} [userId] The identifier of a user to search for. If specified, then only the user with the given id will be regarded. If no user can be found for the passed userId (because the user was deleted or his username was misspelled), then the result list will be empty.
     * @param {boolean} [isDeleted] If NOT specified, then the service will regard both active and deleted users in the search. If set to \&#39;true\&#39;, then ONLY deleted users will be regarded. If set to \&#39;false\&#39;, then ONLY active users will be regarded.
     * @param {boolean} [isLocked] If NOT specified, then the service will regard both locked and not locked users in the search. If set to \&#39;true\&#39;, then ONLY locked users will be regarded. If set to \&#39;false\&#39;, then ONLY not locked users will be regarded.
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;userId\&#39;. The default order for this service is \&#39;userId,asc\&#39;. The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserList(
      minRegistrationDate?: string,
      maxRegistrationDate?: string,
      minDeletionDate?: string,
      maxDeletionDate?: string,
      minLastActiveDate?: string,
      maxLastActiveDate?: string,
      includeMonthlyStats?: boolean,
      monthlyStatsStartDate?: string,
      monthlyStatsEndDate?: string,
      minBankConnectionCountInMonthlyStats?: number,
      userId?: string,
      isDeleted?: boolean,
      isLocked?: boolean,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/api/v1/mandatorAdmin/getUserList`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      if (minRegistrationDate !== undefined) {
        localVarQueryParameter["minRegistrationDate"] = minRegistrationDate;
      }

      if (maxRegistrationDate !== undefined) {
        localVarQueryParameter["maxRegistrationDate"] = maxRegistrationDate;
      }

      if (minDeletionDate !== undefined) {
        localVarQueryParameter["minDeletionDate"] = minDeletionDate;
      }

      if (maxDeletionDate !== undefined) {
        localVarQueryParameter["maxDeletionDate"] = maxDeletionDate;
      }

      if (minLastActiveDate !== undefined) {
        localVarQueryParameter["minLastActiveDate"] = minLastActiveDate;
      }

      if (maxLastActiveDate !== undefined) {
        localVarQueryParameter["maxLastActiveDate"] = maxLastActiveDate;
      }

      if (includeMonthlyStats !== undefined) {
        localVarQueryParameter["includeMonthlyStats"] = includeMonthlyStats;
      }

      if (monthlyStatsStartDate !== undefined) {
        localVarQueryParameter["monthlyStatsStartDate"] = monthlyStatsStartDate;
      }

      if (monthlyStatsEndDate !== undefined) {
        localVarQueryParameter["monthlyStatsEndDate"] = monthlyStatsEndDate;
      }

      if (minBankConnectionCountInMonthlyStats !== undefined) {
        localVarQueryParameter[
          "minBankConnectionCountInMonthlyStats"
        ] = minBankConnectionCountInMonthlyStats;
      }

      if (userId !== undefined) {
        localVarQueryParameter["userId"] = userId;
      }

      if (isDeleted !== undefined) {
        localVarQueryParameter["isDeleted"] = isDeleted;
      }

      if (isLocked !== undefined) {
        localVarQueryParameter["isLocked"] = isLocked;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["perPage"] = perPage;
      }

      if (order) {
        localVarQueryParameter["order"] = order;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * MandatorAdministrationApi - functional programming interface
 * @export
 */
export const MandatorAdministrationApiFp = function(
  configuration?: Configuration
) {
  return {
    /**
     * Change the client_secret for any of your clients, including the mandator admin client. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\'>mandator admin client</a>\'s access_token. <br/><br/>NOTES:<br/>&bull; When you change a client\'s secret, then all of its existing access tokens will be revoked. User access tokens are not affected.<br/>&bull; finAPI is storing client secrets with a one-way encryption. A lost client secret can NOT be recovered.
     * @summary Change client credentials
     * @param {ChangeClientCredentialsParams} body Parameters for changing client credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeClientCredentials(
      body: ChangeClientCredentialsParams,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = MandatorAdministrationApiAxiosParamCreator(
        configuration
      ).changeClientCredentials(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This service can be used to define IBAN rules for finAPI\'s transaction categorization system. The transaction categorization is run automatically whenever new transactions are imported, as well as when you call the services \'Check categorization\' or \'Trigger categorization\'. <br/><br/>An IBAN rule maps an IBAN to a certain category. finAPI\'s categorization system will pick the category as a candidate for any transaction whose counterpart\'s account matches the IBAN. It is not guaranteed though that this candidate will actually be applied, as there could be other categorization rules that have higher priority or that are an even better match for the transaction.<br/><br/>Note that the rules that you define here will be applied to all of your users. They have higher priority than finAPI\'s default categorization rules, but lower priority than user-specific rules (User-specific rules are created implicitly whenever a category is manually assigned to a transaction via the PATCH /transactions services). IBAN rules have a higher priority than keyword rules (see the \'Create keyword rules\' service).
     * @summary Create IBAN rules
     * @param {IbanRulesParams} body IBAN rule definitions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createIbanRules(
      body: IbanRulesParams,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<IbanRuleList> {
      const localVarAxiosArgs = MandatorAdministrationApiAxiosParamCreator(
        configuration
      ).createIbanRules(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This service can be used to define keyword rules for finAPI\'s transaction categorization system. The transaction categorization is run automatically whenever new transactions are imported, as well as when you call the services \'Check categorization\' or \'Trigger categorization\'. <br/><br/>A keyword rule maps a set of keywords to a certain category. finAPI\'s categorization system will pick the category as a candidate for any transaction that contains at least one of the defined keywords in its purpose or counterpart information. It is not guaranteed though that this candidate will actually be applied, as there could be other categorization rules that have higher priority or that are an even better match for the transaction. If there are multiple keyword rules that match a transaction, finAPI will pick the one with the highest count of matched keywords.<br/><br/>Note that the rules that you define here will be applied to all of your users. They have higher priority than finAPI\'s default categorization rules, but lower priority than user-specific rules (User-specific rules are created implicitly whenever a category is manually assigned to a transaction via the PATCH /transactions services). Keyword rules have a lower priority than IBAN rules (see the \'Create IBAN rules\' service).
     * @summary Create keyword rules
     * @param {KeywordRulesParams} body Keyword rule definitions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createKeywordRules(
      body: KeywordRulesParams,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<KeywordRuleList> {
      const localVarAxiosArgs = MandatorAdministrationApiAxiosParamCreator(
        configuration
      ).createKeywordRules(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Delete one or multiple IBAN rules that you have previously created via the \'Create IBAN rules\' service.
     * @summary Delete IBAN rules
     * @param {IdentifiersParams} body List of IBAN rules identifiers.The maximum number of identifiers is 100.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteIbanRules(
      body: IdentifiersParams,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<IdentifierList> {
      const localVarAxiosArgs = MandatorAdministrationApiAxiosParamCreator(
        configuration
      ).deleteIbanRules(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Delete one or multiple keyword rules that you have previously created via the \'Create keyword rules\' service.
     * @summary Delete keyword rules
     * @param {IdentifiersParams} body List of keyword rule identifiers.The maximum number of identifiers is 100.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteKeywordRules(
      body: IdentifiersParams,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<IdentifierList> {
      const localVarAxiosArgs = MandatorAdministrationApiAxiosParamCreator(
        configuration
      ).deleteKeywordRules(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Delete one or several users, which are specified by a given list of identifiers. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token. <br/><br/><b>NOTE</b>: finAPI may fail to delete one (or several, or all) of the specified users. A user cannot get deleted when his data is currently locked by an internal process (for instance, update of a bank connection or transactions categorization). The response contains the identifiers of all users that could not get deleted, and all users that could get deleted, separated in two lists. The mandator admin client can retry the request at a later time for the users who could not get deleted.<br/> Note that non-existing user identifiers will be ignored entirely, meaning that those identifiers will not appear in the response at all.
     * @summary Delete users
     * @param {UserIdentifiersParams} body List of user identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUsers(
      body: UserIdentifiersParams,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<UserIdentifiersList> {
      const localVarAxiosArgs = MandatorAdministrationApiAxiosParamCreator(
        configuration
      ).deleteUsers(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Returns all IBAN-based categorization rules that you have defined for your users via the \'Create IBAN rules\' service.
     * @summary Get IBAN rules
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIbanRuleList(
      page?: number,
      perPage?: number,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<PageableIbanRuleList> {
      const localVarAxiosArgs = MandatorAdministrationApiAxiosParamCreator(
        configuration
      ).getIbanRuleList(page, perPage, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Returns all keyword-based categorization rules that you have defined for your users via the \'Create keyword rules\' service.
     * @summary Get keyword rules
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKeywordRuleList(
      page?: number,
      perPage?: number,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<PageableKeywordRuleList> {
      const localVarAxiosArgs = MandatorAdministrationApiAxiosParamCreator(
        configuration
      ).getKeywordRuleList(page, perPage, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * <p>Get a list of the users of the mandator that is authorized by the access_token. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token. You can set optional search criteria to get only those users that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.</p><p>Note that the original user id is no longer available in finAPI once a user has been deleted. Because of this, the userId of deleted users will be a distorted version of the original userId. For example, if the deleted user\'s id was originally \'user\', then this service will return \'uXXr\' as the userId.</p>
     * @summary Get user list
     * @param {string} [minRegistrationDate] Lower bound for a user\&#39;s registration date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;registrationDate\&#39; is equal to or later than the given date will be regarded.
     * @param {string} [maxRegistrationDate] Upper bound for a user\&#39;s registration date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;registrationDate\&#39; is equal to or earlier than the given date will be regarded.
     * @param {string} [minDeletionDate] Lower bound for a user\&#39;s deletion date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;deletionDate\&#39; is not null, and is equal to or later than the given date will be regarded.
     * @param {string} [maxDeletionDate] Upper bound for a user\&#39;s deletion date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;deletionDate\&#39; is null, or is equal to or earlier than the given date will be regarded.
     * @param {string} [minLastActiveDate] Lower bound for a user\&#39;s last active date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;lastActiveDate\&#39; is not null, and is equal to or later than the given date will be regarded.
     * @param {string} [maxLastActiveDate] Upper bound for a user\&#39;s last active date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;lastActiveDate\&#39; is null, or is equal to or earlier than the given date will be regarded.
     * @param {boolean} [includeMonthlyStats] Whether to include the \&#39;monthlyStats\&#39; for the returned users. If not specified, then the field defaults to \&#39;false\&#39;.
     * @param {string} [monthlyStatsStartDate] Minimum bound for the monthly stats (&#x3D;oldest month that should be included). Must be passed in the format \&#39;YYYY-MM\&#39;. If not specified, then the monthly stats will go back up to the first month in which the user existed (date of the user\&#39;s registration). Note that this field is only regarded if \&#39;includeMonthlyStats\&#39; &#x3D; true.
     * @param {string} [monthlyStatsEndDate] Maximum bound for the monthly stats (&#x3D;latest month that should be included). Must be passed in the format \&#39;YYYY-MM\&#39;. If not specified, then the monthly stats will go up to either the current month (for active users), or up to the month of deletion (for deleted users). Note that this field is only regarded if  \&#39;includeMonthlyStats\&#39; &#x3D; true.
     * @param {number} [minBankConnectionCountInMonthlyStats] A value of X means that the service will return only those users which had at least X bank connections imported at any time within the returned monthly stats set. This field is only regarded when \&#39;includeMonthlyStats\&#39; is set to \&#39;true\&#39;. The default value for this field is 0.
     * @param {string} [userId] The identifier of a user to search for. If specified, then only the user with the given id will be regarded. If no user can be found for the passed userId (because the user was deleted or his username was misspelled), then the result list will be empty.
     * @param {boolean} [isDeleted] If NOT specified, then the service will regard both active and deleted users in the search. If set to \&#39;true\&#39;, then ONLY deleted users will be regarded. If set to \&#39;false\&#39;, then ONLY active users will be regarded.
     * @param {boolean} [isLocked] If NOT specified, then the service will regard both locked and not locked users in the search. If set to \&#39;true\&#39;, then ONLY locked users will be regarded. If set to \&#39;false\&#39;, then ONLY not locked users will be regarded.
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;userId\&#39;. The default order for this service is \&#39;userId,asc\&#39;. The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserList(
      minRegistrationDate?: string,
      maxRegistrationDate?: string,
      minDeletionDate?: string,
      maxDeletionDate?: string,
      minLastActiveDate?: string,
      maxLastActiveDate?: string,
      includeMonthlyStats?: boolean,
      monthlyStatsStartDate?: string,
      monthlyStatsEndDate?: string,
      minBankConnectionCountInMonthlyStats?: number,
      userId?: string,
      isDeleted?: boolean,
      isLocked?: boolean,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<PageableUserInfoList> {
      const localVarAxiosArgs = MandatorAdministrationApiAxiosParamCreator(
        configuration
      ).getUserList(
        minRegistrationDate,
        maxRegistrationDate,
        minDeletionDate,
        maxDeletionDate,
        minLastActiveDate,
        maxLastActiveDate,
        includeMonthlyStats,
        monthlyStatsStartDate,
        monthlyStatsEndDate,
        minBankConnectionCountInMonthlyStats,
        userId,
        isDeleted,
        isLocked,
        page,
        perPage,
        order,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    }
  };
};

/**
 * MandatorAdministrationApi - factory interface
 * @export
 */
export const MandatorAdministrationApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Change the client_secret for any of your clients, including the mandator admin client. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\'>mandator admin client</a>\'s access_token. <br/><br/>NOTES:<br/>&bull; When you change a client\'s secret, then all of its existing access tokens will be revoked. User access tokens are not affected.<br/>&bull; finAPI is storing client secrets with a one-way encryption. A lost client secret can NOT be recovered.
     * @summary Change client credentials
     * @param {ChangeClientCredentialsParams} body Parameters for changing client credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeClientCredentials(
      body: ChangeClientCredentialsParams,
      options?: any
    ) {
      return MandatorAdministrationApiFp(configuration).changeClientCredentials(
        body,
        options
      )(axios, basePath);
    },
    /**
     * This service can be used to define IBAN rules for finAPI\'s transaction categorization system. The transaction categorization is run automatically whenever new transactions are imported, as well as when you call the services \'Check categorization\' or \'Trigger categorization\'. <br/><br/>An IBAN rule maps an IBAN to a certain category. finAPI\'s categorization system will pick the category as a candidate for any transaction whose counterpart\'s account matches the IBAN. It is not guaranteed though that this candidate will actually be applied, as there could be other categorization rules that have higher priority or that are an even better match for the transaction.<br/><br/>Note that the rules that you define here will be applied to all of your users. They have higher priority than finAPI\'s default categorization rules, but lower priority than user-specific rules (User-specific rules are created implicitly whenever a category is manually assigned to a transaction via the PATCH /transactions services). IBAN rules have a higher priority than keyword rules (see the \'Create keyword rules\' service).
     * @summary Create IBAN rules
     * @param {IbanRulesParams} body IBAN rule definitions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createIbanRules(body: IbanRulesParams, options?: any) {
      return MandatorAdministrationApiFp(configuration).createIbanRules(
        body,
        options
      )(axios, basePath);
    },
    /**
     * This service can be used to define keyword rules for finAPI\'s transaction categorization system. The transaction categorization is run automatically whenever new transactions are imported, as well as when you call the services \'Check categorization\' or \'Trigger categorization\'. <br/><br/>A keyword rule maps a set of keywords to a certain category. finAPI\'s categorization system will pick the category as a candidate for any transaction that contains at least one of the defined keywords in its purpose or counterpart information. It is not guaranteed though that this candidate will actually be applied, as there could be other categorization rules that have higher priority or that are an even better match for the transaction. If there are multiple keyword rules that match a transaction, finAPI will pick the one with the highest count of matched keywords.<br/><br/>Note that the rules that you define here will be applied to all of your users. They have higher priority than finAPI\'s default categorization rules, but lower priority than user-specific rules (User-specific rules are created implicitly whenever a category is manually assigned to a transaction via the PATCH /transactions services). Keyword rules have a lower priority than IBAN rules (see the \'Create IBAN rules\' service).
     * @summary Create keyword rules
     * @param {KeywordRulesParams} body Keyword rule definitions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createKeywordRules(body: KeywordRulesParams, options?: any) {
      return MandatorAdministrationApiFp(configuration).createKeywordRules(
        body,
        options
      )(axios, basePath);
    },
    /**
     * Delete one or multiple IBAN rules that you have previously created via the \'Create IBAN rules\' service.
     * @summary Delete IBAN rules
     * @param {IdentifiersParams} body List of IBAN rules identifiers.The maximum number of identifiers is 100.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteIbanRules(body: IdentifiersParams, options?: any) {
      return MandatorAdministrationApiFp(configuration).deleteIbanRules(
        body,
        options
      )(axios, basePath);
    },
    /**
     * Delete one or multiple keyword rules that you have previously created via the \'Create keyword rules\' service.
     * @summary Delete keyword rules
     * @param {IdentifiersParams} body List of keyword rule identifiers.The maximum number of identifiers is 100.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteKeywordRules(body: IdentifiersParams, options?: any) {
      return MandatorAdministrationApiFp(configuration).deleteKeywordRules(
        body,
        options
      )(axios, basePath);
    },
    /**
     * Delete one or several users, which are specified by a given list of identifiers. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token. <br/><br/><b>NOTE</b>: finAPI may fail to delete one (or several, or all) of the specified users. A user cannot get deleted when his data is currently locked by an internal process (for instance, update of a bank connection or transactions categorization). The response contains the identifiers of all users that could not get deleted, and all users that could get deleted, separated in two lists. The mandator admin client can retry the request at a later time for the users who could not get deleted.<br/> Note that non-existing user identifiers will be ignored entirely, meaning that those identifiers will not appear in the response at all.
     * @summary Delete users
     * @param {UserIdentifiersParams} body List of user identifiers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUsers(body: UserIdentifiersParams, options?: any) {
      return MandatorAdministrationApiFp(configuration).deleteUsers(
        body,
        options
      )(axios, basePath);
    },
    /**
     * Returns all IBAN-based categorization rules that you have defined for your users via the \'Create IBAN rules\' service.
     * @summary Get IBAN rules
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getIbanRuleList(page?: number, perPage?: number, options?: any) {
      return MandatorAdministrationApiFp(configuration).getIbanRuleList(
        page,
        perPage,
        options
      )(axios, basePath);
    },
    /**
     * Returns all keyword-based categorization rules that you have defined for your users via the \'Create keyword rules\' service.
     * @summary Get keyword rules
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKeywordRuleList(page?: number, perPage?: number, options?: any) {
      return MandatorAdministrationApiFp(configuration).getKeywordRuleList(
        page,
        perPage,
        options
      )(axios, basePath);
    },
    /**
     * <p>Get a list of the users of the mandator that is authorized by the access_token. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token. You can set optional search criteria to get only those users that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.</p><p>Note that the original user id is no longer available in finAPI once a user has been deleted. Because of this, the userId of deleted users will be a distorted version of the original userId. For example, if the deleted user\'s id was originally \'user\', then this service will return \'uXXr\' as the userId.</p>
     * @summary Get user list
     * @param {string} [minRegistrationDate] Lower bound for a user\&#39;s registration date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;registrationDate\&#39; is equal to or later than the given date will be regarded.
     * @param {string} [maxRegistrationDate] Upper bound for a user\&#39;s registration date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;registrationDate\&#39; is equal to or earlier than the given date will be regarded.
     * @param {string} [minDeletionDate] Lower bound for a user\&#39;s deletion date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;deletionDate\&#39; is not null, and is equal to or later than the given date will be regarded.
     * @param {string} [maxDeletionDate] Upper bound for a user\&#39;s deletion date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;deletionDate\&#39; is null, or is equal to or earlier than the given date will be regarded.
     * @param {string} [minLastActiveDate] Lower bound for a user\&#39;s last active date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;lastActiveDate\&#39; is not null, and is equal to or later than the given date will be regarded.
     * @param {string} [maxLastActiveDate] Upper bound for a user\&#39;s last active date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;lastActiveDate\&#39; is null, or is equal to or earlier than the given date will be regarded.
     * @param {boolean} [includeMonthlyStats] Whether to include the \&#39;monthlyStats\&#39; for the returned users. If not specified, then the field defaults to \&#39;false\&#39;.
     * @param {string} [monthlyStatsStartDate] Minimum bound for the monthly stats (&#x3D;oldest month that should be included). Must be passed in the format \&#39;YYYY-MM\&#39;. If not specified, then the monthly stats will go back up to the first month in which the user existed (date of the user\&#39;s registration). Note that this field is only regarded if \&#39;includeMonthlyStats\&#39; &#x3D; true.
     * @param {string} [monthlyStatsEndDate] Maximum bound for the monthly stats (&#x3D;latest month that should be included). Must be passed in the format \&#39;YYYY-MM\&#39;. If not specified, then the monthly stats will go up to either the current month (for active users), or up to the month of deletion (for deleted users). Note that this field is only regarded if  \&#39;includeMonthlyStats\&#39; &#x3D; true.
     * @param {number} [minBankConnectionCountInMonthlyStats] A value of X means that the service will return only those users which had at least X bank connections imported at any time within the returned monthly stats set. This field is only regarded when \&#39;includeMonthlyStats\&#39; is set to \&#39;true\&#39;. The default value for this field is 0.
     * @param {string} [userId] The identifier of a user to search for. If specified, then only the user with the given id will be regarded. If no user can be found for the passed userId (because the user was deleted or his username was misspelled), then the result list will be empty.
     * @param {boolean} [isDeleted] If NOT specified, then the service will regard both active and deleted users in the search. If set to \&#39;true\&#39;, then ONLY deleted users will be regarded. If set to \&#39;false\&#39;, then ONLY active users will be regarded.
     * @param {boolean} [isLocked] If NOT specified, then the service will regard both locked and not locked users in the search. If set to \&#39;true\&#39;, then ONLY locked users will be regarded. If set to \&#39;false\&#39;, then ONLY not locked users will be regarded.
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;userId\&#39;. The default order for this service is \&#39;userId,asc\&#39;. The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserList(
      minRegistrationDate?: string,
      maxRegistrationDate?: string,
      minDeletionDate?: string,
      maxDeletionDate?: string,
      minLastActiveDate?: string,
      maxLastActiveDate?: string,
      includeMonthlyStats?: boolean,
      monthlyStatsStartDate?: string,
      monthlyStatsEndDate?: string,
      minBankConnectionCountInMonthlyStats?: number,
      userId?: string,
      isDeleted?: boolean,
      isLocked?: boolean,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options?: any
    ) {
      return MandatorAdministrationApiFp(configuration).getUserList(
        minRegistrationDate,
        maxRegistrationDate,
        minDeletionDate,
        maxDeletionDate,
        minLastActiveDate,
        maxLastActiveDate,
        includeMonthlyStats,
        monthlyStatsStartDate,
        monthlyStatsEndDate,
        minBankConnectionCountInMonthlyStats,
        userId,
        isDeleted,
        isLocked,
        page,
        perPage,
        order,
        options
      )(axios, basePath);
    }
  };
};

/**
 * MandatorAdministrationApi - object-oriented interface
 * @export
 * @class MandatorAdministrationApi
 * @extends {BaseAPI}
 */
export class MandatorAdministrationApi extends BaseAPI {
  /**
   * Change the client_secret for any of your clients, including the mandator admin client. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\'>mandator admin client</a>\'s access_token. <br/><br/>NOTES:<br/>&bull; When you change a client\'s secret, then all of its existing access tokens will be revoked. User access tokens are not affected.<br/>&bull; finAPI is storing client secrets with a one-way encryption. A lost client secret can NOT be recovered.
   * @summary Change client credentials
   * @param {ChangeClientCredentialsParams} body Parameters for changing client credentials
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MandatorAdministrationApi
   */
  public changeClientCredentials(
    body: ChangeClientCredentialsParams,
    options?: any
  ) {
    return MandatorAdministrationApiFp(
      this.configuration
    ).changeClientCredentials(body, options)(this.axios, this.basePath);
  }

  /**
   * This service can be used to define IBAN rules for finAPI\'s transaction categorization system. The transaction categorization is run automatically whenever new transactions are imported, as well as when you call the services \'Check categorization\' or \'Trigger categorization\'. <br/><br/>An IBAN rule maps an IBAN to a certain category. finAPI\'s categorization system will pick the category as a candidate for any transaction whose counterpart\'s account matches the IBAN. It is not guaranteed though that this candidate will actually be applied, as there could be other categorization rules that have higher priority or that are an even better match for the transaction.<br/><br/>Note that the rules that you define here will be applied to all of your users. They have higher priority than finAPI\'s default categorization rules, but lower priority than user-specific rules (User-specific rules are created implicitly whenever a category is manually assigned to a transaction via the PATCH /transactions services). IBAN rules have a higher priority than keyword rules (see the \'Create keyword rules\' service).
   * @summary Create IBAN rules
   * @param {IbanRulesParams} body IBAN rule definitions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MandatorAdministrationApi
   */
  public createIbanRules(body: IbanRulesParams, options?: any) {
    return MandatorAdministrationApiFp(this.configuration).createIbanRules(
      body,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This service can be used to define keyword rules for finAPI\'s transaction categorization system. The transaction categorization is run automatically whenever new transactions are imported, as well as when you call the services \'Check categorization\' or \'Trigger categorization\'. <br/><br/>A keyword rule maps a set of keywords to a certain category. finAPI\'s categorization system will pick the category as a candidate for any transaction that contains at least one of the defined keywords in its purpose or counterpart information. It is not guaranteed though that this candidate will actually be applied, as there could be other categorization rules that have higher priority or that are an even better match for the transaction. If there are multiple keyword rules that match a transaction, finAPI will pick the one with the highest count of matched keywords.<br/><br/>Note that the rules that you define here will be applied to all of your users. They have higher priority than finAPI\'s default categorization rules, but lower priority than user-specific rules (User-specific rules are created implicitly whenever a category is manually assigned to a transaction via the PATCH /transactions services). Keyword rules have a lower priority than IBAN rules (see the \'Create IBAN rules\' service).
   * @summary Create keyword rules
   * @param {KeywordRulesParams} body Keyword rule definitions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MandatorAdministrationApi
   */
  public createKeywordRules(body: KeywordRulesParams, options?: any) {
    return MandatorAdministrationApiFp(this.configuration).createKeywordRules(
      body,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Delete one or multiple IBAN rules that you have previously created via the \'Create IBAN rules\' service.
   * @summary Delete IBAN rules
   * @param {IdentifiersParams} body List of IBAN rules identifiers.The maximum number of identifiers is 100.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MandatorAdministrationApi
   */
  public deleteIbanRules(body: IdentifiersParams, options?: any) {
    return MandatorAdministrationApiFp(this.configuration).deleteIbanRules(
      body,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Delete one or multiple keyword rules that you have previously created via the \'Create keyword rules\' service.
   * @summary Delete keyword rules
   * @param {IdentifiersParams} body List of keyword rule identifiers.The maximum number of identifiers is 100.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MandatorAdministrationApi
   */
  public deleteKeywordRules(body: IdentifiersParams, options?: any) {
    return MandatorAdministrationApiFp(this.configuration).deleteKeywordRules(
      body,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Delete one or several users, which are specified by a given list of identifiers. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token. <br/><br/><b>NOTE</b>: finAPI may fail to delete one (or several, or all) of the specified users. A user cannot get deleted when his data is currently locked by an internal process (for instance, update of a bank connection or transactions categorization). The response contains the identifiers of all users that could not get deleted, and all users that could get deleted, separated in two lists. The mandator admin client can retry the request at a later time for the users who could not get deleted.<br/> Note that non-existing user identifiers will be ignored entirely, meaning that those identifiers will not appear in the response at all.
   * @summary Delete users
   * @param {UserIdentifiersParams} body List of user identifiers
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MandatorAdministrationApi
   */
  public deleteUsers(body: UserIdentifiersParams, options?: any) {
    return MandatorAdministrationApiFp(this.configuration).deleteUsers(
      body,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Returns all IBAN-based categorization rules that you have defined for your users via the \'Create IBAN rules\' service.
   * @summary Get IBAN rules
   * @param {number} [page] Result page that you want to retrieve
   * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MandatorAdministrationApi
   */
  public getIbanRuleList(page?: number, perPage?: number, options?: any) {
    return MandatorAdministrationApiFp(this.configuration).getIbanRuleList(
      page,
      perPage,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Returns all keyword-based categorization rules that you have defined for your users via the \'Create keyword rules\' service.
   * @summary Get keyword rules
   * @param {number} [page] Result page that you want to retrieve
   * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MandatorAdministrationApi
   */
  public getKeywordRuleList(page?: number, perPage?: number, options?: any) {
    return MandatorAdministrationApiFp(this.configuration).getKeywordRuleList(
      page,
      perPage,
      options
    )(this.axios, this.basePath);
  }

  /**
   * <p>Get a list of the users of the mandator that is authorized by the access_token. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token. You can set optional search criteria to get only those users that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.</p><p>Note that the original user id is no longer available in finAPI once a user has been deleted. Because of this, the userId of deleted users will be a distorted version of the original userId. For example, if the deleted user\'s id was originally \'user\', then this service will return \'uXXr\' as the userId.</p>
   * @summary Get user list
   * @param {string} [minRegistrationDate] Lower bound for a user\&#39;s registration date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;registrationDate\&#39; is equal to or later than the given date will be regarded.
   * @param {string} [maxRegistrationDate] Upper bound for a user\&#39;s registration date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;registrationDate\&#39; is equal to or earlier than the given date will be regarded.
   * @param {string} [minDeletionDate] Lower bound for a user\&#39;s deletion date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;deletionDate\&#39; is not null, and is equal to or later than the given date will be regarded.
   * @param {string} [maxDeletionDate] Upper bound for a user\&#39;s deletion date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;deletionDate\&#39; is null, or is equal to or earlier than the given date will be regarded.
   * @param {string} [minLastActiveDate] Lower bound for a user\&#39;s last active date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;lastActiveDate\&#39; is not null, and is equal to or later than the given date will be regarded.
   * @param {string} [maxLastActiveDate] Upper bound for a user\&#39;s last active date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only users whose \&#39;lastActiveDate\&#39; is null, or is equal to or earlier than the given date will be regarded.
   * @param {boolean} [includeMonthlyStats] Whether to include the \&#39;monthlyStats\&#39; for the returned users. If not specified, then the field defaults to \&#39;false\&#39;.
   * @param {string} [monthlyStatsStartDate] Minimum bound for the monthly stats (&#x3D;oldest month that should be included). Must be passed in the format \&#39;YYYY-MM\&#39;. If not specified, then the monthly stats will go back up to the first month in which the user existed (date of the user\&#39;s registration). Note that this field is only regarded if \&#39;includeMonthlyStats\&#39; &#x3D; true.
   * @param {string} [monthlyStatsEndDate] Maximum bound for the monthly stats (&#x3D;latest month that should be included). Must be passed in the format \&#39;YYYY-MM\&#39;. If not specified, then the monthly stats will go up to either the current month (for active users), or up to the month of deletion (for deleted users). Note that this field is only regarded if  \&#39;includeMonthlyStats\&#39; &#x3D; true.
   * @param {number} [minBankConnectionCountInMonthlyStats] A value of X means that the service will return only those users which had at least X bank connections imported at any time within the returned monthly stats set. This field is only regarded when \&#39;includeMonthlyStats\&#39; is set to \&#39;true\&#39;. The default value for this field is 0.
   * @param {string} [userId] The identifier of a user to search for. If specified, then only the user with the given id will be regarded. If no user can be found for the passed userId (because the user was deleted or his username was misspelled), then the result list will be empty.
   * @param {boolean} [isDeleted] If NOT specified, then the service will regard both active and deleted users in the search. If set to \&#39;true\&#39;, then ONLY deleted users will be regarded. If set to \&#39;false\&#39;, then ONLY active users will be regarded.
   * @param {boolean} [isLocked] If NOT specified, then the service will regard both locked and not locked users in the search. If set to \&#39;true\&#39;, then ONLY locked users will be regarded. If set to \&#39;false\&#39;, then ONLY not locked users will be regarded.
   * @param {number} [page] Result page that you want to retrieve
   * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
   * @param {Array<string>} [order] Determines the order of the results. You can order the results by \&#39;userId\&#39;. The default order for this service is \&#39;userId,asc\&#39;. The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MandatorAdministrationApi
   */
  public getUserList(
    minRegistrationDate?: string,
    maxRegistrationDate?: string,
    minDeletionDate?: string,
    maxDeletionDate?: string,
    minLastActiveDate?: string,
    maxLastActiveDate?: string,
    includeMonthlyStats?: boolean,
    monthlyStatsStartDate?: string,
    monthlyStatsEndDate?: string,
    minBankConnectionCountInMonthlyStats?: number,
    userId?: string,
    isDeleted?: boolean,
    isLocked?: boolean,
    page?: number,
    perPage?: number,
    order?: Array<string>,
    options?: any
  ) {
    return MandatorAdministrationApiFp(this.configuration).getUserList(
      minRegistrationDate,
      maxRegistrationDate,
      minDeletionDate,
      maxDeletionDate,
      minLastActiveDate,
      maxLastActiveDate,
      includeMonthlyStats,
      monthlyStatsStartDate,
      monthlyStatsEndDate,
      minBankConnectionCountInMonthlyStats,
      userId,
      isDeleted,
      isLocked,
      page,
      perPage,
      order,
      options
    )(this.axios, this.basePath);
  }
}

/**
 * MocksAndTestsApi - axios parameter creator
 * @export
 */
export const MocksAndTestsApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * This service can be used to check the categorization for a given set of transactions, without the need of having the transactions actually imported in finAPI. The result of the categorization is the same as if the transactions were actually imported (the service regards the user-specific categorization rules of the user that is authorized by the access_token). Must pass the user\'s access_token.
     * @summary Check categorization
     * @param {CheckCategorizationData} body Transactions data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkCategorization(
      body: CheckCategorizationData,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling checkCategorization."
        );
      }
      const localVarPath = `/api/v1/tests/checkCategorization`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"CheckCategorizationData" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * This service can be used to mock an update of one or several bank connections by letting you simulate finAPI\'s communication with a bank server. More specifically, you can provide custom balances and transactions for existing accounts and finAPI will import that data into the accounts as if the data had been delivered by a real bank server during a real update. The idea of this service is to allow you to create accounts with specific data in them so that you can test your application in different scenarios.<br/><br/>You can also test your application\'s reception and processing of push notifications with this service, by enabling the \'triggerNotifications\' flag in your request. When this flag is enabled, finAPI will send notifications to your application based on the notification rules that are set up for the user and on the data you provided in the request, the same way as it works with finAPI\'s real automatic batch update process.<br/><br/>Note that this service behaves mostly like calling the bank connection update service, meaning that it returns immediately after having asynchronously started the update process, and also meaning that you have to check the status of the updated bank connections and accounts to find out when the update has finished and what the result is. As you can update several bank connections at once, this service is closer to how finAPI\'s automatic batch updates work as it is to the manual update service though. Because of this, the result of the mocked bank connection updates will be stored in the \'lastAutoUpdate\' field of the bank connections and not in the \'lastManualUpdate\' field. Also, just like with the real batch update, any bank connection that you use with this service must have a PIN stored (even though it is not actually forwarded to any bank server).<br/><br/>Also note that this service may be called only when the user\'s automatic bank connection updates are disabled, to make sure that the mock updates cannot intervene with a real update (please see the User field \'isAutoUpdateEnabled\'). Also, it is currently not possible to mock data for security accounts with this service, as you can only pass transactions, but not security positions.<br/><br/>Please be aware that you will \'mess up\' the accounts when using this service, meaning that when you perform a real update of accounts that you have previously updated with this service, finAPI might detect inconsistencies in the data that exists in its database and the data that is reported by the bank server, and try to fix this with the insertion of an adjusting entry (\'Zwischensaldo\' transaction). Also, new real transactions might not get imported as finAPI could match them to mocked transactions. <b>THIS SERVICE IS MEANT FOR TESTING PURPOSES DURING DEVELOPMENT OF YOUR APPLICATION ONLY!</b> This is why it will work only on the sandbox or alpha environments. Calling it on the live environment will result in <b>403 Forbidden</b>.
     * @summary Mock batch update
     * @param {MockBatchUpdateParams} body Data for mock bank connection updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mockBatchUpdate(
      body: MockBatchUpdateParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling mockBatchUpdate."
        );
      }
      const localVarPath = `/api/v1/tests/mockBatchUpdate`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"MockBatchUpdateParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * MocksAndTestsApi - functional programming interface
 * @export
 */
export const MocksAndTestsApiFp = function(configuration?: Configuration) {
  return {
    /**
     * This service can be used to check the categorization for a given set of transactions, without the need of having the transactions actually imported in finAPI. The result of the categorization is the same as if the transactions were actually imported (the service regards the user-specific categorization rules of the user that is authorized by the access_token). Must pass the user\'s access_token.
     * @summary Check categorization
     * @param {CheckCategorizationData} body Transactions data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkCategorization(
      body: CheckCategorizationData,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<CategorizationCheckResults> {
      const localVarAxiosArgs = MocksAndTestsApiAxiosParamCreator(
        configuration
      ).checkCategorization(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * This service can be used to mock an update of one or several bank connections by letting you simulate finAPI\'s communication with a bank server. More specifically, you can provide custom balances and transactions for existing accounts and finAPI will import that data into the accounts as if the data had been delivered by a real bank server during a real update. The idea of this service is to allow you to create accounts with specific data in them so that you can test your application in different scenarios.<br/><br/>You can also test your application\'s reception and processing of push notifications with this service, by enabling the \'triggerNotifications\' flag in your request. When this flag is enabled, finAPI will send notifications to your application based on the notification rules that are set up for the user and on the data you provided in the request, the same way as it works with finAPI\'s real automatic batch update process.<br/><br/>Note that this service behaves mostly like calling the bank connection update service, meaning that it returns immediately after having asynchronously started the update process, and also meaning that you have to check the status of the updated bank connections and accounts to find out when the update has finished and what the result is. As you can update several bank connections at once, this service is closer to how finAPI\'s automatic batch updates work as it is to the manual update service though. Because of this, the result of the mocked bank connection updates will be stored in the \'lastAutoUpdate\' field of the bank connections and not in the \'lastManualUpdate\' field. Also, just like with the real batch update, any bank connection that you use with this service must have a PIN stored (even though it is not actually forwarded to any bank server).<br/><br/>Also note that this service may be called only when the user\'s automatic bank connection updates are disabled, to make sure that the mock updates cannot intervene with a real update (please see the User field \'isAutoUpdateEnabled\'). Also, it is currently not possible to mock data for security accounts with this service, as you can only pass transactions, but not security positions.<br/><br/>Please be aware that you will \'mess up\' the accounts when using this service, meaning that when you perform a real update of accounts that you have previously updated with this service, finAPI might detect inconsistencies in the data that exists in its database and the data that is reported by the bank server, and try to fix this with the insertion of an adjusting entry (\'Zwischensaldo\' transaction). Also, new real transactions might not get imported as finAPI could match them to mocked transactions. <b>THIS SERVICE IS MEANT FOR TESTING PURPOSES DURING DEVELOPMENT OF YOUR APPLICATION ONLY!</b> This is why it will work only on the sandbox or alpha environments. Calling it on the live environment will result in <b>403 Forbidden</b>.
     * @summary Mock batch update
     * @param {MockBatchUpdateParams} body Data for mock bank connection updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mockBatchUpdate(
      body: MockBatchUpdateParams,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = MocksAndTestsApiAxiosParamCreator(
        configuration
      ).mockBatchUpdate(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    }
  };
};

/**
 * MocksAndTestsApi - factory interface
 * @export
 */
export const MocksAndTestsApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * This service can be used to check the categorization for a given set of transactions, without the need of having the transactions actually imported in finAPI. The result of the categorization is the same as if the transactions were actually imported (the service regards the user-specific categorization rules of the user that is authorized by the access_token). Must pass the user\'s access_token.
     * @summary Check categorization
     * @param {CheckCategorizationData} body Transactions data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkCategorization(body: CheckCategorizationData, options?: any) {
      return MocksAndTestsApiFp(configuration).checkCategorization(
        body,
        options
      )(axios, basePath);
    },
    /**
     * This service can be used to mock an update of one or several bank connections by letting you simulate finAPI\'s communication with a bank server. More specifically, you can provide custom balances and transactions for existing accounts and finAPI will import that data into the accounts as if the data had been delivered by a real bank server during a real update. The idea of this service is to allow you to create accounts with specific data in them so that you can test your application in different scenarios.<br/><br/>You can also test your application\'s reception and processing of push notifications with this service, by enabling the \'triggerNotifications\' flag in your request. When this flag is enabled, finAPI will send notifications to your application based on the notification rules that are set up for the user and on the data you provided in the request, the same way as it works with finAPI\'s real automatic batch update process.<br/><br/>Note that this service behaves mostly like calling the bank connection update service, meaning that it returns immediately after having asynchronously started the update process, and also meaning that you have to check the status of the updated bank connections and accounts to find out when the update has finished and what the result is. As you can update several bank connections at once, this service is closer to how finAPI\'s automatic batch updates work as it is to the manual update service though. Because of this, the result of the mocked bank connection updates will be stored in the \'lastAutoUpdate\' field of the bank connections and not in the \'lastManualUpdate\' field. Also, just like with the real batch update, any bank connection that you use with this service must have a PIN stored (even though it is not actually forwarded to any bank server).<br/><br/>Also note that this service may be called only when the user\'s automatic bank connection updates are disabled, to make sure that the mock updates cannot intervene with a real update (please see the User field \'isAutoUpdateEnabled\'). Also, it is currently not possible to mock data for security accounts with this service, as you can only pass transactions, but not security positions.<br/><br/>Please be aware that you will \'mess up\' the accounts when using this service, meaning that when you perform a real update of accounts that you have previously updated with this service, finAPI might detect inconsistencies in the data that exists in its database and the data that is reported by the bank server, and try to fix this with the insertion of an adjusting entry (\'Zwischensaldo\' transaction). Also, new real transactions might not get imported as finAPI could match them to mocked transactions. <b>THIS SERVICE IS MEANT FOR TESTING PURPOSES DURING DEVELOPMENT OF YOUR APPLICATION ONLY!</b> This is why it will work only on the sandbox or alpha environments. Calling it on the live environment will result in <b>403 Forbidden</b>.
     * @summary Mock batch update
     * @param {MockBatchUpdateParams} body Data for mock bank connection updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    mockBatchUpdate(body: MockBatchUpdateParams, options?: any) {
      return MocksAndTestsApiFp(configuration).mockBatchUpdate(body, options)(
        axios,
        basePath
      );
    }
  };
};

/**
 * MocksAndTestsApi - object-oriented interface
 * @export
 * @class MocksAndTestsApi
 * @extends {BaseAPI}
 */
export class MocksAndTestsApi extends BaseAPI {
  /**
   * This service can be used to check the categorization for a given set of transactions, without the need of having the transactions actually imported in finAPI. The result of the categorization is the same as if the transactions were actually imported (the service regards the user-specific categorization rules of the user that is authorized by the access_token). Must pass the user\'s access_token.
   * @summary Check categorization
   * @param {CheckCategorizationData} body Transactions data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MocksAndTestsApi
   */
  public checkCategorization(body: CheckCategorizationData, options?: any) {
    return MocksAndTestsApiFp(this.configuration).checkCategorization(
      body,
      options
    )(this.axios, this.basePath);
  }

  /**
   * This service can be used to mock an update of one or several bank connections by letting you simulate finAPI\'s communication with a bank server. More specifically, you can provide custom balances and transactions for existing accounts and finAPI will import that data into the accounts as if the data had been delivered by a real bank server during a real update. The idea of this service is to allow you to create accounts with specific data in them so that you can test your application in different scenarios.<br/><br/>You can also test your application\'s reception and processing of push notifications with this service, by enabling the \'triggerNotifications\' flag in your request. When this flag is enabled, finAPI will send notifications to your application based on the notification rules that are set up for the user and on the data you provided in the request, the same way as it works with finAPI\'s real automatic batch update process.<br/><br/>Note that this service behaves mostly like calling the bank connection update service, meaning that it returns immediately after having asynchronously started the update process, and also meaning that you have to check the status of the updated bank connections and accounts to find out when the update has finished and what the result is. As you can update several bank connections at once, this service is closer to how finAPI\'s automatic batch updates work as it is to the manual update service though. Because of this, the result of the mocked bank connection updates will be stored in the \'lastAutoUpdate\' field of the bank connections and not in the \'lastManualUpdate\' field. Also, just like with the real batch update, any bank connection that you use with this service must have a PIN stored (even though it is not actually forwarded to any bank server).<br/><br/>Also note that this service may be called only when the user\'s automatic bank connection updates are disabled, to make sure that the mock updates cannot intervene with a real update (please see the User field \'isAutoUpdateEnabled\'). Also, it is currently not possible to mock data for security accounts with this service, as you can only pass transactions, but not security positions.<br/><br/>Please be aware that you will \'mess up\' the accounts when using this service, meaning that when you perform a real update of accounts that you have previously updated with this service, finAPI might detect inconsistencies in the data that exists in its database and the data that is reported by the bank server, and try to fix this with the insertion of an adjusting entry (\'Zwischensaldo\' transaction). Also, new real transactions might not get imported as finAPI could match them to mocked transactions. <b>THIS SERVICE IS MEANT FOR TESTING PURPOSES DURING DEVELOPMENT OF YOUR APPLICATION ONLY!</b> This is why it will work only on the sandbox or alpha environments. Calling it on the live environment will result in <b>403 Forbidden</b>.
   * @summary Mock batch update
   * @param {MockBatchUpdateParams} body Data for mock bank connection updates
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MocksAndTestsApi
   */
  public mockBatchUpdate(body: MockBatchUpdateParams, options?: any) {
    return MocksAndTestsApiFp(this.configuration).mockBatchUpdate(
      body,
      options
    )(this.axios, this.basePath);
  }
}

/**
 * NotificationRulesApi - axios parameter creator
 * @export
 */
export const NotificationRulesApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * Create a new notification rule for a specific user. Must pass the user\'s access_token.<br/><br/>Setting up notification rules for a user allows your client application to get notified about changes in the user\'s data, e.g. when new transactions were downloaded, an account\'s balance has changed, or the user\'s banking credentials are no longer correct. Note that currently, this feature is implemented only for finAPI\'s automatic batch update, i.e. notification rules are only relevant when the user has activated the automatic updates (and when the automatic batch update is activated in general for your client).<br/><br/>There are different kinds of notification rules. The kind of a rule is depicted by the \'triggerEvent\'. The trigger event specifies what data you have to pass when creating a rule (specifically, the contents of the \'params\' field), on which events finAPI will send notifications to your client application, as well as what data is contained in those notifications. The specifics of the different trigger events are documented in the following article on our Dev Portal: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/232324608-How-to-create-notification-rules-and-receive-notifications\' target=\'_blank\'>How to create notification rules and receive notifications</a>
     * @summary Create a new notification rule
     * @param {NotificationRuleParams} body Notification rule parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNotificationRule(
      body: NotificationRuleParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling createNotificationRule."
        );
      }
      const localVarPath = `/api/v1/notificationRules`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"NotificationRuleParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete all notification rules of the user that is authorized by the access_token. Must pass the user\'s access_token.
     * @summary Delete all notification rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllNotificationRules(options: any = {}): RequestArgs {
      const localVarPath = `/api/v1/notificationRules`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete a single notification rule of the user that is authorized by the access_token. Must pass the notification rule\'s identifier and the user\'s access_token.
     * @summary Delete a notification rule
     * @param {number} id Identifier of the notification rule to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNotificationRule(id: number, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling deleteNotificationRule."
        );
      }
      const localVarPath = `/api/v1/notificationRules/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get notification rules of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those notification rules that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get and search all notification rules
     * @param {Array<number>} [ids] A comma-separated list of notification rule identifiers. If specified, then only notification rules whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {'NEW_ACCOUNT_BALANCE' | 'NEW_TRANSACTIONS' | 'BANK_LOGIN_ERROR' | 'FOREIGN_MONEY_TRANSFER' | 'LOW_ACCOUNT_BALANCE' | 'HIGH_TRANSACTION_AMOUNT' | 'CATEGORY_CASH_FLOW' | 'NEW_TERMS_AND_CONDITIONS'} [triggerEvent] If specified, then only notification rules with given trigger event will be regarded.
     * @param {boolean} [includeDetails] If specified, then only notification rules that include or not include details will be regarded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchAllNotificationRules(
      ids?: Array<number>,
      triggerEvent?:
        | "NEW_ACCOUNT_BALANCE"
        | "NEW_TRANSACTIONS"
        | "BANK_LOGIN_ERROR"
        | "FOREIGN_MONEY_TRANSFER"
        | "LOW_ACCOUNT_BALANCE"
        | "HIGH_TRANSACTION_AMOUNT"
        | "CATEGORY_CASH_FLOW"
        | "NEW_TERMS_AND_CONDITIONS",
      includeDetails?: boolean,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/api/v1/notificationRules`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      if (ids) {
        localVarQueryParameter["ids"] = ids;
      }

      if (triggerEvent !== undefined) {
        localVarQueryParameter["triggerEvent"] = triggerEvent;
      }

      if (includeDetails !== undefined) {
        localVarQueryParameter["includeDetails"] = includeDetails;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a single notification rule of the user that is authorized by the access_token. Must pass the notification rule\'s identifier and the user\'s access_token.
     * @summary Get a notification rule
     * @param {number} id Identifier of requested notification rule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationRule(id: number, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getNotificationRule."
        );
      }
      const localVarPath = `/api/v1/notificationRules/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * NotificationRulesApi - functional programming interface
 * @export
 */
export const NotificationRulesApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Create a new notification rule for a specific user. Must pass the user\'s access_token.<br/><br/>Setting up notification rules for a user allows your client application to get notified about changes in the user\'s data, e.g. when new transactions were downloaded, an account\'s balance has changed, or the user\'s banking credentials are no longer correct. Note that currently, this feature is implemented only for finAPI\'s automatic batch update, i.e. notification rules are only relevant when the user has activated the automatic updates (and when the automatic batch update is activated in general for your client).<br/><br/>There are different kinds of notification rules. The kind of a rule is depicted by the \'triggerEvent\'. The trigger event specifies what data you have to pass when creating a rule (specifically, the contents of the \'params\' field), on which events finAPI will send notifications to your client application, as well as what data is contained in those notifications. The specifics of the different trigger events are documented in the following article on our Dev Portal: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/232324608-How-to-create-notification-rules-and-receive-notifications\' target=\'_blank\'>How to create notification rules and receive notifications</a>
     * @summary Create a new notification rule
     * @param {NotificationRuleParams} body Notification rule parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNotificationRule(
      body: NotificationRuleParams,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<NotificationRule> {
      const localVarAxiosArgs = NotificationRulesApiAxiosParamCreator(
        configuration
      ).createNotificationRule(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Delete all notification rules of the user that is authorized by the access_token. Must pass the user\'s access_token.
     * @summary Delete all notification rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllNotificationRules(
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<IdentifierList> {
      const localVarAxiosArgs = NotificationRulesApiAxiosParamCreator(
        configuration
      ).deleteAllNotificationRules(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Delete a single notification rule of the user that is authorized by the access_token. Must pass the notification rule\'s identifier and the user\'s access_token.
     * @summary Delete a notification rule
     * @param {number} id Identifier of the notification rule to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNotificationRule(
      id: number,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = NotificationRulesApiAxiosParamCreator(
        configuration
      ).deleteNotificationRule(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get notification rules of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those notification rules that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get and search all notification rules
     * @param {Array<number>} [ids] A comma-separated list of notification rule identifiers. If specified, then only notification rules whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {'NEW_ACCOUNT_BALANCE' | 'NEW_TRANSACTIONS' | 'BANK_LOGIN_ERROR' | 'FOREIGN_MONEY_TRANSFER' | 'LOW_ACCOUNT_BALANCE' | 'HIGH_TRANSACTION_AMOUNT' | 'CATEGORY_CASH_FLOW' | 'NEW_TERMS_AND_CONDITIONS'} [triggerEvent] If specified, then only notification rules with given trigger event will be regarded.
     * @param {boolean} [includeDetails] If specified, then only notification rules that include or not include details will be regarded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchAllNotificationRules(
      ids?: Array<number>,
      triggerEvent?:
        | "NEW_ACCOUNT_BALANCE"
        | "NEW_TRANSACTIONS"
        | "BANK_LOGIN_ERROR"
        | "FOREIGN_MONEY_TRANSFER"
        | "LOW_ACCOUNT_BALANCE"
        | "HIGH_TRANSACTION_AMOUNT"
        | "CATEGORY_CASH_FLOW"
        | "NEW_TERMS_AND_CONDITIONS",
      includeDetails?: boolean,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<NotificationRuleList> {
      const localVarAxiosArgs = NotificationRulesApiAxiosParamCreator(
        configuration
      ).getAndSearchAllNotificationRules(
        ids,
        triggerEvent,
        includeDetails,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get a single notification rule of the user that is authorized by the access_token. Must pass the notification rule\'s identifier and the user\'s access_token.
     * @summary Get a notification rule
     * @param {number} id Identifier of requested notification rule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationRule(
      id: number,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<NotificationRule> {
      const localVarAxiosArgs = NotificationRulesApiAxiosParamCreator(
        configuration
      ).getNotificationRule(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    }
  };
};

/**
 * NotificationRulesApi - factory interface
 * @export
 */
export const NotificationRulesApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Create a new notification rule for a specific user. Must pass the user\'s access_token.<br/><br/>Setting up notification rules for a user allows your client application to get notified about changes in the user\'s data, e.g. when new transactions were downloaded, an account\'s balance has changed, or the user\'s banking credentials are no longer correct. Note that currently, this feature is implemented only for finAPI\'s automatic batch update, i.e. notification rules are only relevant when the user has activated the automatic updates (and when the automatic batch update is activated in general for your client).<br/><br/>There are different kinds of notification rules. The kind of a rule is depicted by the \'triggerEvent\'. The trigger event specifies what data you have to pass when creating a rule (specifically, the contents of the \'params\' field), on which events finAPI will send notifications to your client application, as well as what data is contained in those notifications. The specifics of the different trigger events are documented in the following article on our Dev Portal: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/232324608-How-to-create-notification-rules-and-receive-notifications\' target=\'_blank\'>How to create notification rules and receive notifications</a>
     * @summary Create a new notification rule
     * @param {NotificationRuleParams} body Notification rule parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNotificationRule(body: NotificationRuleParams, options?: any) {
      return NotificationRulesApiFp(configuration).createNotificationRule(
        body,
        options
      )(axios, basePath);
    },
    /**
     * Delete all notification rules of the user that is authorized by the access_token. Must pass the user\'s access_token.
     * @summary Delete all notification rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllNotificationRules(options?: any) {
      return NotificationRulesApiFp(configuration).deleteAllNotificationRules(
        options
      )(axios, basePath);
    },
    /**
     * Delete a single notification rule of the user that is authorized by the access_token. Must pass the notification rule\'s identifier and the user\'s access_token.
     * @summary Delete a notification rule
     * @param {number} id Identifier of the notification rule to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteNotificationRule(id: number, options?: any) {
      return NotificationRulesApiFp(configuration).deleteNotificationRule(
        id,
        options
      )(axios, basePath);
    },
    /**
     * Get notification rules of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those notification rules that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get and search all notification rules
     * @param {Array<number>} [ids] A comma-separated list of notification rule identifiers. If specified, then only notification rules whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {'NEW_ACCOUNT_BALANCE' | 'NEW_TRANSACTIONS' | 'BANK_LOGIN_ERROR' | 'FOREIGN_MONEY_TRANSFER' | 'LOW_ACCOUNT_BALANCE' | 'HIGH_TRANSACTION_AMOUNT' | 'CATEGORY_CASH_FLOW' | 'NEW_TERMS_AND_CONDITIONS'} [triggerEvent] If specified, then only notification rules with given trigger event will be regarded.
     * @param {boolean} [includeDetails] If specified, then only notification rules that include or not include details will be regarded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchAllNotificationRules(
      ids?: Array<number>,
      triggerEvent?:
        | "NEW_ACCOUNT_BALANCE"
        | "NEW_TRANSACTIONS"
        | "BANK_LOGIN_ERROR"
        | "FOREIGN_MONEY_TRANSFER"
        | "LOW_ACCOUNT_BALANCE"
        | "HIGH_TRANSACTION_AMOUNT"
        | "CATEGORY_CASH_FLOW"
        | "NEW_TERMS_AND_CONDITIONS",
      includeDetails?: boolean,
      options?: any
    ) {
      return NotificationRulesApiFp(
        configuration
      ).getAndSearchAllNotificationRules(
        ids,
        triggerEvent,
        includeDetails,
        options
      )(axios, basePath);
    },
    /**
     * Get a single notification rule of the user that is authorized by the access_token. Must pass the notification rule\'s identifier and the user\'s access_token.
     * @summary Get a notification rule
     * @param {number} id Identifier of requested notification rule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNotificationRule(id: number, options?: any) {
      return NotificationRulesApiFp(configuration).getNotificationRule(
        id,
        options
      )(axios, basePath);
    }
  };
};

/**
 * NotificationRulesApi - object-oriented interface
 * @export
 * @class NotificationRulesApi
 * @extends {BaseAPI}
 */
export class NotificationRulesApi extends BaseAPI {
  /**
   * Create a new notification rule for a specific user. Must pass the user\'s access_token.<br/><br/>Setting up notification rules for a user allows your client application to get notified about changes in the user\'s data, e.g. when new transactions were downloaded, an account\'s balance has changed, or the user\'s banking credentials are no longer correct. Note that currently, this feature is implemented only for finAPI\'s automatic batch update, i.e. notification rules are only relevant when the user has activated the automatic updates (and when the automatic batch update is activated in general for your client).<br/><br/>There are different kinds of notification rules. The kind of a rule is depicted by the \'triggerEvent\'. The trigger event specifies what data you have to pass when creating a rule (specifically, the contents of the \'params\' field), on which events finAPI will send notifications to your client application, as well as what data is contained in those notifications. The specifics of the different trigger events are documented in the following article on our Dev Portal: <a href=\'https://finapi.zendesk.com/hc/en-us/articles/232324608-How-to-create-notification-rules-and-receive-notifications\' target=\'_blank\'>How to create notification rules and receive notifications</a>
   * @summary Create a new notification rule
   * @param {NotificationRuleParams} body Notification rule parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NotificationRulesApi
   */
  public createNotificationRule(body: NotificationRuleParams, options?: any) {
    return NotificationRulesApiFp(this.configuration).createNotificationRule(
      body,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Delete all notification rules of the user that is authorized by the access_token. Must pass the user\'s access_token.
   * @summary Delete all notification rules
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NotificationRulesApi
   */
  public deleteAllNotificationRules(options?: any) {
    return NotificationRulesApiFp(
      this.configuration
    ).deleteAllNotificationRules(options)(this.axios, this.basePath);
  }

  /**
   * Delete a single notification rule of the user that is authorized by the access_token. Must pass the notification rule\'s identifier and the user\'s access_token.
   * @summary Delete a notification rule
   * @param {number} id Identifier of the notification rule to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NotificationRulesApi
   */
  public deleteNotificationRule(id: number, options?: any) {
    return NotificationRulesApiFp(this.configuration).deleteNotificationRule(
      id,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Get notification rules of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those notification rules that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
   * @summary Get and search all notification rules
   * @param {Array<number>} [ids] A comma-separated list of notification rule identifiers. If specified, then only notification rules whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
   * @param {'NEW_ACCOUNT_BALANCE' | 'NEW_TRANSACTIONS' | 'BANK_LOGIN_ERROR' | 'FOREIGN_MONEY_TRANSFER' | 'LOW_ACCOUNT_BALANCE' | 'HIGH_TRANSACTION_AMOUNT' | 'CATEGORY_CASH_FLOW' | 'NEW_TERMS_AND_CONDITIONS'} [triggerEvent] If specified, then only notification rules with given trigger event will be regarded.
   * @param {boolean} [includeDetails] If specified, then only notification rules that include or not include details will be regarded.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NotificationRulesApi
   */
  public getAndSearchAllNotificationRules(
    ids?: Array<number>,
    triggerEvent?:
      | "NEW_ACCOUNT_BALANCE"
      | "NEW_TRANSACTIONS"
      | "BANK_LOGIN_ERROR"
      | "FOREIGN_MONEY_TRANSFER"
      | "LOW_ACCOUNT_BALANCE"
      | "HIGH_TRANSACTION_AMOUNT"
      | "CATEGORY_CASH_FLOW"
      | "NEW_TERMS_AND_CONDITIONS",
    includeDetails?: boolean,
    options?: any
  ) {
    return NotificationRulesApiFp(
      this.configuration
    ).getAndSearchAllNotificationRules(
      ids,
      triggerEvent,
      includeDetails,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Get a single notification rule of the user that is authorized by the access_token. Must pass the notification rule\'s identifier and the user\'s access_token.
   * @summary Get a notification rule
   * @param {number} id Identifier of requested notification rule
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NotificationRulesApi
   */
  public getNotificationRule(id: number, options?: any) {
    return NotificationRulesApiFp(this.configuration).getNotificationRule(
      id,
      options
    )(this.axios, this.basePath);
  }
}

/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * Get payments of the user that is authorized by the access_token.
     * @summary Get payments
     * @param {Array<number>} [ids] A comma-separated list of payment identifiers. If specified, then only payments whose identifier is matching any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {Array<number>} [accountIds] A comma-separated list of account identifiers. If specified, then only payments that relate to the given account(s) will be regarded. The maximum number of identifiers is 1000.
     * @param {number} [minAmount] If specified, then only those payments are regarded whose (absolute) total amount is equal or greater than the given amount will be regarded. The value must be a positive (absolute) amount.
     * @param {number} [maxAmount] If specified, then only those payments are regarded whose (absolute) total amount is equal or less than the given amount will be regarded. Value must be a positive (absolute) amount.
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can use the following fields for ordering the response: \&#39;id\&#39;, \&#39;amount\&#39;, \&#39;requestDate\&#39; and \&#39;executionDate\&#39;. The default order for all services is \&#39;id,asc\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayments(
      ids?: Array<number>,
      accountIds?: Array<number>,
      minAmount?: number,
      maxAmount?: number,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/api/v1/payments`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      if (ids) {
        localVarQueryParameter["ids"] = ids;
      }

      if (accountIds) {
        localVarQueryParameter["accountIds"] = accountIds;
      }

      if (minAmount !== undefined) {
        localVarQueryParameter["minAmount"] = minAmount;
      }

      if (maxAmount !== undefined) {
        localVarQueryParameter["maxAmount"] = maxAmount;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["perPage"] = perPage;
      }

      if (order) {
        localVarQueryParameter["order"] = order;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Get payments of the user that is authorized by the access_token.
     * @summary Get payments
     * @param {Array<number>} [ids] A comma-separated list of payment identifiers. If specified, then only payments whose identifier is matching any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {Array<number>} [accountIds] A comma-separated list of account identifiers. If specified, then only payments that relate to the given account(s) will be regarded. The maximum number of identifiers is 1000.
     * @param {number} [minAmount] If specified, then only those payments are regarded whose (absolute) total amount is equal or greater than the given amount will be regarded. The value must be a positive (absolute) amount.
     * @param {number} [maxAmount] If specified, then only those payments are regarded whose (absolute) total amount is equal or less than the given amount will be regarded. Value must be a positive (absolute) amount.
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can use the following fields for ordering the response: \&#39;id\&#39;, \&#39;amount\&#39;, \&#39;requestDate\&#39; and \&#39;executionDate\&#39;. The default order for all services is \&#39;id,asc\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayments(
      ids?: Array<number>,
      accountIds?: Array<number>,
      minAmount?: number,
      maxAmount?: number,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<PageablePaymentResources> {
      const localVarAxiosArgs = PaymentsApiAxiosParamCreator(
        configuration
      ).getPayments(
        ids,
        accountIds,
        minAmount,
        maxAmount,
        page,
        perPage,
        order,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    }
  };
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Get payments of the user that is authorized by the access_token.
     * @summary Get payments
     * @param {Array<number>} [ids] A comma-separated list of payment identifiers. If specified, then only payments whose identifier is matching any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {Array<number>} [accountIds] A comma-separated list of account identifiers. If specified, then only payments that relate to the given account(s) will be regarded. The maximum number of identifiers is 1000.
     * @param {number} [minAmount] If specified, then only those payments are regarded whose (absolute) total amount is equal or greater than the given amount will be regarded. The value must be a positive (absolute) amount.
     * @param {number} [maxAmount] If specified, then only those payments are regarded whose (absolute) total amount is equal or less than the given amount will be regarded. Value must be a positive (absolute) amount.
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can use the following fields for ordering the response: \&#39;id\&#39;, \&#39;amount\&#39;, \&#39;requestDate\&#39; and \&#39;executionDate\&#39;. The default order for all services is \&#39;id,asc\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPayments(
      ids?: Array<number>,
      accountIds?: Array<number>,
      minAmount?: number,
      maxAmount?: number,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options?: any
    ) {
      return PaymentsApiFp(configuration).getPayments(
        ids,
        accountIds,
        minAmount,
        maxAmount,
        page,
        perPage,
        order,
        options
      )(axios, basePath);
    }
  };
};

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
  /**
   * Get payments of the user that is authorized by the access_token.
   * @summary Get payments
   * @param {Array<number>} [ids] A comma-separated list of payment identifiers. If specified, then only payments whose identifier is matching any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
   * @param {Array<number>} [accountIds] A comma-separated list of account identifiers. If specified, then only payments that relate to the given account(s) will be regarded. The maximum number of identifiers is 1000.
   * @param {number} [minAmount] If specified, then only those payments are regarded whose (absolute) total amount is equal or greater than the given amount will be regarded. The value must be a positive (absolute) amount.
   * @param {number} [maxAmount] If specified, then only those payments are regarded whose (absolute) total amount is equal or less than the given amount will be regarded. Value must be a positive (absolute) amount.
   * @param {number} [page] Result page that you want to retrieve
   * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
   * @param {Array<string>} [order] Determines the order of the results. You can use the following fields for ordering the response: \&#39;id\&#39;, \&#39;amount\&#39;, \&#39;requestDate\&#39; and \&#39;executionDate\&#39;. The default order for all services is \&#39;id,asc\&#39;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  public getPayments(
    ids?: Array<number>,
    accountIds?: Array<number>,
    minAmount?: number,
    maxAmount?: number,
    page?: number,
    perPage?: number,
    order?: Array<string>,
    options?: any
  ) {
    return PaymentsApiFp(this.configuration).getPayments(
      ids,
      accountIds,
      minAmount,
      maxAmount,
      page,
      perPage,
      order,
      options
    )(this.axios, this.basePath);
  }
}

/**
 * SecuritiesApi - axios parameter creator
 * @export
 */
export const SecuritiesApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * Get securities of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those securities that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.<p>Note: Whenever a security account is being updated, its security positions will be internally re-created, meaning that the identifier of a security position might change over time.</p>
     * @summary Get and search all securities
     * @param {Array<number>} [ids] A comma-separated list of security identifiers. If specified, then only securities whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {string} [search] If specified, then only those securities will be contained in the result whose \&#39;name\&#39;, \&#39;isin\&#39; or \&#39;wkn\&#39; contains the given search string (the matching works case-insensitive). If no securities contain the search string in any of these fields, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the searched fields in order for a security to get included into the result.
     * @param {Array<number>} [accountIds] Comma-separated list of identifiers of accounts
     * @param {number} [page] Result page that you want to retrieve.
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can order the results by next fields: \&#39;id\&#39;, \&#39;name\&#39;, \&#39;isin\&#39;, \&#39;wkn\&#39;, \&#39;quote\&#39;, \&#39;quantityNominal\&#39;, \&#39;marketValue\&#39; and \&#39;entryQuote\&#39;. The default order for all services is \&#39;id,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchAllSecurities(
      ids?: Array<number>,
      search?: string,
      accountIds?: Array<number>,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/api/v1/securities`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      if (ids) {
        localVarQueryParameter["ids"] = ids;
      }

      if (search !== undefined) {
        localVarQueryParameter["search"] = search;
      }

      if (accountIds) {
        localVarQueryParameter["accountIds"] = accountIds;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["perPage"] = perPage;
      }

      if (order) {
        localVarQueryParameter["order"] = order;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a list of multiple securities of the user that is authorized by the access_token. Must pass the securities\' identifiers and the user\'s access_token. Securities whose identifiers do not exist or do not relate to the authorized user will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). <p>Note: Whenever a security account is being updated, its security positions will be internally re-created, meaning that the identifier of a security position might change over time.</p><p>WARNING: This service is deprecated and will be removed at some point. If you want to get multiple securities, please instead use the service \'Get and search all securities\' and pass a comma-separated list of identifiers as a parameter \'ids\'.</p>
     * @summary Get multiple securities
     * @param {Array<number>} ids Comma-separated list of identifiers of requested securities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleSecurities(ids: Array<number>, options: any = {}): RequestArgs {
      // verify required parameter 'ids' is not null or undefined
      if (ids === null || ids === undefined) {
        throw new RequiredError(
          "ids",
          "Required parameter ids was null or undefined when calling getMultipleSecurities."
        );
      }
      const localVarPath = `/api/v1/securities/{ids}`.replace(
        `{${"ids"}}`,
        encodeURIComponent(String(ids))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a single security for a specific user. Must pass the security\'s identifier and the user\'s access_token. <p>Note: Whenever a security account is being updated, its security positions will be internally re-created, meaning that the identifier of a security position might change over time.</p>
     * @summary Get a security
     * @param {number} id Security identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSecurity(id: number, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getSecurity."
        );
      }
      const localVarPath = `/api/v1/securities/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * SecuritiesApi - functional programming interface
 * @export
 */
export const SecuritiesApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Get securities of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those securities that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.<p>Note: Whenever a security account is being updated, its security positions will be internally re-created, meaning that the identifier of a security position might change over time.</p>
     * @summary Get and search all securities
     * @param {Array<number>} [ids] A comma-separated list of security identifiers. If specified, then only securities whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {string} [search] If specified, then only those securities will be contained in the result whose \&#39;name\&#39;, \&#39;isin\&#39; or \&#39;wkn\&#39; contains the given search string (the matching works case-insensitive). If no securities contain the search string in any of these fields, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the searched fields in order for a security to get included into the result.
     * @param {Array<number>} [accountIds] Comma-separated list of identifiers of accounts
     * @param {number} [page] Result page that you want to retrieve.
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can order the results by next fields: \&#39;id\&#39;, \&#39;name\&#39;, \&#39;isin\&#39;, \&#39;wkn\&#39;, \&#39;quote\&#39;, \&#39;quantityNominal\&#39;, \&#39;marketValue\&#39; and \&#39;entryQuote\&#39;. The default order for all services is \&#39;id,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchAllSecurities(
      ids?: Array<number>,
      search?: string,
      accountIds?: Array<number>,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<PageableSecurityList> {
      const localVarAxiosArgs = SecuritiesApiAxiosParamCreator(
        configuration
      ).getAndSearchAllSecurities(
        ids,
        search,
        accountIds,
        page,
        perPage,
        order,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get a list of multiple securities of the user that is authorized by the access_token. Must pass the securities\' identifiers and the user\'s access_token. Securities whose identifiers do not exist or do not relate to the authorized user will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). <p>Note: Whenever a security account is being updated, its security positions will be internally re-created, meaning that the identifier of a security position might change over time.</p><p>WARNING: This service is deprecated and will be removed at some point. If you want to get multiple securities, please instead use the service \'Get and search all securities\' and pass a comma-separated list of identifiers as a parameter \'ids\'.</p>
     * @summary Get multiple securities
     * @param {Array<number>} ids Comma-separated list of identifiers of requested securities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleSecurities(
      ids: Array<number>,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<SecurityList> {
      const localVarAxiosArgs = SecuritiesApiAxiosParamCreator(
        configuration
      ).getMultipleSecurities(ids, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get a single security for a specific user. Must pass the security\'s identifier and the user\'s access_token. <p>Note: Whenever a security account is being updated, its security positions will be internally re-created, meaning that the identifier of a security position might change over time.</p>
     * @summary Get a security
     * @param {number} id Security identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSecurity(
      id: number,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Security> {
      const localVarAxiosArgs = SecuritiesApiAxiosParamCreator(
        configuration
      ).getSecurity(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    }
  };
};

/**
 * SecuritiesApi - factory interface
 * @export
 */
export const SecuritiesApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Get securities of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those securities that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.<p>Note: Whenever a security account is being updated, its security positions will be internally re-created, meaning that the identifier of a security position might change over time.</p>
     * @summary Get and search all securities
     * @param {Array<number>} [ids] A comma-separated list of security identifiers. If specified, then only securities whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {string} [search] If specified, then only those securities will be contained in the result whose \&#39;name\&#39;, \&#39;isin\&#39; or \&#39;wkn\&#39; contains the given search string (the matching works case-insensitive). If no securities contain the search string in any of these fields, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the searched fields in order for a security to get included into the result.
     * @param {Array<number>} [accountIds] Comma-separated list of identifiers of accounts
     * @param {number} [page] Result page that you want to retrieve.
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can order the results by next fields: \&#39;id\&#39;, \&#39;name\&#39;, \&#39;isin\&#39;, \&#39;wkn\&#39;, \&#39;quote\&#39;, \&#39;quantityNominal\&#39;, \&#39;marketValue\&#39; and \&#39;entryQuote\&#39;. The default order for all services is \&#39;id,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchAllSecurities(
      ids?: Array<number>,
      search?: string,
      accountIds?: Array<number>,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options?: any
    ) {
      return SecuritiesApiFp(configuration).getAndSearchAllSecurities(
        ids,
        search,
        accountIds,
        page,
        perPage,
        order,
        options
      )(axios, basePath);
    },
    /**
     * Get a list of multiple securities of the user that is authorized by the access_token. Must pass the securities\' identifiers and the user\'s access_token. Securities whose identifiers do not exist or do not relate to the authorized user will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). <p>Note: Whenever a security account is being updated, its security positions will be internally re-created, meaning that the identifier of a security position might change over time.</p><p>WARNING: This service is deprecated and will be removed at some point. If you want to get multiple securities, please instead use the service \'Get and search all securities\' and pass a comma-separated list of identifiers as a parameter \'ids\'.</p>
     * @summary Get multiple securities
     * @param {Array<number>} ids Comma-separated list of identifiers of requested securities
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleSecurities(ids: Array<number>, options?: any) {
      return SecuritiesApiFp(configuration).getMultipleSecurities(ids, options)(
        axios,
        basePath
      );
    },
    /**
     * Get a single security for a specific user. Must pass the security\'s identifier and the user\'s access_token. <p>Note: Whenever a security account is being updated, its security positions will be internally re-created, meaning that the identifier of a security position might change over time.</p>
     * @summary Get a security
     * @param {number} id Security identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSecurity(id: number, options?: any) {
      return SecuritiesApiFp(configuration).getSecurity(id, options)(
        axios,
        basePath
      );
    }
  };
};

/**
 * SecuritiesApi - object-oriented interface
 * @export
 * @class SecuritiesApi
 * @extends {BaseAPI}
 */
export class SecuritiesApi extends BaseAPI {
  /**
   * Get securities of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those securities that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.<p>Note: Whenever a security account is being updated, its security positions will be internally re-created, meaning that the identifier of a security position might change over time.</p>
   * @summary Get and search all securities
   * @param {Array<number>} [ids] A comma-separated list of security identifiers. If specified, then only securities whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
   * @param {string} [search] If specified, then only those securities will be contained in the result whose \&#39;name\&#39;, \&#39;isin\&#39; or \&#39;wkn\&#39; contains the given search string (the matching works case-insensitive). If no securities contain the search string in any of these fields, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the searched fields in order for a security to get included into the result.
   * @param {Array<number>} [accountIds] Comma-separated list of identifiers of accounts
   * @param {number} [page] Result page that you want to retrieve.
   * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
   * @param {Array<string>} [order] Determines the order of the results. You can order the results by next fields: \&#39;id\&#39;, \&#39;name\&#39;, \&#39;isin\&#39;, \&#39;wkn\&#39;, \&#39;quote\&#39;, \&#39;quantityNominal\&#39;, \&#39;marketValue\&#39; and \&#39;entryQuote\&#39;. The default order for all services is \&#39;id,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecuritiesApi
   */
  public getAndSearchAllSecurities(
    ids?: Array<number>,
    search?: string,
    accountIds?: Array<number>,
    page?: number,
    perPage?: number,
    order?: Array<string>,
    options?: any
  ) {
    return SecuritiesApiFp(this.configuration).getAndSearchAllSecurities(
      ids,
      search,
      accountIds,
      page,
      perPage,
      order,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Get a list of multiple securities of the user that is authorized by the access_token. Must pass the securities\' identifiers and the user\'s access_token. Securities whose identifiers do not exist or do not relate to the authorized user will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). <p>Note: Whenever a security account is being updated, its security positions will be internally re-created, meaning that the identifier of a security position might change over time.</p><p>WARNING: This service is deprecated and will be removed at some point. If you want to get multiple securities, please instead use the service \'Get and search all securities\' and pass a comma-separated list of identifiers as a parameter \'ids\'.</p>
   * @summary Get multiple securities
   * @param {Array<number>} ids Comma-separated list of identifiers of requested securities
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecuritiesApi
   */
  public getMultipleSecurities(ids: Array<number>, options?: any) {
    return SecuritiesApiFp(this.configuration).getMultipleSecurities(
      ids,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Get a single security for a specific user. Must pass the security\'s identifier and the user\'s access_token. <p>Note: Whenever a security account is being updated, its security positions will be internally re-created, meaning that the identifier of a security position might change over time.</p>
   * @summary Get a security
   * @param {number} id Security identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecuritiesApi
   */
  public getSecurity(id: number, options?: any) {
    return SecuritiesApiFp(this.configuration).getSecurity(id, options)(
      this.axios,
      this.basePath
    );
  }
}

/**
 * TPPCertificatesApi - axios parameter creator
 * @export
 */
export const TPPCertificatesApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * Upload a new TPP certificate. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token. <br/>QWAC certificate is used to verify your identity by the bank during the TLS handshake.<br/>QsealC certificate is used to sign the requests to the bank.
     * @summary Create a new certificate
     * @param {TppCertificateParams} body Create new certificate parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewCertificate(
      body: TppCertificateParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling createNewCertificate."
        );
      }
      const localVarPath = `/api/v1/tppCertificates`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"TppCertificateParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete a single certificate by its id. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
     * @summary Delete a certificate
     * @param {number} id Id of the certificate to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCertificate(id: number, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling deleteCertificate."
        );
      }
      const localVarPath = `/api/v1/tppCertificates/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Returns all certificates that you have uploaded via \'Create a new certificate\' service. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
     * @summary Get all certificates
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllCertificates(
      page?: number,
      perPage?: number,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/api/v1/tppCertificates`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["perPage"] = perPage;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a single certificate by its id. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
     * @summary Get a certificate
     * @param {number} id Id of requested certificate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCertificate(id: number, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getCertificate."
        );
      }
      const localVarPath = `/api/v1/tppCertificates/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * TPPCertificatesApi - functional programming interface
 * @export
 */
export const TPPCertificatesApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Upload a new TPP certificate. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token. <br/>QWAC certificate is used to verify your identity by the bank during the TLS handshake.<br/>QsealC certificate is used to sign the requests to the bank.
     * @summary Create a new certificate
     * @param {TppCertificateParams} body Create new certificate parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewCertificate(
      body: TppCertificateParams,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<TppCertificate> {
      const localVarAxiosArgs = TPPCertificatesApiAxiosParamCreator(
        configuration
      ).createNewCertificate(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Delete a single certificate by its id. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
     * @summary Delete a certificate
     * @param {number} id Id of the certificate to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCertificate(
      id: number,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = TPPCertificatesApiAxiosParamCreator(
        configuration
      ).deleteCertificate(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Returns all certificates that you have uploaded via \'Create a new certificate\' service. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
     * @summary Get all certificates
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllCertificates(
      page?: number,
      perPage?: number,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<PageableTppCertificateList> {
      const localVarAxiosArgs = TPPCertificatesApiAxiosParamCreator(
        configuration
      ).getAllCertificates(page, perPage, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get a single certificate by its id. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
     * @summary Get a certificate
     * @param {number} id Id of requested certificate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCertificate(
      id: number,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<TppCertificate> {
      const localVarAxiosArgs = TPPCertificatesApiAxiosParamCreator(
        configuration
      ).getCertificate(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    }
  };
};

/**
 * TPPCertificatesApi - factory interface
 * @export
 */
export const TPPCertificatesApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Upload a new TPP certificate. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token. <br/>QWAC certificate is used to verify your identity by the bank during the TLS handshake.<br/>QsealC certificate is used to sign the requests to the bank.
     * @summary Create a new certificate
     * @param {TppCertificateParams} body Create new certificate parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewCertificate(body: TppCertificateParams, options?: any) {
      return TPPCertificatesApiFp(configuration).createNewCertificate(
        body,
        options
      )(axios, basePath);
    },
    /**
     * Delete a single certificate by its id. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
     * @summary Delete a certificate
     * @param {number} id Id of the certificate to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCertificate(id: number, options?: any) {
      return TPPCertificatesApiFp(configuration).deleteCertificate(id, options)(
        axios,
        basePath
      );
    },
    /**
     * Returns all certificates that you have uploaded via \'Create a new certificate\' service. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
     * @summary Get all certificates
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllCertificates(page?: number, perPage?: number, options?: any) {
      return TPPCertificatesApiFp(configuration).getAllCertificates(
        page,
        perPage,
        options
      )(axios, basePath);
    },
    /**
     * Get a single certificate by its id. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
     * @summary Get a certificate
     * @param {number} id Id of requested certificate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCertificate(id: number, options?: any) {
      return TPPCertificatesApiFp(configuration).getCertificate(id, options)(
        axios,
        basePath
      );
    }
  };
};

/**
 * TPPCertificatesApi - object-oriented interface
 * @export
 * @class TPPCertificatesApi
 * @extends {BaseAPI}
 */
export class TPPCertificatesApi extends BaseAPI {
  /**
   * Upload a new TPP certificate. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token. <br/>QWAC certificate is used to verify your identity by the bank during the TLS handshake.<br/>QsealC certificate is used to sign the requests to the bank.
   * @summary Create a new certificate
   * @param {TppCertificateParams} body Create new certificate parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TPPCertificatesApi
   */
  public createNewCertificate(body: TppCertificateParams, options?: any) {
    return TPPCertificatesApiFp(this.configuration).createNewCertificate(
      body,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Delete a single certificate by its id. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
   * @summary Delete a certificate
   * @param {number} id Id of the certificate to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TPPCertificatesApi
   */
  public deleteCertificate(id: number, options?: any) {
    return TPPCertificatesApiFp(this.configuration).deleteCertificate(
      id,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Returns all certificates that you have uploaded via \'Create a new certificate\' service. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
   * @summary Get all certificates
   * @param {number} [page] Result page that you want to retrieve
   * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TPPCertificatesApi
   */
  public getAllCertificates(page?: number, perPage?: number, options?: any) {
    return TPPCertificatesApiFp(this.configuration).getAllCertificates(
      page,
      perPage,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Get a single certificate by its id. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
   * @summary Get a certificate
   * @param {number} id Id of requested certificate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TPPCertificatesApi
   */
  public getCertificate(id: number, options?: any) {
    return TPPCertificatesApiFp(this.configuration).getCertificate(id, options)(
      this.axios,
      this.basePath
    );
  }
}

/**
 * TPPCredentialsApi - axios parameter creator
 * @export
 */
export const TPPCredentialsApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * Upload TPP credentials for a TPP Authentication Group. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
     * @summary Create new TPP credentials
     * @param {TppCredentialsParams} body Parameters of a new set of TPP credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTppCredential(
      body: TppCredentialsParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling createTppCredential."
        );
      }
      const localVarPath = `/api/v1/tppCredentials`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"TppCredentialsParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete a single set of TPP credentials by its id. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
     * @summary Delete a set of TPP credentials
     * @param {number} id Id of the TPP credentials to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTppCredential(id: number, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling deleteTppCredential."
        );
      }
      const localVarPath = `/api/v1/tppCredentials/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Edit TPP credentials data. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
     * @summary Edit a set of TPP credentials
     * @param {number} id Id of the TPP credentials to edit
     * @param {EditTppCredentialParams} body New TPP credentials parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editTppCredential(
      id: number,
      body: EditTppCredentialParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling editTppCredential."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling editTppCredential."
        );
      }
      const localVarPath = `/api/v1/tppCredentials/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"EditTppCredentialParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get and search all TPP credentials. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token. You can set optional search criteria to get only those TPP credentials that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get all TPP credentials
     * @param {string} [search] Returns only the TPP credentials belonging to those banks whose \&#39;name\&#39;, \&#39;blz\&#39;, or \&#39;bic\&#39; contains the given search string (the matching works case-insensitive). Note: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must apply to a bank in order for it to get included into the result.
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTppCredentials(
      search?: string,
      page?: number,
      perPage?: number,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/api/v1/tppCredentials`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      if (search !== undefined) {
        localVarQueryParameter["search"] = search;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["perPage"] = perPage;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get and search across all available TPP authentication groups. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token. You can set optional search criteria to get only those TPP authentication groups that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get all TPP Authentication Groups
     * @param {string} [name] Only the tpp authentication groups with name matching the given one should appear in the result list
     * @param {string} [bankBlz] Search by connected banks: only the banks with BLZ matching the given one should appear in the result list
     * @param {string} [bankName] Search by connected banks: only the banks with name matching the given one should appear in the result list
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchTppAuthenticationGroups(
      name?: string,
      bankBlz?: string,
      bankName?: string,
      page?: number,
      perPage?: number,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/api/v1/tppCredentials/tppAuthenticationGroups`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (bankBlz !== undefined) {
        localVarQueryParameter["bankBlz"] = bankBlz;
      }

      if (bankName !== undefined) {
        localVarQueryParameter["bankName"] = bankName;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["perPage"] = perPage;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a single set of TPP credentials by its id. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
     * @summary Get a set of TPP credentials
     * @param {number} id Id of the requested TPP credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTppCredential(id: number, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getTppCredential."
        );
      }
      const localVarPath = `/api/v1/tppCredentials/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * TPPCredentialsApi - functional programming interface
 * @export
 */
export const TPPCredentialsApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Upload TPP credentials for a TPP Authentication Group. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
     * @summary Create new TPP credentials
     * @param {TppCredentialsParams} body Parameters of a new set of TPP credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTppCredential(
      body: TppCredentialsParams,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<TppCredentials> {
      const localVarAxiosArgs = TPPCredentialsApiAxiosParamCreator(
        configuration
      ).createTppCredential(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Delete a single set of TPP credentials by its id. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
     * @summary Delete a set of TPP credentials
     * @param {number} id Id of the TPP credentials to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTppCredential(
      id: number,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = TPPCredentialsApiAxiosParamCreator(
        configuration
      ).deleteTppCredential(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Edit TPP credentials data. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
     * @summary Edit a set of TPP credentials
     * @param {number} id Id of the TPP credentials to edit
     * @param {EditTppCredentialParams} body New TPP credentials parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editTppCredential(
      id: number,
      body: EditTppCredentialParams,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<TppCredentials> {
      const localVarAxiosArgs = TPPCredentialsApiAxiosParamCreator(
        configuration
      ).editTppCredential(id, body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get and search all TPP credentials. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token. You can set optional search criteria to get only those TPP credentials that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get all TPP credentials
     * @param {string} [search] Returns only the TPP credentials belonging to those banks whose \&#39;name\&#39;, \&#39;blz\&#39;, or \&#39;bic\&#39; contains the given search string (the matching works case-insensitive). Note: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must apply to a bank in order for it to get included into the result.
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTppCredentials(
      search?: string,
      page?: number,
      perPage?: number,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<PageableTppCredentialResources> {
      const localVarAxiosArgs = TPPCredentialsApiAxiosParamCreator(
        configuration
      ).getAllTppCredentials(search, page, perPage, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get and search across all available TPP authentication groups. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token. You can set optional search criteria to get only those TPP authentication groups that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get all TPP Authentication Groups
     * @param {string} [name] Only the tpp authentication groups with name matching the given one should appear in the result list
     * @param {string} [bankBlz] Search by connected banks: only the banks with BLZ matching the given one should appear in the result list
     * @param {string} [bankName] Search by connected banks: only the banks with name matching the given one should appear in the result list
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchTppAuthenticationGroups(
      name?: string,
      bankBlz?: string,
      bankName?: string,
      page?: number,
      perPage?: number,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<PageableTppAuthenticationGroupResources> {
      const localVarAxiosArgs = TPPCredentialsApiAxiosParamCreator(
        configuration
      ).getAndSearchTppAuthenticationGroups(
        name,
        bankBlz,
        bankName,
        page,
        perPage,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get a single set of TPP credentials by its id. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
     * @summary Get a set of TPP credentials
     * @param {number} id Id of the requested TPP credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTppCredential(
      id: number,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<TppCredentials> {
      const localVarAxiosArgs = TPPCredentialsApiAxiosParamCreator(
        configuration
      ).getTppCredential(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    }
  };
};

/**
 * TPPCredentialsApi - factory interface
 * @export
 */
export const TPPCredentialsApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Upload TPP credentials for a TPP Authentication Group. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
     * @summary Create new TPP credentials
     * @param {TppCredentialsParams} body Parameters of a new set of TPP credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createTppCredential(body: TppCredentialsParams, options?: any) {
      return TPPCredentialsApiFp(configuration).createTppCredential(
        body,
        options
      )(axios, basePath);
    },
    /**
     * Delete a single set of TPP credentials by its id. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
     * @summary Delete a set of TPP credentials
     * @param {number} id Id of the TPP credentials to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTppCredential(id: number, options?: any) {
      return TPPCredentialsApiFp(configuration).deleteTppCredential(
        id,
        options
      )(axios, basePath);
    },
    /**
     * Edit TPP credentials data. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
     * @summary Edit a set of TPP credentials
     * @param {number} id Id of the TPP credentials to edit
     * @param {EditTppCredentialParams} body New TPP credentials parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editTppCredential(
      id: number,
      body: EditTppCredentialParams,
      options?: any
    ) {
      return TPPCredentialsApiFp(configuration).editTppCredential(
        id,
        body,
        options
      )(axios, basePath);
    },
    /**
     * Get and search all TPP credentials. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token. You can set optional search criteria to get only those TPP credentials that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get all TPP credentials
     * @param {string} [search] Returns only the TPP credentials belonging to those banks whose \&#39;name\&#39;, \&#39;blz\&#39;, or \&#39;bic\&#39; contains the given search string (the matching works case-insensitive). Note: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must apply to a bank in order for it to get included into the result.
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTppCredentials(
      search?: string,
      page?: number,
      perPage?: number,
      options?: any
    ) {
      return TPPCredentialsApiFp(configuration).getAllTppCredentials(
        search,
        page,
        perPage,
        options
      )(axios, basePath);
    },
    /**
     * Get and search across all available TPP authentication groups. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token. You can set optional search criteria to get only those TPP authentication groups that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get all TPP Authentication Groups
     * @param {string} [name] Only the tpp authentication groups with name matching the given one should appear in the result list
     * @param {string} [bankBlz] Search by connected banks: only the banks with BLZ matching the given one should appear in the result list
     * @param {string} [bankName] Search by connected banks: only the banks with name matching the given one should appear in the result list
     * @param {number} [page] Result page that you want to retrieve
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchTppAuthenticationGroups(
      name?: string,
      bankBlz?: string,
      bankName?: string,
      page?: number,
      perPage?: number,
      options?: any
    ) {
      return TPPCredentialsApiFp(
        configuration
      ).getAndSearchTppAuthenticationGroups(
        name,
        bankBlz,
        bankName,
        page,
        perPage,
        options
      )(axios, basePath);
    },
    /**
     * Get a single set of TPP credentials by its id. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
     * @summary Get a set of TPP credentials
     * @param {number} id Id of the requested TPP credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTppCredential(id: number, options?: any) {
      return TPPCredentialsApiFp(configuration).getTppCredential(id, options)(
        axios,
        basePath
      );
    }
  };
};

/**
 * TPPCredentialsApi - object-oriented interface
 * @export
 * @class TPPCredentialsApi
 * @extends {BaseAPI}
 */
export class TPPCredentialsApi extends BaseAPI {
  /**
   * Upload TPP credentials for a TPP Authentication Group. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
   * @summary Create new TPP credentials
   * @param {TppCredentialsParams} body Parameters of a new set of TPP credentials
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TPPCredentialsApi
   */
  public createTppCredential(body: TppCredentialsParams, options?: any) {
    return TPPCredentialsApiFp(this.configuration).createTppCredential(
      body,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Delete a single set of TPP credentials by its id. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
   * @summary Delete a set of TPP credentials
   * @param {number} id Id of the TPP credentials to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TPPCredentialsApi
   */
  public deleteTppCredential(id: number, options?: any) {
    return TPPCredentialsApiFp(this.configuration).deleteTppCredential(
      id,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Edit TPP credentials data. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
   * @summary Edit a set of TPP credentials
   * @param {number} id Id of the TPP credentials to edit
   * @param {EditTppCredentialParams} body New TPP credentials parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TPPCredentialsApi
   */
  public editTppCredential(
    id: number,
    body: EditTppCredentialParams,
    options?: any
  ) {
    return TPPCredentialsApiFp(this.configuration).editTppCredential(
      id,
      body,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Get and search all TPP credentials. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token. You can set optional search criteria to get only those TPP credentials that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
   * @summary Get all TPP credentials
   * @param {string} [search] Returns only the TPP credentials belonging to those banks whose \&#39;name\&#39;, \&#39;blz\&#39;, or \&#39;bic\&#39; contains the given search string (the matching works case-insensitive). Note: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must apply to a bank in order for it to get included into the result.
   * @param {number} [page] Result page that you want to retrieve
   * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TPPCredentialsApi
   */
  public getAllTppCredentials(
    search?: string,
    page?: number,
    perPage?: number,
    options?: any
  ) {
    return TPPCredentialsApiFp(this.configuration).getAllTppCredentials(
      search,
      page,
      perPage,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Get and search across all available TPP authentication groups. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token. You can set optional search criteria to get only those TPP authentication groups that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
   * @summary Get all TPP Authentication Groups
   * @param {string} [name] Only the tpp authentication groups with name matching the given one should appear in the result list
   * @param {string} [bankBlz] Search by connected banks: only the banks with BLZ matching the given one should appear in the result list
   * @param {string} [bankName] Search by connected banks: only the banks with name matching the given one should appear in the result list
   * @param {number} [page] Result page that you want to retrieve
   * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TPPCredentialsApi
   */
  public getAndSearchTppAuthenticationGroups(
    name?: string,
    bankBlz?: string,
    bankName?: string,
    page?: number,
    perPage?: number,
    options?: any
  ) {
    return TPPCredentialsApiFp(
      this.configuration
    ).getAndSearchTppAuthenticationGroups(
      name,
      bankBlz,
      bankName,
      page,
      perPage,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Get a single set of TPP credentials by its id. Must pass the <a href=\'https://finapi.zendesk.com/hc/en-us/articles/115003661827-Difference-between-app-clients-and-mandator-admin-client\' target=\'_blank\'>mandator admin client</a>\'s access_token.
   * @summary Get a set of TPP credentials
   * @param {number} id Id of the requested TPP credentials
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TPPCredentialsApi
   */
  public getTppCredential(id: number, options?: any) {
    return TPPCredentialsApiFp(this.configuration).getTppCredential(
      id,
      options
    )(this.axios, this.basePath);
  }
}

/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * Delete a set, or the entirety, of transactions of the currently authorized user.
     * @summary Delete all transactions
     * @param {string} [maxDeletionDate] If specified, then only those transactions are being deleted whose \&#39;finapiBookingDate\&#39; is equal to or earlier to the given date. The date may not be in future, and must be given in the format \&#39;YYYY-MM-DD\&#39;. If not specified, then no date limitation will be in place for the deletion.
     * @param {boolean} [safeMode] When passing \&#39;true\&#39;, then only those transactions are being deleted where at least one of the following holds true: 1. The transaction belongs to a \&#39;demo connection\&#39;; 2. The transaction\&#39;s \&#39;potentialDuplicate\&#39; flag is set to TRUE; 3. The transaction is an adjusting entry (\&#39;Zwischensaldo\&#39; transaction) that was added by finAPI. When passing \&#39;false\&#39;, then finAPI will delete transactions independent of these characteristics. The default value for this parameter is \&#39;true\&#39;.
     * @param {boolean} [rememberDeletion] When passing \&#39;true\&#39;, then finAPI will make sure to not re-import deleted transactions on future account updates. When \&#39;false\&#39;, then deleted transactions might be re-imported. Default value for this parameter is \&#39;false\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllTransactions(
      maxDeletionDate?: string,
      safeMode?: boolean,
      rememberDeletion?: boolean,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/api/v1/transactions`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      if (maxDeletionDate !== undefined) {
        localVarQueryParameter["maxDeletionDate"] = maxDeletionDate;
      }

      if (safeMode !== undefined) {
        localVarQueryParameter["safeMode"] = safeMode;
      }

      if (rememberDeletion !== undefined) {
        localVarQueryParameter["rememberDeletion"] = rememberDeletion;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete a single transaction of the user that is authorized by the access_token.<br/><br/> A transaction can only get deleted if at least one of the following holds true:<br/> &bull; The transaction belongs to a \'demo connection\'<br/> &bull; The transaction\'s \'potentialDuplicate\' flag is set to TRUE<br/> &bull; The transaction is an adjusting entry (\'Zwischensaldo\' transaction) that was added by finAPI<br/><br/>Note that the \'Delete all transactions\' service has additional functionality and allows you to delete transactions that you cannot delete with this service.
     * @summary Delete a transaction
     * @param {number} id Identifier of transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTransaction(id: number, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling deleteTransaction."
        );
      }
      const localVarPath = `/api/v1/transactions/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Edit one or multiple transactions. You can edit the following fields: \'isNew=true|false\' and/or \'isPotentialDuplicate=false\' and/or \'categoryId=<id>\' and/or \'labelIds=[<ids>]\'. To clear the category of the given transactions (so that they are no longer categorized), pass the value \'0\' as the categoryId. To clear the labels of the given transactions, pass an empty array of label identifiers: \'[]\'. The parameters \'categoryId\' and \'labelIds\' are forbidden if \'ids\' is NOT set (i.e. you cannot update the category or labels for ALL transactions). The result is a list of identifiers of only those transactions that have changed as a result of this service call.
     * @summary Edit multiple transactions
     * @param {UpdateMultipleTransactionsParams} body Update transactions parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editMultipleTransactions(
      body: UpdateMultipleTransactionsParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling editMultipleTransactions."
        );
      }
      const localVarPath = `/api/v1/transactions`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"UpdateMultipleTransactionsParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Change the fields of multiple transactions. You can change the following fields: \'isNew=true|false\' and/or \'isPotentialDuplicate=false\' and/or \'categoryId=<id>\' and/or \'labelIds=[<ids>]\'. The max number of input identifiers is limited to 100. To clear the category of the given transactions (so that they are no longer categorized), pass the value \'0\' as the categoryId. To clear the labels of the given transactions, pass an empty array of label identifiers: \'[]\'. The result is a list of identifiers of only those transactions that have changed as a result of this service call. WARNING: This service is deprecated and will be removed at some point. If you want to edit multiple transactions, please instead use the service \'Edit multiple transactions\', where you can pass a comma-separated list of identifiers.
     * @summary Edit multiple transactions (DEPRECATED)
     * @param {Array<number>} ids Comma-separated list of identifiers of updated transactions
     * @param {UpdateTransactionsParams} body Update transactions parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editMultipleTransactionsDeprecated(
      ids: Array<number>,
      body: UpdateTransactionsParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'ids' is not null or undefined
      if (ids === null || ids === undefined) {
        throw new RequiredError(
          "ids",
          "Required parameter ids was null or undefined when calling editMultipleTransactionsDeprecated."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling editMultipleTransactionsDeprecated."
        );
      }
      const localVarPath = `/api/v1/transactions/{ids}`.replace(
        `{${"ids"}}`,
        encodeURIComponent(String(ids))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"UpdateTransactionsParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Change a transaction\'s fields. You can change the following fields: \'isNew=true|false\' and/or \'isPotentialDuplicate=false\' and/or \'categoryId=<id>\' and/or \'labelIds=[<ids>]\'. To clear a transaction\'s category (so that it is no longer categorized), pass the value \'0\' as the categoryId. To clear the labels of the given transaction, pass an empty array of label identifiers: \'[]\'.
     * @summary Edit a transaction
     * @param {number} id Identifier of transaction
     * @param {UpdateTransactionsParams} body Update transactions parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editTransaction(
      id: number,
      body: UpdateTransactionsParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling editTransaction."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling editTransaction."
        );
      }
      const localVarPath = `/api/v1/transactions/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"UpdateTransactionsParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get transactions of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those transactions that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get and search all transactions
     * @param {'bankView' | 'userView'} view This parameter defines finAPI\&#39;s logical view on the transactions when querying them: \&#39;bankView\&#39; regards only the original transactions as they were received from the bank, without considering how the transactions might have gotten split by the user (see POST /transactions/&lt;id&gt;/split). This means that if a transaction is split into logical sub-transactions, then the service will still regard only the original transaction, and NOT the logical sub-transactions in its processing (though for convenience, the transactions will have the data of their sub-transactions included in the response). \&#39;userView\&#39; by contrast regards the transactions as they exist for the user. For transactions that have not been split into logical sub-transactions, there is no difference to the \&quot;bankView\&quot;. But for transaction that have been split into logical sub-transactions, the service will ONLY regard these sub-transactions, and not the originally received transaction (though for convenience, the sub-transactions will have the identifier of their original transaction included in the response).
     * @param {Array<number>} [ids] A comma-separated list of transaction identifiers. If specified, then only transactions whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {string} [search] If specified, then only those transactions will be contained in the result whose \&#39;purpose\&#39; or counterpart fields contain the given search string (the matching works case-insensitive). If no transactions contain the search string in any of these fields, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the searched fields in order for a transaction to get included into the result.
     * @param {string} [counterpart] If specified, then only those transactions will be contained in the result whose counterpart fields contain the given search string (the matching works case-insensitive). If no transactions contain the search string in any of the counterpart fields, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the searched fields in order for a transaction to get included into the result.
     * @param {string} [purpose] If specified, then only those transactions will be contained in the result whose purpose field contains the given search string (the matching works case-insensitive). If no transactions contain the search string in the purpose field, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the purpose in order for a transaction to get included into the result.
     * @param {Array<number>} [accountIds] A comma-separated list of account identifiers. If specified, then only transactions that relate to the given accounts will be regarded. If not specified, then all accounts will be regarded.
     * @param {string} [minBankBookingDate] Lower bound for a transaction\&#39;s booking date as returned by the bank (&#x3D; original booking date), in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;bankBookingDate\&#39; is equal to or later than the given date will be regarded.
     * @param {string} [maxBankBookingDate] Upper bound for a transaction\&#39;s booking date as returned by the bank (&#x3D; original booking date), in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;bankBookingDate\&#39; is equal to or earlier than the given date will be regarded.
     * @param {string} [minFinapiBookingDate] Lower bound for a transaction\&#39;s booking date as set by finAPI, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). For details about the meaning of the finAPI booking date, please see the field\&#39;s documentation in the service\&#39;s response.
     * @param {string} [maxFinapiBookingDate] Upper bound for a transaction\&#39;s booking date as set by finAPI, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). For details about the meaning of the finAPI booking date, please see the field\&#39;s documentation in the service\&#39;s response.
     * @param {number} [minAmount] If specified, then only transactions whose amount is equal to or greater than the given amount will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
     * @param {number} [maxAmount] If specified, then only transactions whose amount is equal to or less than the given amount will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
     * @param {'all' | 'income' | 'spending'} [direction] If specified, then only transactions with the given direction(s) will be regarded. Use \&#39;income\&#39; for regarding only received payments (amount &gt;&#x3D; 0), \&#39;spending\&#39; for regarding only outgoing payments (amount &lt; 0), or \&#39;all\&#39; to regard both directions. If not specified, the direction defaults to \&#39;all\&#39;.
     * @param {Array<number>} [labelIds] A comma-separated list of label identifiers. If specified, then only transactions that have been marked with at least one of the given labels will be contained in the result.
     * @param {Array<number>} [categoryIds] A comma-separated list of category identifiers. If specified, then the result will contain only transactions whose category is either one of the given categories, or - but only if the \&#39;includeChildCategories\&#39; flag is set to \&#39;true\&#39; - whose category is a sub-category of one of the given categories. To include transactions without any category, pass the value \&#39;0\&#39; as the categoryId.
     * @param {boolean} [includeChildCategories] This flag controls how the given \&#39;categoryIds\&#39; are handled. If set to \&#39;true\&#39;, then all transactions of a given categoryId, as well as all transactions of any of its sub-categories will be regarded. If set to \&#39;false\&#39;, then sub-categories of a given categoryId will not be regarded and only those transactions are regarded whose category matches one of the explicitly given categoryIds. The default value for this flag is \&#39;true\&#39;.
     * @param {boolean} [isNew] If specified, then only transactions that have their \&#39;isNew\&#39; flag set to true/false will be regarded.
     * @param {boolean} [isPotentialDuplicate] If specified, then only transactions that have their \&#39;isPotentialDuplicate\&#39; flag set to true/false will be regarded.
     * @param {boolean} [isAdjustingEntry] If specified, then only transactions that have their \&#39;isAdjustingEntry\&#39; flag set to true/false will be regarded.
     * @param {string} [minImportDate] Lower bound for a transaction\&#39;s import date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;importDate\&#39; is equal to or later than the given date will be regarded.
     * @param {string} [maxImportDate] Upper bound for a transaction\&#39;s import date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;importDate\&#39; is equal to or earlier than the given date will be regarded.
     * @param {number} [page] Result page that you want to retrieve.
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can use the following fields for ordering the response: \&#39;id\&#39;, \&#39;parentId\&#39;, \&#39;accountId\&#39;, \&#39;valueDate\&#39;, \&#39;bankBookingDate\&#39;, \&#39;finapiBookingDate\&#39;, \&#39;amount\&#39;, \&#39;purpose\&#39;, \&#39;counterpartName\&#39;, \&#39;counterpartAccountNumber\&#39;, \&#39;counterpartIban\&#39;, \&#39;counterpartBlz\&#39;, \&#39;counterpartBic\&#39;, \&#39;type\&#39;, \&#39;primanota\&#39;, \&#39;category.id\&#39;, \&#39;category.name\&#39;, \&#39;isPotentialDuplicate\&#39;, \&#39;isNew\&#39; and \&#39;importDate\&#39;. The default order for all services is \&#39;id,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: \&#39;/transactions?order&#x3D;finapiBookingDate,desc&amp;order&#x3D;counterpartName\&#39; will return the latest transactions first. If there are more transactions on the same day, then these transactions are ordered by the counterpart name (ascending). The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchAllTransactions(
      view: "bankView" | "userView",
      ids?: Array<number>,
      search?: string,
      counterpart?: string,
      purpose?: string,
      accountIds?: Array<number>,
      minBankBookingDate?: string,
      maxBankBookingDate?: string,
      minFinapiBookingDate?: string,
      maxFinapiBookingDate?: string,
      minAmount?: number,
      maxAmount?: number,
      direction?: "all" | "income" | "spending",
      labelIds?: Array<number>,
      categoryIds?: Array<number>,
      includeChildCategories?: boolean,
      isNew?: boolean,
      isPotentialDuplicate?: boolean,
      isAdjustingEntry?: boolean,
      minImportDate?: string,
      maxImportDate?: string,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'view' is not null or undefined
      if (view === null || view === undefined) {
        throw new RequiredError(
          "view",
          "Required parameter view was null or undefined when calling getAndSearchAllTransactions."
        );
      }
      const localVarPath = `/api/v1/transactions`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      if (ids) {
        localVarQueryParameter["ids"] = ids;
      }

      if (view !== undefined) {
        localVarQueryParameter["view"] = view;
      }

      if (search !== undefined) {
        localVarQueryParameter["search"] = search;
      }

      if (counterpart !== undefined) {
        localVarQueryParameter["counterpart"] = counterpart;
      }

      if (purpose !== undefined) {
        localVarQueryParameter["purpose"] = purpose;
      }

      if (accountIds) {
        localVarQueryParameter["accountIds"] = accountIds;
      }

      if (minBankBookingDate !== undefined) {
        localVarQueryParameter["minBankBookingDate"] = minBankBookingDate;
      }

      if (maxBankBookingDate !== undefined) {
        localVarQueryParameter["maxBankBookingDate"] = maxBankBookingDate;
      }

      if (minFinapiBookingDate !== undefined) {
        localVarQueryParameter["minFinapiBookingDate"] = minFinapiBookingDate;
      }

      if (maxFinapiBookingDate !== undefined) {
        localVarQueryParameter["maxFinapiBookingDate"] = maxFinapiBookingDate;
      }

      if (minAmount !== undefined) {
        localVarQueryParameter["minAmount"] = minAmount;
      }

      if (maxAmount !== undefined) {
        localVarQueryParameter["maxAmount"] = maxAmount;
      }

      if (direction !== undefined) {
        localVarQueryParameter["direction"] = direction;
      }

      if (labelIds) {
        localVarQueryParameter["labelIds"] = labelIds;
      }

      if (categoryIds) {
        localVarQueryParameter["categoryIds"] = categoryIds;
      }

      if (includeChildCategories !== undefined) {
        localVarQueryParameter[
          "includeChildCategories"
        ] = includeChildCategories;
      }

      if (isNew !== undefined) {
        localVarQueryParameter["isNew"] = isNew;
      }

      if (isPotentialDuplicate !== undefined) {
        localVarQueryParameter["isPotentialDuplicate"] = isPotentialDuplicate;
      }

      if (isAdjustingEntry !== undefined) {
        localVarQueryParameter["isAdjustingEntry"] = isAdjustingEntry;
      }

      if (minImportDate !== undefined) {
        localVarQueryParameter["minImportDate"] = minImportDate;
      }

      if (maxImportDate !== undefined) {
        localVarQueryParameter["maxImportDate"] = maxImportDate;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (perPage !== undefined) {
        localVarQueryParameter["perPage"] = perPage;
      }

      if (order) {
        localVarQueryParameter["order"] = order;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a list of multiple transactions of the user that is authorized by the access_token. Must pass the transactions\' identifiers and the user\'s access_token. Transactions whose identifiers do not exist or do not relate to the authorized user will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). WARNING: This service is deprecated and will be removed at some point. If you want to get multiple transactions, please instead use the service \'Get and search all transactions\', where you can pass a comma-separated list of identifiers.
     * @summary Get multiple transactions
     * @param {Array<number>} ids Comma-separated list of identifiers of requested transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleTransactions(
      ids: Array<number>,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'ids' is not null or undefined
      if (ids === null || ids === undefined) {
        throw new RequiredError(
          "ids",
          "Required parameter ids was null or undefined when calling getMultipleTransactions."
        );
      }
      const localVarPath = `/api/v1/transactions/{ids}`.replace(
        `{${"ids"}}`,
        encodeURIComponent(String(ids))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get a single transaction of the user that is authorized by the access_token. Must pass the transaction\'s identifier and the user\'s access_token.
     * @summary Get a transaction
     * @param {number} id Identifier of transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction(id: number, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getTransaction."
        );
      }
      const localVarPath = `/api/v1/transactions/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Restore a previously split transaction. Removes all of its sub-transactions.
     * @summary Restore a transaction
     * @param {number} id Transaction identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restoreTransaction(id: number, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling restoreTransaction."
        );
      }
      const localVarPath = `/api/v1/transactions/{id}/restore`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Split a transaction into several logical sub-transactions. If the given transaction is split already, all its current sub-transactions will get deleted before the new sub-transactions will get created.
     * @summary Split a transaction
     * @param {number} id Transaction identifier
     * @param {SplitTransactionsParams} body Split transactions parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    splitTransaction(
      id: number,
      body: SplitTransactionsParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling splitTransaction."
        );
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling splitTransaction."
        );
      }
      const localVarPath = `/api/v1/transactions/{id}/split`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"SplitTransactionsParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Triggers finAPI\'s background categorization process for all uncategorized transactions of the given bank connection(s) (or of all of the user\'s bank connections, if no bank connection identifiers are passed). The service returns as soon as the categorizations are scheduled. At this point, the bank connections will have their \'categorizationStatus\' set to \'PENDING\'. Use the service \"Get a bank connection\" or \"Get all bank connections\" to check when the categorization has finished (this is the case when the categorizationStatus has switched to \'READY\').<br/><br/>Note that if at least one of the target bank connections is currently locked at the time when you call this service (i.e. the bank connection is currently being updated, or another categorization is already scheduled for it), then no categorization will be triggered at all and the service will respond with HTTP code 422.<br/><br/>Please also note:<br/>&bull; finAPI\'s background categorization process is executed automatically whenever you import or update a bank connection (though in case of update, it will categorize only the new transactions, and not re-run categorization for previously imported transactions). This means that in general you do not have to call this service after an import or update. Use this service only when you wish to re-run the categorization of all existing uncategorized transactions.<br/>&bull; if you wish to just manually assign categories to transactions, please use the service \"Edit a transaction\" or \"Edit multiple transactions\" instead.
     * @summary Trigger categorization
     * @param {TriggerCategorizationParams} body Trigger categorization parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    triggerCategorization(
      body: TriggerCategorizationParams,
      options: any = {}
    ): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling triggerCategorization."
        );
      }
      const localVarPath = `/api/v1/transactions/triggerCategorization`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"TriggerCategorizationParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Delete a set, or the entirety, of transactions of the currently authorized user.
     * @summary Delete all transactions
     * @param {string} [maxDeletionDate] If specified, then only those transactions are being deleted whose \&#39;finapiBookingDate\&#39; is equal to or earlier to the given date. The date may not be in future, and must be given in the format \&#39;YYYY-MM-DD\&#39;. If not specified, then no date limitation will be in place for the deletion.
     * @param {boolean} [safeMode] When passing \&#39;true\&#39;, then only those transactions are being deleted where at least one of the following holds true: 1. The transaction belongs to a \&#39;demo connection\&#39;; 2. The transaction\&#39;s \&#39;potentialDuplicate\&#39; flag is set to TRUE; 3. The transaction is an adjusting entry (\&#39;Zwischensaldo\&#39; transaction) that was added by finAPI. When passing \&#39;false\&#39;, then finAPI will delete transactions independent of these characteristics. The default value for this parameter is \&#39;true\&#39;.
     * @param {boolean} [rememberDeletion] When passing \&#39;true\&#39;, then finAPI will make sure to not re-import deleted transactions on future account updates. When \&#39;false\&#39;, then deleted transactions might be re-imported. Default value for this parameter is \&#39;false\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllTransactions(
      maxDeletionDate?: string,
      safeMode?: boolean,
      rememberDeletion?: boolean,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<IdentifierList> {
      const localVarAxiosArgs = TransactionsApiAxiosParamCreator(
        configuration
      ).deleteAllTransactions(
        maxDeletionDate,
        safeMode,
        rememberDeletion,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Delete a single transaction of the user that is authorized by the access_token.<br/><br/> A transaction can only get deleted if at least one of the following holds true:<br/> &bull; The transaction belongs to a \'demo connection\'<br/> &bull; The transaction\'s \'potentialDuplicate\' flag is set to TRUE<br/> &bull; The transaction is an adjusting entry (\'Zwischensaldo\' transaction) that was added by finAPI<br/><br/>Note that the \'Delete all transactions\' service has additional functionality and allows you to delete transactions that you cannot delete with this service.
     * @summary Delete a transaction
     * @param {number} id Identifier of transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTransaction(
      id: number,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = TransactionsApiAxiosParamCreator(
        configuration
      ).deleteTransaction(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Edit one or multiple transactions. You can edit the following fields: \'isNew=true|false\' and/or \'isPotentialDuplicate=false\' and/or \'categoryId=<id>\' and/or \'labelIds=[<ids>]\'. To clear the category of the given transactions (so that they are no longer categorized), pass the value \'0\' as the categoryId. To clear the labels of the given transactions, pass an empty array of label identifiers: \'[]\'. The parameters \'categoryId\' and \'labelIds\' are forbidden if \'ids\' is NOT set (i.e. you cannot update the category or labels for ALL transactions). The result is a list of identifiers of only those transactions that have changed as a result of this service call.
     * @summary Edit multiple transactions
     * @param {UpdateMultipleTransactionsParams} body Update transactions parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editMultipleTransactions(
      body: UpdateMultipleTransactionsParams,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<IdentifierList> {
      const localVarAxiosArgs = TransactionsApiAxiosParamCreator(
        configuration
      ).editMultipleTransactions(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Change the fields of multiple transactions. You can change the following fields: \'isNew=true|false\' and/or \'isPotentialDuplicate=false\' and/or \'categoryId=<id>\' and/or \'labelIds=[<ids>]\'. The max number of input identifiers is limited to 100. To clear the category of the given transactions (so that they are no longer categorized), pass the value \'0\' as the categoryId. To clear the labels of the given transactions, pass an empty array of label identifiers: \'[]\'. The result is a list of identifiers of only those transactions that have changed as a result of this service call. WARNING: This service is deprecated and will be removed at some point. If you want to edit multiple transactions, please instead use the service \'Edit multiple transactions\', where you can pass a comma-separated list of identifiers.
     * @summary Edit multiple transactions (DEPRECATED)
     * @param {Array<number>} ids Comma-separated list of identifiers of updated transactions
     * @param {UpdateTransactionsParams} body Update transactions parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editMultipleTransactionsDeprecated(
      ids: Array<number>,
      body: UpdateTransactionsParams,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<IdentifierList> {
      const localVarAxiosArgs = TransactionsApiAxiosParamCreator(
        configuration
      ).editMultipleTransactionsDeprecated(ids, body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Change a transaction\'s fields. You can change the following fields: \'isNew=true|false\' and/or \'isPotentialDuplicate=false\' and/or \'categoryId=<id>\' and/or \'labelIds=[<ids>]\'. To clear a transaction\'s category (so that it is no longer categorized), pass the value \'0\' as the categoryId. To clear the labels of the given transaction, pass an empty array of label identifiers: \'[]\'.
     * @summary Edit a transaction
     * @param {number} id Identifier of transaction
     * @param {UpdateTransactionsParams} body Update transactions parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editTransaction(
      id: number,
      body: UpdateTransactionsParams,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transaction> {
      const localVarAxiosArgs = TransactionsApiAxiosParamCreator(
        configuration
      ).editTransaction(id, body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get transactions of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those transactions that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get and search all transactions
     * @param {'bankView' | 'userView'} view This parameter defines finAPI\&#39;s logical view on the transactions when querying them: \&#39;bankView\&#39; regards only the original transactions as they were received from the bank, without considering how the transactions might have gotten split by the user (see POST /transactions/&lt;id&gt;/split). This means that if a transaction is split into logical sub-transactions, then the service will still regard only the original transaction, and NOT the logical sub-transactions in its processing (though for convenience, the transactions will have the data of their sub-transactions included in the response). \&#39;userView\&#39; by contrast regards the transactions as they exist for the user. For transactions that have not been split into logical sub-transactions, there is no difference to the \&quot;bankView\&quot;. But for transaction that have been split into logical sub-transactions, the service will ONLY regard these sub-transactions, and not the originally received transaction (though for convenience, the sub-transactions will have the identifier of their original transaction included in the response).
     * @param {Array<number>} [ids] A comma-separated list of transaction identifiers. If specified, then only transactions whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {string} [search] If specified, then only those transactions will be contained in the result whose \&#39;purpose\&#39; or counterpart fields contain the given search string (the matching works case-insensitive). If no transactions contain the search string in any of these fields, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the searched fields in order for a transaction to get included into the result.
     * @param {string} [counterpart] If specified, then only those transactions will be contained in the result whose counterpart fields contain the given search string (the matching works case-insensitive). If no transactions contain the search string in any of the counterpart fields, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the searched fields in order for a transaction to get included into the result.
     * @param {string} [purpose] If specified, then only those transactions will be contained in the result whose purpose field contains the given search string (the matching works case-insensitive). If no transactions contain the search string in the purpose field, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the purpose in order for a transaction to get included into the result.
     * @param {Array<number>} [accountIds] A comma-separated list of account identifiers. If specified, then only transactions that relate to the given accounts will be regarded. If not specified, then all accounts will be regarded.
     * @param {string} [minBankBookingDate] Lower bound for a transaction\&#39;s booking date as returned by the bank (&#x3D; original booking date), in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;bankBookingDate\&#39; is equal to or later than the given date will be regarded.
     * @param {string} [maxBankBookingDate] Upper bound for a transaction\&#39;s booking date as returned by the bank (&#x3D; original booking date), in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;bankBookingDate\&#39; is equal to or earlier than the given date will be regarded.
     * @param {string} [minFinapiBookingDate] Lower bound for a transaction\&#39;s booking date as set by finAPI, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). For details about the meaning of the finAPI booking date, please see the field\&#39;s documentation in the service\&#39;s response.
     * @param {string} [maxFinapiBookingDate] Upper bound for a transaction\&#39;s booking date as set by finAPI, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). For details about the meaning of the finAPI booking date, please see the field\&#39;s documentation in the service\&#39;s response.
     * @param {number} [minAmount] If specified, then only transactions whose amount is equal to or greater than the given amount will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
     * @param {number} [maxAmount] If specified, then only transactions whose amount is equal to or less than the given amount will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
     * @param {'all' | 'income' | 'spending'} [direction] If specified, then only transactions with the given direction(s) will be regarded. Use \&#39;income\&#39; for regarding only received payments (amount &gt;&#x3D; 0), \&#39;spending\&#39; for regarding only outgoing payments (amount &lt; 0), or \&#39;all\&#39; to regard both directions. If not specified, the direction defaults to \&#39;all\&#39;.
     * @param {Array<number>} [labelIds] A comma-separated list of label identifiers. If specified, then only transactions that have been marked with at least one of the given labels will be contained in the result.
     * @param {Array<number>} [categoryIds] A comma-separated list of category identifiers. If specified, then the result will contain only transactions whose category is either one of the given categories, or - but only if the \&#39;includeChildCategories\&#39; flag is set to \&#39;true\&#39; - whose category is a sub-category of one of the given categories. To include transactions without any category, pass the value \&#39;0\&#39; as the categoryId.
     * @param {boolean} [includeChildCategories] This flag controls how the given \&#39;categoryIds\&#39; are handled. If set to \&#39;true\&#39;, then all transactions of a given categoryId, as well as all transactions of any of its sub-categories will be regarded. If set to \&#39;false\&#39;, then sub-categories of a given categoryId will not be regarded and only those transactions are regarded whose category matches one of the explicitly given categoryIds. The default value for this flag is \&#39;true\&#39;.
     * @param {boolean} [isNew] If specified, then only transactions that have their \&#39;isNew\&#39; flag set to true/false will be regarded.
     * @param {boolean} [isPotentialDuplicate] If specified, then only transactions that have their \&#39;isPotentialDuplicate\&#39; flag set to true/false will be regarded.
     * @param {boolean} [isAdjustingEntry] If specified, then only transactions that have their \&#39;isAdjustingEntry\&#39; flag set to true/false will be regarded.
     * @param {string} [minImportDate] Lower bound for a transaction\&#39;s import date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;importDate\&#39; is equal to or later than the given date will be regarded.
     * @param {string} [maxImportDate] Upper bound for a transaction\&#39;s import date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;importDate\&#39; is equal to or earlier than the given date will be regarded.
     * @param {number} [page] Result page that you want to retrieve.
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can use the following fields for ordering the response: \&#39;id\&#39;, \&#39;parentId\&#39;, \&#39;accountId\&#39;, \&#39;valueDate\&#39;, \&#39;bankBookingDate\&#39;, \&#39;finapiBookingDate\&#39;, \&#39;amount\&#39;, \&#39;purpose\&#39;, \&#39;counterpartName\&#39;, \&#39;counterpartAccountNumber\&#39;, \&#39;counterpartIban\&#39;, \&#39;counterpartBlz\&#39;, \&#39;counterpartBic\&#39;, \&#39;type\&#39;, \&#39;primanota\&#39;, \&#39;category.id\&#39;, \&#39;category.name\&#39;, \&#39;isPotentialDuplicate\&#39;, \&#39;isNew\&#39; and \&#39;importDate\&#39;. The default order for all services is \&#39;id,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: \&#39;/transactions?order&#x3D;finapiBookingDate,desc&amp;order&#x3D;counterpartName\&#39; will return the latest transactions first. If there are more transactions on the same day, then these transactions are ordered by the counterpart name (ascending). The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchAllTransactions(
      view: "bankView" | "userView",
      ids?: Array<number>,
      search?: string,
      counterpart?: string,
      purpose?: string,
      accountIds?: Array<number>,
      minBankBookingDate?: string,
      maxBankBookingDate?: string,
      minFinapiBookingDate?: string,
      maxFinapiBookingDate?: string,
      minAmount?: number,
      maxAmount?: number,
      direction?: "all" | "income" | "spending",
      labelIds?: Array<number>,
      categoryIds?: Array<number>,
      includeChildCategories?: boolean,
      isNew?: boolean,
      isPotentialDuplicate?: boolean,
      isAdjustingEntry?: boolean,
      minImportDate?: string,
      maxImportDate?: string,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<PageableTransactionList> {
      const localVarAxiosArgs = TransactionsApiAxiosParamCreator(
        configuration
      ).getAndSearchAllTransactions(
        view,
        ids,
        search,
        counterpart,
        purpose,
        accountIds,
        minBankBookingDate,
        maxBankBookingDate,
        minFinapiBookingDate,
        maxFinapiBookingDate,
        minAmount,
        maxAmount,
        direction,
        labelIds,
        categoryIds,
        includeChildCategories,
        isNew,
        isPotentialDuplicate,
        isAdjustingEntry,
        minImportDate,
        maxImportDate,
        page,
        perPage,
        order,
        options
      );
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get a list of multiple transactions of the user that is authorized by the access_token. Must pass the transactions\' identifiers and the user\'s access_token. Transactions whose identifiers do not exist or do not relate to the authorized user will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). WARNING: This service is deprecated and will be removed at some point. If you want to get multiple transactions, please instead use the service \'Get and search all transactions\', where you can pass a comma-separated list of identifiers.
     * @summary Get multiple transactions
     * @param {Array<number>} ids Comma-separated list of identifiers of requested transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleTransactions(
      ids: Array<number>,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<TransactionList> {
      const localVarAxiosArgs = TransactionsApiAxiosParamCreator(
        configuration
      ).getMultipleTransactions(ids, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get a single transaction of the user that is authorized by the access_token. Must pass the transaction\'s identifier and the user\'s access_token.
     * @summary Get a transaction
     * @param {number} id Identifier of transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction(
      id: number,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transaction> {
      const localVarAxiosArgs = TransactionsApiAxiosParamCreator(
        configuration
      ).getTransaction(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Restore a previously split transaction. Removes all of its sub-transactions.
     * @summary Restore a transaction
     * @param {number} id Transaction identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restoreTransaction(
      id: number,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transaction> {
      const localVarAxiosArgs = TransactionsApiAxiosParamCreator(
        configuration
      ).restoreTransaction(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Split a transaction into several logical sub-transactions. If the given transaction is split already, all its current sub-transactions will get deleted before the new sub-transactions will get created.
     * @summary Split a transaction
     * @param {number} id Transaction identifier
     * @param {SplitTransactionsParams} body Split transactions parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    splitTransaction(
      id: number,
      body: SplitTransactionsParams,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transaction> {
      const localVarAxiosArgs = TransactionsApiAxiosParamCreator(
        configuration
      ).splitTransaction(id, body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Triggers finAPI\'s background categorization process for all uncategorized transactions of the given bank connection(s) (or of all of the user\'s bank connections, if no bank connection identifiers are passed). The service returns as soon as the categorizations are scheduled. At this point, the bank connections will have their \'categorizationStatus\' set to \'PENDING\'. Use the service \"Get a bank connection\" or \"Get all bank connections\" to check when the categorization has finished (this is the case when the categorizationStatus has switched to \'READY\').<br/><br/>Note that if at least one of the target bank connections is currently locked at the time when you call this service (i.e. the bank connection is currently being updated, or another categorization is already scheduled for it), then no categorization will be triggered at all and the service will respond with HTTP code 422.<br/><br/>Please also note:<br/>&bull; finAPI\'s background categorization process is executed automatically whenever you import or update a bank connection (though in case of update, it will categorize only the new transactions, and not re-run categorization for previously imported transactions). This means that in general you do not have to call this service after an import or update. Use this service only when you wish to re-run the categorization of all existing uncategorized transactions.<br/>&bull; if you wish to just manually assign categories to transactions, please use the service \"Edit a transaction\" or \"Edit multiple transactions\" instead.
     * @summary Trigger categorization
     * @param {TriggerCategorizationParams} body Trigger categorization parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    triggerCategorization(
      body: TriggerCategorizationParams,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = TransactionsApiAxiosParamCreator(
        configuration
      ).triggerCategorization(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    }
  };
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Delete a set, or the entirety, of transactions of the currently authorized user.
     * @summary Delete all transactions
     * @param {string} [maxDeletionDate] If specified, then only those transactions are being deleted whose \&#39;finapiBookingDate\&#39; is equal to or earlier to the given date. The date may not be in future, and must be given in the format \&#39;YYYY-MM-DD\&#39;. If not specified, then no date limitation will be in place for the deletion.
     * @param {boolean} [safeMode] When passing \&#39;true\&#39;, then only those transactions are being deleted where at least one of the following holds true: 1. The transaction belongs to a \&#39;demo connection\&#39;; 2. The transaction\&#39;s \&#39;potentialDuplicate\&#39; flag is set to TRUE; 3. The transaction is an adjusting entry (\&#39;Zwischensaldo\&#39; transaction) that was added by finAPI. When passing \&#39;false\&#39;, then finAPI will delete transactions independent of these characteristics. The default value for this parameter is \&#39;true\&#39;.
     * @param {boolean} [rememberDeletion] When passing \&#39;true\&#39;, then finAPI will make sure to not re-import deleted transactions on future account updates. When \&#39;false\&#39;, then deleted transactions might be re-imported. Default value for this parameter is \&#39;false\&#39;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllTransactions(
      maxDeletionDate?: string,
      safeMode?: boolean,
      rememberDeletion?: boolean,
      options?: any
    ) {
      return TransactionsApiFp(configuration).deleteAllTransactions(
        maxDeletionDate,
        safeMode,
        rememberDeletion,
        options
      )(axios, basePath);
    },
    /**
     * Delete a single transaction of the user that is authorized by the access_token.<br/><br/> A transaction can only get deleted if at least one of the following holds true:<br/> &bull; The transaction belongs to a \'demo connection\'<br/> &bull; The transaction\'s \'potentialDuplicate\' flag is set to TRUE<br/> &bull; The transaction is an adjusting entry (\'Zwischensaldo\' transaction) that was added by finAPI<br/><br/>Note that the \'Delete all transactions\' service has additional functionality and allows you to delete transactions that you cannot delete with this service.
     * @summary Delete a transaction
     * @param {number} id Identifier of transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteTransaction(id: number, options?: any) {
      return TransactionsApiFp(configuration).deleteTransaction(id, options)(
        axios,
        basePath
      );
    },
    /**
     * Edit one or multiple transactions. You can edit the following fields: \'isNew=true|false\' and/or \'isPotentialDuplicate=false\' and/or \'categoryId=<id>\' and/or \'labelIds=[<ids>]\'. To clear the category of the given transactions (so that they are no longer categorized), pass the value \'0\' as the categoryId. To clear the labels of the given transactions, pass an empty array of label identifiers: \'[]\'. The parameters \'categoryId\' and \'labelIds\' are forbidden if \'ids\' is NOT set (i.e. you cannot update the category or labels for ALL transactions). The result is a list of identifiers of only those transactions that have changed as a result of this service call.
     * @summary Edit multiple transactions
     * @param {UpdateMultipleTransactionsParams} body Update transactions parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editMultipleTransactions(
      body: UpdateMultipleTransactionsParams,
      options?: any
    ) {
      return TransactionsApiFp(configuration).editMultipleTransactions(
        body,
        options
      )(axios, basePath);
    },
    /**
     * Change the fields of multiple transactions. You can change the following fields: \'isNew=true|false\' and/or \'isPotentialDuplicate=false\' and/or \'categoryId=<id>\' and/or \'labelIds=[<ids>]\'. The max number of input identifiers is limited to 100. To clear the category of the given transactions (so that they are no longer categorized), pass the value \'0\' as the categoryId. To clear the labels of the given transactions, pass an empty array of label identifiers: \'[]\'. The result is a list of identifiers of only those transactions that have changed as a result of this service call. WARNING: This service is deprecated and will be removed at some point. If you want to edit multiple transactions, please instead use the service \'Edit multiple transactions\', where you can pass a comma-separated list of identifiers.
     * @summary Edit multiple transactions (DEPRECATED)
     * @param {Array<number>} ids Comma-separated list of identifiers of updated transactions
     * @param {UpdateTransactionsParams} body Update transactions parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editMultipleTransactionsDeprecated(
      ids: Array<number>,
      body: UpdateTransactionsParams,
      options?: any
    ) {
      return TransactionsApiFp(
        configuration
      ).editMultipleTransactionsDeprecated(ids, body, options)(axios, basePath);
    },
    /**
     * Change a transaction\'s fields. You can change the following fields: \'isNew=true|false\' and/or \'isPotentialDuplicate=false\' and/or \'categoryId=<id>\' and/or \'labelIds=[<ids>]\'. To clear a transaction\'s category (so that it is no longer categorized), pass the value \'0\' as the categoryId. To clear the labels of the given transaction, pass an empty array of label identifiers: \'[]\'.
     * @summary Edit a transaction
     * @param {number} id Identifier of transaction
     * @param {UpdateTransactionsParams} body Update transactions parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editTransaction(id: number, body: UpdateTransactionsParams, options?: any) {
      return TransactionsApiFp(configuration).editTransaction(
        id,
        body,
        options
      )(axios, basePath);
    },
    /**
     * Get transactions of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those transactions that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
     * @summary Get and search all transactions
     * @param {'bankView' | 'userView'} view This parameter defines finAPI\&#39;s logical view on the transactions when querying them: \&#39;bankView\&#39; regards only the original transactions as they were received from the bank, without considering how the transactions might have gotten split by the user (see POST /transactions/&lt;id&gt;/split). This means that if a transaction is split into logical sub-transactions, then the service will still regard only the original transaction, and NOT the logical sub-transactions in its processing (though for convenience, the transactions will have the data of their sub-transactions included in the response). \&#39;userView\&#39; by contrast regards the transactions as they exist for the user. For transactions that have not been split into logical sub-transactions, there is no difference to the \&quot;bankView\&quot;. But for transaction that have been split into logical sub-transactions, the service will ONLY regard these sub-transactions, and not the originally received transaction (though for convenience, the sub-transactions will have the identifier of their original transaction included in the response).
     * @param {Array<number>} [ids] A comma-separated list of transaction identifiers. If specified, then only transactions whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
     * @param {string} [search] If specified, then only those transactions will be contained in the result whose \&#39;purpose\&#39; or counterpart fields contain the given search string (the matching works case-insensitive). If no transactions contain the search string in any of these fields, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the searched fields in order for a transaction to get included into the result.
     * @param {string} [counterpart] If specified, then only those transactions will be contained in the result whose counterpart fields contain the given search string (the matching works case-insensitive). If no transactions contain the search string in any of the counterpart fields, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the searched fields in order for a transaction to get included into the result.
     * @param {string} [purpose] If specified, then only those transactions will be contained in the result whose purpose field contains the given search string (the matching works case-insensitive). If no transactions contain the search string in the purpose field, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the purpose in order for a transaction to get included into the result.
     * @param {Array<number>} [accountIds] A comma-separated list of account identifiers. If specified, then only transactions that relate to the given accounts will be regarded. If not specified, then all accounts will be regarded.
     * @param {string} [minBankBookingDate] Lower bound for a transaction\&#39;s booking date as returned by the bank (&#x3D; original booking date), in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;bankBookingDate\&#39; is equal to or later than the given date will be regarded.
     * @param {string} [maxBankBookingDate] Upper bound for a transaction\&#39;s booking date as returned by the bank (&#x3D; original booking date), in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;bankBookingDate\&#39; is equal to or earlier than the given date will be regarded.
     * @param {string} [minFinapiBookingDate] Lower bound for a transaction\&#39;s booking date as set by finAPI, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). For details about the meaning of the finAPI booking date, please see the field\&#39;s documentation in the service\&#39;s response.
     * @param {string} [maxFinapiBookingDate] Upper bound for a transaction\&#39;s booking date as set by finAPI, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). For details about the meaning of the finAPI booking date, please see the field\&#39;s documentation in the service\&#39;s response.
     * @param {number} [minAmount] If specified, then only transactions whose amount is equal to or greater than the given amount will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
     * @param {number} [maxAmount] If specified, then only transactions whose amount is equal to or less than the given amount will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
     * @param {'all' | 'income' | 'spending'} [direction] If specified, then only transactions with the given direction(s) will be regarded. Use \&#39;income\&#39; for regarding only received payments (amount &gt;&#x3D; 0), \&#39;spending\&#39; for regarding only outgoing payments (amount &lt; 0), or \&#39;all\&#39; to regard both directions. If not specified, the direction defaults to \&#39;all\&#39;.
     * @param {Array<number>} [labelIds] A comma-separated list of label identifiers. If specified, then only transactions that have been marked with at least one of the given labels will be contained in the result.
     * @param {Array<number>} [categoryIds] A comma-separated list of category identifiers. If specified, then the result will contain only transactions whose category is either one of the given categories, or - but only if the \&#39;includeChildCategories\&#39; flag is set to \&#39;true\&#39; - whose category is a sub-category of one of the given categories. To include transactions without any category, pass the value \&#39;0\&#39; as the categoryId.
     * @param {boolean} [includeChildCategories] This flag controls how the given \&#39;categoryIds\&#39; are handled. If set to \&#39;true\&#39;, then all transactions of a given categoryId, as well as all transactions of any of its sub-categories will be regarded. If set to \&#39;false\&#39;, then sub-categories of a given categoryId will not be regarded and only those transactions are regarded whose category matches one of the explicitly given categoryIds. The default value for this flag is \&#39;true\&#39;.
     * @param {boolean} [isNew] If specified, then only transactions that have their \&#39;isNew\&#39; flag set to true/false will be regarded.
     * @param {boolean} [isPotentialDuplicate] If specified, then only transactions that have their \&#39;isPotentialDuplicate\&#39; flag set to true/false will be regarded.
     * @param {boolean} [isAdjustingEntry] If specified, then only transactions that have their \&#39;isAdjustingEntry\&#39; flag set to true/false will be regarded.
     * @param {string} [minImportDate] Lower bound for a transaction\&#39;s import date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;importDate\&#39; is equal to or later than the given date will be regarded.
     * @param {string} [maxImportDate] Upper bound for a transaction\&#39;s import date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;importDate\&#39; is equal to or earlier than the given date will be regarded.
     * @param {number} [page] Result page that you want to retrieve.
     * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
     * @param {Array<string>} [order] Determines the order of the results. You can use the following fields for ordering the response: \&#39;id\&#39;, \&#39;parentId\&#39;, \&#39;accountId\&#39;, \&#39;valueDate\&#39;, \&#39;bankBookingDate\&#39;, \&#39;finapiBookingDate\&#39;, \&#39;amount\&#39;, \&#39;purpose\&#39;, \&#39;counterpartName\&#39;, \&#39;counterpartAccountNumber\&#39;, \&#39;counterpartIban\&#39;, \&#39;counterpartBlz\&#39;, \&#39;counterpartBic\&#39;, \&#39;type\&#39;, \&#39;primanota\&#39;, \&#39;category.id\&#39;, \&#39;category.name\&#39;, \&#39;isPotentialDuplicate\&#39;, \&#39;isNew\&#39; and \&#39;importDate\&#39;. The default order for all services is \&#39;id,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: \&#39;/transactions?order&#x3D;finapiBookingDate,desc&amp;order&#x3D;counterpartName\&#39; will return the latest transactions first. If there are more transactions on the same day, then these transactions are ordered by the counterpart name (ascending). The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAndSearchAllTransactions(
      view: "bankView" | "userView",
      ids?: Array<number>,
      search?: string,
      counterpart?: string,
      purpose?: string,
      accountIds?: Array<number>,
      minBankBookingDate?: string,
      maxBankBookingDate?: string,
      minFinapiBookingDate?: string,
      maxFinapiBookingDate?: string,
      minAmount?: number,
      maxAmount?: number,
      direction?: "all" | "income" | "spending",
      labelIds?: Array<number>,
      categoryIds?: Array<number>,
      includeChildCategories?: boolean,
      isNew?: boolean,
      isPotentialDuplicate?: boolean,
      isAdjustingEntry?: boolean,
      minImportDate?: string,
      maxImportDate?: string,
      page?: number,
      perPage?: number,
      order?: Array<string>,
      options?: any
    ) {
      return TransactionsApiFp(configuration).getAndSearchAllTransactions(
        view,
        ids,
        search,
        counterpart,
        purpose,
        accountIds,
        minBankBookingDate,
        maxBankBookingDate,
        minFinapiBookingDate,
        maxFinapiBookingDate,
        minAmount,
        maxAmount,
        direction,
        labelIds,
        categoryIds,
        includeChildCategories,
        isNew,
        isPotentialDuplicate,
        isAdjustingEntry,
        minImportDate,
        maxImportDate,
        page,
        perPage,
        order,
        options
      )(axios, basePath);
    },
    /**
     * Get a list of multiple transactions of the user that is authorized by the access_token. Must pass the transactions\' identifiers and the user\'s access_token. Transactions whose identifiers do not exist or do not relate to the authorized user will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). WARNING: This service is deprecated and will be removed at some point. If you want to get multiple transactions, please instead use the service \'Get and search all transactions\', where you can pass a comma-separated list of identifiers.
     * @summary Get multiple transactions
     * @param {Array<number>} ids Comma-separated list of identifiers of requested transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleTransactions(ids: Array<number>, options?: any) {
      return TransactionsApiFp(configuration).getMultipleTransactions(
        ids,
        options
      )(axios, basePath);
    },
    /**
     * Get a single transaction of the user that is authorized by the access_token. Must pass the transaction\'s identifier and the user\'s access_token.
     * @summary Get a transaction
     * @param {number} id Identifier of transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction(id: number, options?: any) {
      return TransactionsApiFp(configuration).getTransaction(id, options)(
        axios,
        basePath
      );
    },
    /**
     * Restore a previously split transaction. Removes all of its sub-transactions.
     * @summary Restore a transaction
     * @param {number} id Transaction identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    restoreTransaction(id: number, options?: any) {
      return TransactionsApiFp(configuration).restoreTransaction(id, options)(
        axios,
        basePath
      );
    },
    /**
     * Split a transaction into several logical sub-transactions. If the given transaction is split already, all its current sub-transactions will get deleted before the new sub-transactions will get created.
     * @summary Split a transaction
     * @param {number} id Transaction identifier
     * @param {SplitTransactionsParams} body Split transactions parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    splitTransaction(id: number, body: SplitTransactionsParams, options?: any) {
      return TransactionsApiFp(configuration).splitTransaction(
        id,
        body,
        options
      )(axios, basePath);
    },
    /**
     * Triggers finAPI\'s background categorization process for all uncategorized transactions of the given bank connection(s) (or of all of the user\'s bank connections, if no bank connection identifiers are passed). The service returns as soon as the categorizations are scheduled. At this point, the bank connections will have their \'categorizationStatus\' set to \'PENDING\'. Use the service \"Get a bank connection\" or \"Get all bank connections\" to check when the categorization has finished (this is the case when the categorizationStatus has switched to \'READY\').<br/><br/>Note that if at least one of the target bank connections is currently locked at the time when you call this service (i.e. the bank connection is currently being updated, or another categorization is already scheduled for it), then no categorization will be triggered at all and the service will respond with HTTP code 422.<br/><br/>Please also note:<br/>&bull; finAPI\'s background categorization process is executed automatically whenever you import or update a bank connection (though in case of update, it will categorize only the new transactions, and not re-run categorization for previously imported transactions). This means that in general you do not have to call this service after an import or update. Use this service only when you wish to re-run the categorization of all existing uncategorized transactions.<br/>&bull; if you wish to just manually assign categories to transactions, please use the service \"Edit a transaction\" or \"Edit multiple transactions\" instead.
     * @summary Trigger categorization
     * @param {TriggerCategorizationParams} body Trigger categorization parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    triggerCategorization(body: TriggerCategorizationParams, options?: any) {
      return TransactionsApiFp(configuration).triggerCategorization(
        body,
        options
      )(axios, basePath);
    }
  };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
  /**
   * Delete a set, or the entirety, of transactions of the currently authorized user.
   * @summary Delete all transactions
   * @param {string} [maxDeletionDate] If specified, then only those transactions are being deleted whose \&#39;finapiBookingDate\&#39; is equal to or earlier to the given date. The date may not be in future, and must be given in the format \&#39;YYYY-MM-DD\&#39;. If not specified, then no date limitation will be in place for the deletion.
   * @param {boolean} [safeMode] When passing \&#39;true\&#39;, then only those transactions are being deleted where at least one of the following holds true: 1. The transaction belongs to a \&#39;demo connection\&#39;; 2. The transaction\&#39;s \&#39;potentialDuplicate\&#39; flag is set to TRUE; 3. The transaction is an adjusting entry (\&#39;Zwischensaldo\&#39; transaction) that was added by finAPI. When passing \&#39;false\&#39;, then finAPI will delete transactions independent of these characteristics. The default value for this parameter is \&#39;true\&#39;.
   * @param {boolean} [rememberDeletion] When passing \&#39;true\&#39;, then finAPI will make sure to not re-import deleted transactions on future account updates. When \&#39;false\&#39;, then deleted transactions might be re-imported. Default value for this parameter is \&#39;false\&#39;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public deleteAllTransactions(
    maxDeletionDate?: string,
    safeMode?: boolean,
    rememberDeletion?: boolean,
    options?: any
  ) {
    return TransactionsApiFp(this.configuration).deleteAllTransactions(
      maxDeletionDate,
      safeMode,
      rememberDeletion,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Delete a single transaction of the user that is authorized by the access_token.<br/><br/> A transaction can only get deleted if at least one of the following holds true:<br/> &bull; The transaction belongs to a \'demo connection\'<br/> &bull; The transaction\'s \'potentialDuplicate\' flag is set to TRUE<br/> &bull; The transaction is an adjusting entry (\'Zwischensaldo\' transaction) that was added by finAPI<br/><br/>Note that the \'Delete all transactions\' service has additional functionality and allows you to delete transactions that you cannot delete with this service.
   * @summary Delete a transaction
   * @param {number} id Identifier of transaction
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public deleteTransaction(id: number, options?: any) {
    return TransactionsApiFp(this.configuration).deleteTransaction(id, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Edit one or multiple transactions. You can edit the following fields: \'isNew=true|false\' and/or \'isPotentialDuplicate=false\' and/or \'categoryId=<id>\' and/or \'labelIds=[<ids>]\'. To clear the category of the given transactions (so that they are no longer categorized), pass the value \'0\' as the categoryId. To clear the labels of the given transactions, pass an empty array of label identifiers: \'[]\'. The parameters \'categoryId\' and \'labelIds\' are forbidden if \'ids\' is NOT set (i.e. you cannot update the category or labels for ALL transactions). The result is a list of identifiers of only those transactions that have changed as a result of this service call.
   * @summary Edit multiple transactions
   * @param {UpdateMultipleTransactionsParams} body Update transactions parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public editMultipleTransactions(
    body: UpdateMultipleTransactionsParams,
    options?: any
  ) {
    return TransactionsApiFp(this.configuration).editMultipleTransactions(
      body,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Change the fields of multiple transactions. You can change the following fields: \'isNew=true|false\' and/or \'isPotentialDuplicate=false\' and/or \'categoryId=<id>\' and/or \'labelIds=[<ids>]\'. The max number of input identifiers is limited to 100. To clear the category of the given transactions (so that they are no longer categorized), pass the value \'0\' as the categoryId. To clear the labels of the given transactions, pass an empty array of label identifiers: \'[]\'. The result is a list of identifiers of only those transactions that have changed as a result of this service call. WARNING: This service is deprecated and will be removed at some point. If you want to edit multiple transactions, please instead use the service \'Edit multiple transactions\', where you can pass a comma-separated list of identifiers.
   * @summary Edit multiple transactions (DEPRECATED)
   * @param {Array<number>} ids Comma-separated list of identifiers of updated transactions
   * @param {UpdateTransactionsParams} body Update transactions parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public editMultipleTransactionsDeprecated(
    ids: Array<number>,
    body: UpdateTransactionsParams,
    options?: any
  ) {
    return TransactionsApiFp(
      this.configuration
    ).editMultipleTransactionsDeprecated(ids, body, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Change a transaction\'s fields. You can change the following fields: \'isNew=true|false\' and/or \'isPotentialDuplicate=false\' and/or \'categoryId=<id>\' and/or \'labelIds=[<ids>]\'. To clear a transaction\'s category (so that it is no longer categorized), pass the value \'0\' as the categoryId. To clear the labels of the given transaction, pass an empty array of label identifiers: \'[]\'.
   * @summary Edit a transaction
   * @param {number} id Identifier of transaction
   * @param {UpdateTransactionsParams} body Update transactions parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public editTransaction(
    id: number,
    body: UpdateTransactionsParams,
    options?: any
  ) {
    return TransactionsApiFp(this.configuration).editTransaction(
      id,
      body,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Get transactions of the user that is authorized by the access_token. Must pass the user\'s access_token. You can set optional search criteria to get only those transactions that you are interested in. If you do not specify any search criteria, then this service functions as a \'get all\' service.
   * @summary Get and search all transactions
   * @param {'bankView' | 'userView'} view This parameter defines finAPI\&#39;s logical view on the transactions when querying them: \&#39;bankView\&#39; regards only the original transactions as they were received from the bank, without considering how the transactions might have gotten split by the user (see POST /transactions/&lt;id&gt;/split). This means that if a transaction is split into logical sub-transactions, then the service will still regard only the original transaction, and NOT the logical sub-transactions in its processing (though for convenience, the transactions will have the data of their sub-transactions included in the response). \&#39;userView\&#39; by contrast regards the transactions as they exist for the user. For transactions that have not been split into logical sub-transactions, there is no difference to the \&quot;bankView\&quot;. But for transaction that have been split into logical sub-transactions, the service will ONLY regard these sub-transactions, and not the originally received transaction (though for convenience, the sub-transactions will have the identifier of their original transaction included in the response).
   * @param {Array<number>} [ids] A comma-separated list of transaction identifiers. If specified, then only transactions whose identifier match any of the given identifiers will be regarded. The maximum number of identifiers is 1000.
   * @param {string} [search] If specified, then only those transactions will be contained in the result whose \&#39;purpose\&#39; or counterpart fields contain the given search string (the matching works case-insensitive). If no transactions contain the search string in any of these fields, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the searched fields in order for a transaction to get included into the result.
   * @param {string} [counterpart] If specified, then only those transactions will be contained in the result whose counterpart fields contain the given search string (the matching works case-insensitive). If no transactions contain the search string in any of the counterpart fields, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the searched fields in order for a transaction to get included into the result.
   * @param {string} [purpose] If specified, then only those transactions will be contained in the result whose purpose field contains the given search string (the matching works case-insensitive). If no transactions contain the search string in the purpose field, then the result will be an empty list. NOTE: If the given search string consists of several terms (separated by whitespace), then ALL of these terms must be contained in the purpose in order for a transaction to get included into the result.
   * @param {Array<number>} [accountIds] A comma-separated list of account identifiers. If specified, then only transactions that relate to the given accounts will be regarded. If not specified, then all accounts will be regarded.
   * @param {string} [minBankBookingDate] Lower bound for a transaction\&#39;s booking date as returned by the bank (&#x3D; original booking date), in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;bankBookingDate\&#39; is equal to or later than the given date will be regarded.
   * @param {string} [maxBankBookingDate] Upper bound for a transaction\&#39;s booking date as returned by the bank (&#x3D; original booking date), in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;bankBookingDate\&#39; is equal to or earlier than the given date will be regarded.
   * @param {string} [minFinapiBookingDate] Lower bound for a transaction\&#39;s booking date as set by finAPI, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). For details about the meaning of the finAPI booking date, please see the field\&#39;s documentation in the service\&#39;s response.
   * @param {string} [maxFinapiBookingDate] Upper bound for a transaction\&#39;s booking date as set by finAPI, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). For details about the meaning of the finAPI booking date, please see the field\&#39;s documentation in the service\&#39;s response.
   * @param {number} [minAmount] If specified, then only transactions whose amount is equal to or greater than the given amount will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
   * @param {number} [maxAmount] If specified, then only transactions whose amount is equal to or less than the given amount will be regarded. Can contain a positive or negative number with at most two decimal places. Examples: -300.12, or 90.95
   * @param {'all' | 'income' | 'spending'} [direction] If specified, then only transactions with the given direction(s) will be regarded. Use \&#39;income\&#39; for regarding only received payments (amount &gt;&#x3D; 0), \&#39;spending\&#39; for regarding only outgoing payments (amount &lt; 0), or \&#39;all\&#39; to regard both directions. If not specified, the direction defaults to \&#39;all\&#39;.
   * @param {Array<number>} [labelIds] A comma-separated list of label identifiers. If specified, then only transactions that have been marked with at least one of the given labels will be contained in the result.
   * @param {Array<number>} [categoryIds] A comma-separated list of category identifiers. If specified, then the result will contain only transactions whose category is either one of the given categories, or - but only if the \&#39;includeChildCategories\&#39; flag is set to \&#39;true\&#39; - whose category is a sub-category of one of the given categories. To include transactions without any category, pass the value \&#39;0\&#39; as the categoryId.
   * @param {boolean} [includeChildCategories] This flag controls how the given \&#39;categoryIds\&#39; are handled. If set to \&#39;true\&#39;, then all transactions of a given categoryId, as well as all transactions of any of its sub-categories will be regarded. If set to \&#39;false\&#39;, then sub-categories of a given categoryId will not be regarded and only those transactions are regarded whose category matches one of the explicitly given categoryIds. The default value for this flag is \&#39;true\&#39;.
   * @param {boolean} [isNew] If specified, then only transactions that have their \&#39;isNew\&#39; flag set to true/false will be regarded.
   * @param {boolean} [isPotentialDuplicate] If specified, then only transactions that have their \&#39;isPotentialDuplicate\&#39; flag set to true/false will be regarded.
   * @param {boolean} [isAdjustingEntry] If specified, then only transactions that have their \&#39;isAdjustingEntry\&#39; flag set to true/false will be regarded.
   * @param {string} [minImportDate] Lower bound for a transaction\&#39;s import date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;importDate\&#39; is equal to or later than the given date will be regarded.
   * @param {string} [maxImportDate] Upper bound for a transaction\&#39;s import date, in the format \&#39;YYYY-MM-DD\&#39; (e.g. \&#39;2016-01-01\&#39;). If specified, then only transactions whose \&#39;importDate\&#39; is equal to or earlier than the given date will be regarded.
   * @param {number} [page] Result page that you want to retrieve.
   * @param {number} [perPage] Maximum number of records per page. Can be at most 500. NOTE: Due to its validation and visualization, the swagger frontend might show very low performance, or even crashes, when a service responds with a lot of data. It is recommended to use a HTTP client like Postman or DHC instead of our swagger frontend for service calls with large page sizes.
   * @param {Array<string>} [order] Determines the order of the results. You can use the following fields for ordering the response: \&#39;id\&#39;, \&#39;parentId\&#39;, \&#39;accountId\&#39;, \&#39;valueDate\&#39;, \&#39;bankBookingDate\&#39;, \&#39;finapiBookingDate\&#39;, \&#39;amount\&#39;, \&#39;purpose\&#39;, \&#39;counterpartName\&#39;, \&#39;counterpartAccountNumber\&#39;, \&#39;counterpartIban\&#39;, \&#39;counterpartBlz\&#39;, \&#39;counterpartBic\&#39;, \&#39;type\&#39;, \&#39;primanota\&#39;, \&#39;category.id\&#39;, \&#39;category.name\&#39;, \&#39;isPotentialDuplicate\&#39;, \&#39;isNew\&#39; and \&#39;importDate\&#39;. The default order for all services is \&#39;id,asc\&#39;. You can also order by multiple properties. In that case the order of the parameters passed is important. Example: \&#39;/transactions?order&#x3D;finapiBookingDate,desc&amp;order&#x3D;counterpartName\&#39; will return the latest transactions first. If there are more transactions on the same day, then these transactions are ordered by the counterpart name (ascending). The general format is: \&#39;property[,asc|desc]\&#39;, with \&#39;asc\&#39; being the default value. Please note that ordering by multiple fields is not supported in our swagger frontend, but you can test this feature with any HTTP tool of your choice (e.g. postman or DHC).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public getAndSearchAllTransactions(
    view: "bankView" | "userView",
    ids?: Array<number>,
    search?: string,
    counterpart?: string,
    purpose?: string,
    accountIds?: Array<number>,
    minBankBookingDate?: string,
    maxBankBookingDate?: string,
    minFinapiBookingDate?: string,
    maxFinapiBookingDate?: string,
    minAmount?: number,
    maxAmount?: number,
    direction?: "all" | "income" | "spending",
    labelIds?: Array<number>,
    categoryIds?: Array<number>,
    includeChildCategories?: boolean,
    isNew?: boolean,
    isPotentialDuplicate?: boolean,
    isAdjustingEntry?: boolean,
    minImportDate?: string,
    maxImportDate?: string,
    page?: number,
    perPage?: number,
    order?: Array<string>,
    options?: any
  ) {
    return TransactionsApiFp(this.configuration).getAndSearchAllTransactions(
      view,
      ids,
      search,
      counterpart,
      purpose,
      accountIds,
      minBankBookingDate,
      maxBankBookingDate,
      minFinapiBookingDate,
      maxFinapiBookingDate,
      minAmount,
      maxAmount,
      direction,
      labelIds,
      categoryIds,
      includeChildCategories,
      isNew,
      isPotentialDuplicate,
      isAdjustingEntry,
      minImportDate,
      maxImportDate,
      page,
      perPage,
      order,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Get a list of multiple transactions of the user that is authorized by the access_token. Must pass the transactions\' identifiers and the user\'s access_token. Transactions whose identifiers do not exist or do not relate to the authorized user will not be contained in the result (If this applies to all of the given identifiers, then the result will be an empty list). WARNING: This service is deprecated and will be removed at some point. If you want to get multiple transactions, please instead use the service \'Get and search all transactions\', where you can pass a comma-separated list of identifiers.
   * @summary Get multiple transactions
   * @param {Array<number>} ids Comma-separated list of identifiers of requested transactions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public getMultipleTransactions(ids: Array<number>, options?: any) {
    return TransactionsApiFp(this.configuration).getMultipleTransactions(
      ids,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Get a single transaction of the user that is authorized by the access_token. Must pass the transaction\'s identifier and the user\'s access_token.
   * @summary Get a transaction
   * @param {number} id Identifier of transaction
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public getTransaction(id: number, options?: any) {
    return TransactionsApiFp(this.configuration).getTransaction(id, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Restore a previously split transaction. Removes all of its sub-transactions.
   * @summary Restore a transaction
   * @param {number} id Transaction identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public restoreTransaction(id: number, options?: any) {
    return TransactionsApiFp(this.configuration).restoreTransaction(
      id,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Split a transaction into several logical sub-transactions. If the given transaction is split already, all its current sub-transactions will get deleted before the new sub-transactions will get created.
   * @summary Split a transaction
   * @param {number} id Transaction identifier
   * @param {SplitTransactionsParams} body Split transactions parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public splitTransaction(
    id: number,
    body: SplitTransactionsParams,
    options?: any
  ) {
    return TransactionsApiFp(this.configuration).splitTransaction(
      id,
      body,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Triggers finAPI\'s background categorization process for all uncategorized transactions of the given bank connection(s) (or of all of the user\'s bank connections, if no bank connection identifiers are passed). The service returns as soon as the categorizations are scheduled. At this point, the bank connections will have their \'categorizationStatus\' set to \'PENDING\'. Use the service \"Get a bank connection\" or \"Get all bank connections\" to check when the categorization has finished (this is the case when the categorizationStatus has switched to \'READY\').<br/><br/>Note that if at least one of the target bank connections is currently locked at the time when you call this service (i.e. the bank connection is currently being updated, or another categorization is already scheduled for it), then no categorization will be triggered at all and the service will respond with HTTP code 422.<br/><br/>Please also note:<br/>&bull; finAPI\'s background categorization process is executed automatically whenever you import or update a bank connection (though in case of update, it will categorize only the new transactions, and not re-run categorization for previously imported transactions). This means that in general you do not have to call this service after an import or update. Use this service only when you wish to re-run the categorization of all existing uncategorized transactions.<br/>&bull; if you wish to just manually assign categories to transactions, please use the service \"Edit a transaction\" or \"Edit multiple transactions\" instead.
   * @summary Trigger categorization
   * @param {TriggerCategorizationParams} body Trigger categorization parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TransactionsApi
   */
  public triggerCategorization(
    body: TriggerCategorizationParams,
    options?: any
  ) {
    return TransactionsApiFp(this.configuration).triggerCategorization(
      body,
      options
    )(this.axios, this.basePath);
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * <p>Create a new user. Must pass your global (i.e. client) access_token. </p><p>This service returns the user\'s password as plain text. </p><p>The automatic update of the user\'s bank connections is disabled by default for any new user. User identifiers are regarded case-insensitive by finAPI.</p><p>Please note that finAPI generally has a restricted set of allowed characters for input fields. You can find the allowed characters <a href = \"https://finapi.zendesk.com/hc/en-us/articles/222013148-What-symbols-are-allowed-in-finAPI-\">here</a>. If a field does not explicitly specify a set of allowed characters, then these are the characters that are allowed for the field. Some fields may specify a different set of characters, in which case this will be documented for the field (like for the \'id\' field in this service).</p>
     * @summary Create a new user
     * @param {UserCreateParams} body User\&#39;s details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(body: UserCreateParams, options: any = {}): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling createUser."
        );
      }
      const localVarPath = `/api/v1/users`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"UserCreateParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete the authorized user. Must pass the user\'s access_token. ATTENTION: This deletes the user including all of his bank connections, accounts, balance data and transactions! THIS PROCESS CANNOT BE UNDONE! Note that a user cannot get deleted while any of his bank connections are currently busy (in the process of import, update, or transactions categorization). <p>Note: finAPI will send a notification about the deletion of the user to each of your clients that has a user synchronization callback URL set in its configuration. This also includes the client that is performing this request.</p>
     * @summary Delete the authorized user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAuthorizedUser(options: any = {}): RequestArgs {
      const localVarPath = `/api/v1/users`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Delete an unverified user. Must pass your global (i.e. client) access_token.<br/><br/>Notes:<br/>&bull; Unverified users can only exist if the field \'isUserAutoVerificationEnabled\' (see Client Configuration Resource) is set to \'false\' (or had been false at some point in the past).<br/>&bull; finAPI will send a notification about the deletion of the user to each of your clients that has a user synchronization callback URL set in its configuration. This also includes the client that is performing this request.<br/>&bull; finAPI regards user identifiers case-insensitive.
     * @summary Delete an unverified user
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUnverifiedUser(userId: string, options: any = {}): RequestArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          "userId",
          "Required parameter userId was null or undefined when calling deleteUnverifiedUser."
        );
      }
      const localVarPath = `/api/v1/users/{userId}`.replace(
        `{${"userId"}}`,
        encodeURIComponent(String(userId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Edit the authorized user\'s data and settings. Must pass the user\'s access_token. Pass an empty string (but not null) to unset either the email or phone number. At least one field must have a non-null value in the request body. This service returns the user\'s password as \'XXXXX\'.
     * @summary Edit the authorized user
     * @param {UserUpdateParams} body User\&#39;s details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editAuthorizedUser(body: UserUpdateParams, options: any = {}): RequestArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling editAuthorizedUser."
        );
      }
      const localVarPath = `/api/v1/users`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"UserUpdateParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Change the password of a user. Must pass your global (i.e. client) access_token.<br/><br/>Note: When changing the password of a user, all tokens that have been handed out for that user (for whatever client) will be revoked! Also note that finAPI regards user identifiers case-insensitive.
     * @summary Execute password change
     * @param {ExecutePasswordChangeParams} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executePasswordChange(
      body?: ExecutePasswordChangeParams,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/api/v1/users/executePasswordChange`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"ExecutePasswordChangeParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get the authorized user\'s data. Must pass the user\'s access_token. Only the authorized user can get his data, i.e. his access_token must be used. This service returns the user\'s password as \'XXXXX\'.
     * @summary Get the authorized user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthorizedUser(options: any = {}): RequestArgs {
      const localVarPath = `/api/v1/users`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Get the verification status of the requested user. Must pass your global (i.e. client) access_token. Note that finAPI regards user identifiers case-insensitive.
     * @summary Get a user\'s verification status
     * @param {string} userId User\&#39;s identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVerificationStatus(userId: string, options: any = {}): RequestArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          "userId",
          "Required parameter userId was null or undefined when calling getVerificationStatus."
        );
      }
      const localVarPath = `/api/v1/users/verificationStatus`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      if (userId !== undefined) {
        localVarQueryParameter["userId"] = userId;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Request password change for a user. Must pass your global (i.e. client) access_token. Note that finAPI regards user identifiers case-insensitive.
     * @summary Request password change
     * @param {RequestPasswordChangeParams} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestPasswordChange(
      body?: RequestPasswordChangeParams,
      options: any = {}
    ): RequestArgs {
      const localVarPath = `/api/v1/users/requestPasswordChange`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };
      const needsSerialization =
        <any>"RequestPasswordChangeParams" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || "";

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    },
    /**
     * Verify a user. User verification is only required when your client does not have auto-verification enabled (see field \'isUserAutoVerificationEnabled\' in Client Configuration Resource). Must pass your global (i.e. client) access_token. Note that finAPI regards user identifiers case-insensitive.
     * @summary Verify a user
     * @param {string} userId User\&#39;s identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyUser(userId: string, options: any = {}): RequestArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          "userId",
          "Required parameter userId was null or undefined when calling verifyUser."
        );
      }
      const localVarPath = `/api/v1/users/verify/{userId}`.replace(
        `{${"userId"}}`,
        encodeURIComponent(String(userId))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
  return {
    /**
     * <p>Create a new user. Must pass your global (i.e. client) access_token. </p><p>This service returns the user\'s password as plain text. </p><p>The automatic update of the user\'s bank connections is disabled by default for any new user. User identifiers are regarded case-insensitive by finAPI.</p><p>Please note that finAPI generally has a restricted set of allowed characters for input fields. You can find the allowed characters <a href = \"https://finapi.zendesk.com/hc/en-us/articles/222013148-What-symbols-are-allowed-in-finAPI-\">here</a>. If a field does not explicitly specify a set of allowed characters, then these are the characters that are allowed for the field. Some fields may specify a different set of characters, in which case this will be documented for the field (like for the \'id\' field in this service).</p>
     * @summary Create a new user
     * @param {UserCreateParams} body User\&#39;s details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(
      body: UserCreateParams,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
      const localVarAxiosArgs = UsersApiAxiosParamCreator(
        configuration
      ).createUser(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Delete the authorized user. Must pass the user\'s access_token. ATTENTION: This deletes the user including all of his bank connections, accounts, balance data and transactions! THIS PROCESS CANNOT BE UNDONE! Note that a user cannot get deleted while any of his bank connections are currently busy (in the process of import, update, or transactions categorization). <p>Note: finAPI will send a notification about the deletion of the user to each of your clients that has a user synchronization callback URL set in its configuration. This also includes the client that is performing this request.</p>
     * @summary Delete the authorized user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAuthorizedUser(
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = UsersApiAxiosParamCreator(
        configuration
      ).deleteAuthorizedUser(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Delete an unverified user. Must pass your global (i.e. client) access_token.<br/><br/>Notes:<br/>&bull; Unverified users can only exist if the field \'isUserAutoVerificationEnabled\' (see Client Configuration Resource) is set to \'false\' (or had been false at some point in the past).<br/>&bull; finAPI will send a notification about the deletion of the user to each of your clients that has a user synchronization callback URL set in its configuration. This also includes the client that is performing this request.<br/>&bull; finAPI regards user identifiers case-insensitive.
     * @summary Delete an unverified user
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUnverifiedUser(
      userId: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = UsersApiAxiosParamCreator(
        configuration
      ).deleteUnverifiedUser(userId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Edit the authorized user\'s data and settings. Must pass the user\'s access_token. Pass an empty string (but not null) to unset either the email or phone number. At least one field must have a non-null value in the request body. This service returns the user\'s password as \'XXXXX\'.
     * @summary Edit the authorized user
     * @param {UserUpdateParams} body User\&#39;s details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editAuthorizedUser(
      body: UserUpdateParams,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
      const localVarAxiosArgs = UsersApiAxiosParamCreator(
        configuration
      ).editAuthorizedUser(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Change the password of a user. Must pass your global (i.e. client) access_token.<br/><br/>Note: When changing the password of a user, all tokens that have been handed out for that user (for whatever client) will be revoked! Also note that finAPI regards user identifiers case-insensitive.
     * @summary Execute password change
     * @param {ExecutePasswordChangeParams} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executePasswordChange(
      body?: ExecutePasswordChangeParams,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = UsersApiAxiosParamCreator(
        configuration
      ).executePasswordChange(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get the authorized user\'s data. Must pass the user\'s access_token. Only the authorized user can get his data, i.e. his access_token must be used. This service returns the user\'s password as \'XXXXX\'.
     * @summary Get the authorized user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthorizedUser(
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User> {
      const localVarAxiosArgs = UsersApiAxiosParamCreator(
        configuration
      ).getAuthorizedUser(options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get the verification status of the requested user. Must pass your global (i.e. client) access_token. Note that finAPI regards user identifiers case-insensitive.
     * @summary Get a user\'s verification status
     * @param {string} userId User\&#39;s identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVerificationStatus(
      userId: string,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<VerificationStatusResource> {
      const localVarAxiosArgs = UsersApiAxiosParamCreator(
        configuration
      ).getVerificationStatus(userId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Request password change for a user. Must pass your global (i.e. client) access_token. Note that finAPI regards user identifiers case-insensitive.
     * @summary Request password change
     * @param {RequestPasswordChangeParams} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestPasswordChange(
      body?: RequestPasswordChangeParams,
      options?: any
    ): (
      axios?: AxiosInstance,
      basePath?: string
    ) => AxiosPromise<PasswordChangingResource> {
      const localVarAxiosArgs = UsersApiAxiosParamCreator(
        configuration
      ).requestPasswordChange(body, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Verify a user. User verification is only required when your client does not have auto-verification enabled (see field \'isUserAutoVerificationEnabled\' in Client Configuration Resource). Must pass your global (i.e. client) access_token. Note that finAPI regards user identifiers case-insensitive.
     * @summary Verify a user
     * @param {string} userId User\&#39;s identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyUser(
      userId: string,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void> {
      const localVarAxiosArgs = UsersApiAxiosParamCreator(
        configuration
      ).verifyUser(userId, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    }
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * <p>Create a new user. Must pass your global (i.e. client) access_token. </p><p>This service returns the user\'s password as plain text. </p><p>The automatic update of the user\'s bank connections is disabled by default for any new user. User identifiers are regarded case-insensitive by finAPI.</p><p>Please note that finAPI generally has a restricted set of allowed characters for input fields. You can find the allowed characters <a href = \"https://finapi.zendesk.com/hc/en-us/articles/222013148-What-symbols-are-allowed-in-finAPI-\">here</a>. If a field does not explicitly specify a set of allowed characters, then these are the characters that are allowed for the field. Some fields may specify a different set of characters, in which case this will be documented for the field (like for the \'id\' field in this service).</p>
     * @summary Create a new user
     * @param {UserCreateParams} body User\&#39;s details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(body: UserCreateParams, options?: any) {
      return UsersApiFp(configuration).createUser(body, options)(
        axios,
        basePath
      );
    },
    /**
     * Delete the authorized user. Must pass the user\'s access_token. ATTENTION: This deletes the user including all of his bank connections, accounts, balance data and transactions! THIS PROCESS CANNOT BE UNDONE! Note that a user cannot get deleted while any of his bank connections are currently busy (in the process of import, update, or transactions categorization). <p>Note: finAPI will send a notification about the deletion of the user to each of your clients that has a user synchronization callback URL set in its configuration. This also includes the client that is performing this request.</p>
     * @summary Delete the authorized user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAuthorizedUser(options?: any) {
      return UsersApiFp(configuration).deleteAuthorizedUser(options)(
        axios,
        basePath
      );
    },
    /**
     * Delete an unverified user. Must pass your global (i.e. client) access_token.<br/><br/>Notes:<br/>&bull; Unverified users can only exist if the field \'isUserAutoVerificationEnabled\' (see Client Configuration Resource) is set to \'false\' (or had been false at some point in the past).<br/>&bull; finAPI will send a notification about the deletion of the user to each of your clients that has a user synchronization callback URL set in its configuration. This also includes the client that is performing this request.<br/>&bull; finAPI regards user identifiers case-insensitive.
     * @summary Delete an unverified user
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUnverifiedUser(userId: string, options?: any) {
      return UsersApiFp(configuration).deleteUnverifiedUser(userId, options)(
        axios,
        basePath
      );
    },
    /**
     * Edit the authorized user\'s data and settings. Must pass the user\'s access_token. Pass an empty string (but not null) to unset either the email or phone number. At least one field must have a non-null value in the request body. This service returns the user\'s password as \'XXXXX\'.
     * @summary Edit the authorized user
     * @param {UserUpdateParams} body User\&#39;s details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editAuthorizedUser(body: UserUpdateParams, options?: any) {
      return UsersApiFp(configuration).editAuthorizedUser(body, options)(
        axios,
        basePath
      );
    },
    /**
     * Change the password of a user. Must pass your global (i.e. client) access_token.<br/><br/>Note: When changing the password of a user, all tokens that have been handed out for that user (for whatever client) will be revoked! Also note that finAPI regards user identifiers case-insensitive.
     * @summary Execute password change
     * @param {ExecutePasswordChangeParams} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    executePasswordChange(body?: ExecutePasswordChangeParams, options?: any) {
      return UsersApiFp(configuration).executePasswordChange(body, options)(
        axios,
        basePath
      );
    },
    /**
     * Get the authorized user\'s data. Must pass the user\'s access_token. Only the authorized user can get his data, i.e. his access_token must be used. This service returns the user\'s password as \'XXXXX\'.
     * @summary Get the authorized user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthorizedUser(options?: any) {
      return UsersApiFp(configuration).getAuthorizedUser(options)(
        axios,
        basePath
      );
    },
    /**
     * Get the verification status of the requested user. Must pass your global (i.e. client) access_token. Note that finAPI regards user identifiers case-insensitive.
     * @summary Get a user\'s verification status
     * @param {string} userId User\&#39;s identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVerificationStatus(userId: string, options?: any) {
      return UsersApiFp(configuration).getVerificationStatus(userId, options)(
        axios,
        basePath
      );
    },
    /**
     * Request password change for a user. Must pass your global (i.e. client) access_token. Note that finAPI regards user identifiers case-insensitive.
     * @summary Request password change
     * @param {RequestPasswordChangeParams} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestPasswordChange(body?: RequestPasswordChangeParams, options?: any) {
      return UsersApiFp(configuration).requestPasswordChange(body, options)(
        axios,
        basePath
      );
    },
    /**
     * Verify a user. User verification is only required when your client does not have auto-verification enabled (see field \'isUserAutoVerificationEnabled\' in Client Configuration Resource). Must pass your global (i.e. client) access_token. Note that finAPI regards user identifiers case-insensitive.
     * @summary Verify a user
     * @param {string} userId User\&#39;s identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyUser(userId: string, options?: any) {
      return UsersApiFp(configuration).verifyUser(userId, options)(
        axios,
        basePath
      );
    }
  };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   * <p>Create a new user. Must pass your global (i.e. client) access_token. </p><p>This service returns the user\'s password as plain text. </p><p>The automatic update of the user\'s bank connections is disabled by default for any new user. User identifiers are regarded case-insensitive by finAPI.</p><p>Please note that finAPI generally has a restricted set of allowed characters for input fields. You can find the allowed characters <a href = \"https://finapi.zendesk.com/hc/en-us/articles/222013148-What-symbols-are-allowed-in-finAPI-\">here</a>. If a field does not explicitly specify a set of allowed characters, then these are the characters that are allowed for the field. Some fields may specify a different set of characters, in which case this will be documented for the field (like for the \'id\' field in this service).</p>
   * @summary Create a new user
   * @param {UserCreateParams} body User\&#39;s details
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public createUser(body: UserCreateParams, options?: any) {
    return UsersApiFp(this.configuration).createUser(body, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Delete the authorized user. Must pass the user\'s access_token. ATTENTION: This deletes the user including all of his bank connections, accounts, balance data and transactions! THIS PROCESS CANNOT BE UNDONE! Note that a user cannot get deleted while any of his bank connections are currently busy (in the process of import, update, or transactions categorization). <p>Note: finAPI will send a notification about the deletion of the user to each of your clients that has a user synchronization callback URL set in its configuration. This also includes the client that is performing this request.</p>
   * @summary Delete the authorized user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public deleteAuthorizedUser(options?: any) {
    return UsersApiFp(this.configuration).deleteAuthorizedUser(options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Delete an unverified user. Must pass your global (i.e. client) access_token.<br/><br/>Notes:<br/>&bull; Unverified users can only exist if the field \'isUserAutoVerificationEnabled\' (see Client Configuration Resource) is set to \'false\' (or had been false at some point in the past).<br/>&bull; finAPI will send a notification about the deletion of the user to each of your clients that has a user synchronization callback URL set in its configuration. This also includes the client that is performing this request.<br/>&bull; finAPI regards user identifiers case-insensitive.
   * @summary Delete an unverified user
   * @param {string} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public deleteUnverifiedUser(userId: string, options?: any) {
    return UsersApiFp(this.configuration).deleteUnverifiedUser(userId, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Edit the authorized user\'s data and settings. Must pass the user\'s access_token. Pass an empty string (but not null) to unset either the email or phone number. At least one field must have a non-null value in the request body. This service returns the user\'s password as \'XXXXX\'.
   * @summary Edit the authorized user
   * @param {UserUpdateParams} body User\&#39;s details
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public editAuthorizedUser(body: UserUpdateParams, options?: any) {
    return UsersApiFp(this.configuration).editAuthorizedUser(body, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Change the password of a user. Must pass your global (i.e. client) access_token.<br/><br/>Note: When changing the password of a user, all tokens that have been handed out for that user (for whatever client) will be revoked! Also note that finAPI regards user identifiers case-insensitive.
   * @summary Execute password change
   * @param {ExecutePasswordChangeParams} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public executePasswordChange(
    body?: ExecutePasswordChangeParams,
    options?: any
  ) {
    return UsersApiFp(this.configuration).executePasswordChange(body, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Get the authorized user\'s data. Must pass the user\'s access_token. Only the authorized user can get his data, i.e. his access_token must be used. This service returns the user\'s password as \'XXXXX\'.
   * @summary Get the authorized user
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getAuthorizedUser(options?: any) {
    return UsersApiFp(this.configuration).getAuthorizedUser(options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Get the verification status of the requested user. Must pass your global (i.e. client) access_token. Note that finAPI regards user identifiers case-insensitive.
   * @summary Get a user\'s verification status
   * @param {string} userId User\&#39;s identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getVerificationStatus(userId: string, options?: any) {
    return UsersApiFp(this.configuration).getVerificationStatus(
      userId,
      options
    )(this.axios, this.basePath);
  }

  /**
   * Request password change for a user. Must pass your global (i.e. client) access_token. Note that finAPI regards user identifiers case-insensitive.
   * @summary Request password change
   * @param {RequestPasswordChangeParams} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public requestPasswordChange(
    body?: RequestPasswordChangeParams,
    options?: any
  ) {
    return UsersApiFp(this.configuration).requestPasswordChange(body, options)(
      this.axios,
      this.basePath
    );
  }

  /**
   * Verify a user. User verification is only required when your client does not have auto-verification enabled (see field \'isUserAutoVerificationEnabled\' in Client Configuration Resource). Must pass your global (i.e. client) access_token. Note that finAPI regards user identifiers case-insensitive.
   * @summary Verify a user
   * @param {string} userId User\&#39;s identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public verifyUser(userId: string, options?: any) {
    return UsersApiFp(this.configuration).verifyUser(userId, options)(
      this.axios,
      this.basePath
    );
  }
}

/**
 * WebFormsApi - axios parameter creator
 * @export
 */
export const WebFormsApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * Get a web form of the user that is authorized by the access_token. Must pass the web form\'s identifier and the user\'s access_token. <br/><br/>Note that every web form resource is automatically removed from the finAPI system after 24 hours after its creation.
     * @summary Get a web form
     * @param {number} id Identifier of web form
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebForm(id: number, options: any = {}): RequestArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getWebForm."
        );
      }
      const localVarPath = `/api/v1/webForms/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication finapi_auth required
      // oauth required
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue =
          typeof configuration.accessToken === "function"
            ? configuration.accessToken("finapi_auth", ["all"])
            : configuration.accessToken;
        localVarHeaderParameter["Authorization"] =
          "Bearer " + localVarAccessTokenValue;
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query
      };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...options.headers
      };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions
      };
    }
  };
};

/**
 * WebFormsApi - functional programming interface
 * @export
 */
export const WebFormsApiFp = function(configuration?: Configuration) {
  return {
    /**
     * Get a web form of the user that is authorized by the access_token. Must pass the web form\'s identifier and the user\'s access_token. <br/><br/>Note that every web form resource is automatically removed from the finAPI system after 24 hours after its creation.
     * @summary Get a web form
     * @param {number} id Identifier of web form
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebForm(
      id: number,
      options?: any
    ): (axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebForm> {
      const localVarAxiosArgs = WebFormsApiAxiosParamCreator(
        configuration
      ).getWebForm(id, options);
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url
        };
        return axios.request(axiosRequestArgs);
      };
    }
  };
};

/**
 * WebFormsApi - factory interface
 * @export
 */
export const WebFormsApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     * Get a web form of the user that is authorized by the access_token. Must pass the web form\'s identifier and the user\'s access_token. <br/><br/>Note that every web form resource is automatically removed from the finAPI system after 24 hours after its creation.
     * @summary Get a web form
     * @param {number} id Identifier of web form
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWebForm(id: number, options?: any) {
      return WebFormsApiFp(configuration).getWebForm(id, options)(
        axios,
        basePath
      );
    }
  };
};

/**
 * WebFormsApi - object-oriented interface
 * @export
 * @class WebFormsApi
 * @extends {BaseAPI}
 */
export class WebFormsApi extends BaseAPI {
  /**
   * Get a web form of the user that is authorized by the access_token. Must pass the web form\'s identifier and the user\'s access_token. <br/><br/>Note that every web form resource is automatically removed from the finAPI system after 24 hours after its creation.
   * @summary Get a web form
   * @param {number} id Identifier of web form
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WebFormsApi
   */
  public getWebForm(id: number, options?: any) {
    return WebFormsApiFp(this.configuration).getWebForm(id, options)(
      this.axios,
      this.basePath
    );
  }
}
